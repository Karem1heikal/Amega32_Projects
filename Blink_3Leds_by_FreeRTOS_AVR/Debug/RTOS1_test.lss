
RTOS2_test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005138  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000024  00800060  00005138  000051cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000049f  00800084  00800084  000051f0  2**0
                  ALLOC
  3 .stab         00006a2c  00000000  00000000  000051f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003bdb  00000000  00000000  0000bc1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000f7f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000f937  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000faa7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  000116f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  000125db  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00013388  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  000134e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00013775  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00013f43  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 00 1b 	jmp	0x3600	; 0x3600 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 55 07 	jmp	0xeaa	; 0xeaa <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e3       	ldi	r30, 0x38	; 56
      68:	f1 e5       	ldi	r31, 0x51	; 81
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 38       	cpi	r26, 0x84	; 132
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a4 e8       	ldi	r26, 0x84	; 132
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 32       	cpi	r26, 0x23	; 35
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <main>
      8a:	0c 94 9a 28 	jmp	0x5134	; 0x5134 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 44 28 	jmp	0x5088	; 0x5088 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a9 e7       	ldi	r26, 0x79	; 121
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 60 28 	jmp	0x50c0	; 0x50c0 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 6c 28 	jmp	0x50d8	; 0x50d8 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 6c 28 	jmp	0x50d8	; 0x50d8 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 44 28 	jmp	0x5088	; 0x5088 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	89 e7       	ldi	r24, 0x79	; 121
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 60 28 	jmp	0x50c0	; 0x50c0 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 6c 28 	jmp	0x50d8	; 0x50d8 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 6c 28 	jmp	0x50d8	; 0x50d8 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 6c 28 	jmp	0x50d8	; 0x50d8 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 54 28 	jmp	0x50a8	; 0x50a8 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 70 28 	jmp	0x50e0	; 0x50e0 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <ADC_voidInit>:
static u8 * ADC_pu8ChannelNum = NULL;
static u8 ADC_u8ChannelSize ;
static void (*Global_vChainCallBackFunc)() = NULL;
static u16 * ADC_pu16ChannelReading = NULL;
void ADC_voidInit()
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
	ADMUX &= MASK_AREF;
     b4e:	a7 e2       	ldi	r26, 0x27	; 39
     b50:	b0 e0       	ldi	r27, 0x00	; 0
     b52:	e7 e2       	ldi	r30, 0x27	; 39
     b54:	f0 e0       	ldi	r31, 0x00	; 0
     b56:	80 81       	ld	r24, Z
     b58:	8f 73       	andi	r24, 0x3F	; 63
     b5a:	8c 93       	st	X, r24
	ADMUX |= ADC_REF_VOLT<<ADMUX_REFS0;
     b5c:	a7 e2       	ldi	r26, 0x27	; 39
     b5e:	b0 e0       	ldi	r27, 0x00	; 0
     b60:	e7 e2       	ldi	r30, 0x27	; 39
     b62:	f0 e0       	ldi	r31, 0x00	; 0
     b64:	80 81       	ld	r24, Z
     b66:	80 64       	ori	r24, 0x40	; 64
     b68:	8c 93       	st	X, r24
#if ADC_ADJUST_BIT == LEFT_ADJUST
	SET_BIT(ADMUX,ADMUX_ADLAR);
     b6a:	a7 e2       	ldi	r26, 0x27	; 39
     b6c:	b0 e0       	ldi	r27, 0x00	; 0
     b6e:	e7 e2       	ldi	r30, 0x27	; 39
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	80 81       	ld	r24, Z
     b74:	80 62       	ori	r24, 0x20	; 32
     b76:	8c 93       	st	X, r24
#elif ADC_ADJUST_BIT == RIGHT_ADJUST
	CLR_BIT(ADMUX,ADMUX_ADLAR);
#else
#error "Wrong in choosing configuration of ADC_ADJUST_BIT "
#endif
	ADCSRA &= MASK_CLK_RATE;
     b78:	a6 e2       	ldi	r26, 0x26	; 38
     b7a:	b0 e0       	ldi	r27, 0x00	; 0
     b7c:	e6 e2       	ldi	r30, 0x26	; 38
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	80 81       	ld	r24, Z
     b82:	88 7f       	andi	r24, 0xF8	; 248
     b84:	8c 93       	st	X, r24
	ADCSRA |= ADC_CLK_RATE<<ADCSRA_ADPS0;
     b86:	a6 e2       	ldi	r26, 0x26	; 38
     b88:	b0 e0       	ldi	r27, 0x00	; 0
     b8a:	e6 e2       	ldi	r30, 0x26	; 38
     b8c:	f0 e0       	ldi	r31, 0x00	; 0
     b8e:	80 81       	ld	r24, Z
     b90:	86 60       	ori	r24, 0x06	; 6
     b92:	8c 93       	st	X, r24
	SFIOR &= MASK_AUTO_TRIGGER;
	SFIOR |= ADC_AUTO_TRIGGER_SRC << SFIOR_ADTS0;

	SET_BIT(ADCSRA,ADCSRA_ADSC);
#elif ADC_AUTO_TRIGGER_MODE == DISABLE
	CLR_BIT(ADCSRA,ADCSRA_ADATE);
     b94:	a6 e2       	ldi	r26, 0x26	; 38
     b96:	b0 e0       	ldi	r27, 0x00	; 0
     b98:	e6 e2       	ldi	r30, 0x26	; 38
     b9a:	f0 e0       	ldi	r31, 0x00	; 0
     b9c:	80 81       	ld	r24, Z
     b9e:	8f 7d       	andi	r24, 0xDF	; 223
     ba0:	8c 93       	st	X, r24
#else
#error "Wrong in choosing configuration of ADC_AUTO_TRIGGER_MODE "
#endif
	SET_BIT(ADCSRA,ADCSRA_ADEN);
     ba2:	a6 e2       	ldi	r26, 0x26	; 38
     ba4:	b0 e0       	ldi	r27, 0x00	; 0
     ba6:	e6 e2       	ldi	r30, 0x26	; 38
     ba8:	f0 e0       	ldi	r31, 0x00	; 0
     baa:	80 81       	ld	r24, Z
     bac:	80 68       	ori	r24, 0x80	; 128
     bae:	8c 93       	st	X, r24
}
     bb0:	cf 91       	pop	r28
     bb2:	df 91       	pop	r29
     bb4:	08 95       	ret

00000bb6 <ADC_u8StartSingleConvPoll>:
// Synch applay Busy Flag For reenterrant
u8 ADC_u8StartSingleConvPoll(u8 Copy_u8Channel,u16 *Copy_pu16Read)
{
     bb6:	df 93       	push	r29
     bb8:	cf 93       	push	r28
     bba:	cd b7       	in	r28, 0x3d	; 61
     bbc:	de b7       	in	r29, 0x3e	; 62
     bbe:	28 97       	sbiw	r28, 0x08	; 8
     bc0:	0f b6       	in	r0, 0x3f	; 63
     bc2:	f8 94       	cli
     bc4:	de bf       	out	0x3e, r29	; 62
     bc6:	0f be       	out	0x3f, r0	; 63
     bc8:	cd bf       	out	0x3d, r28	; 61
     bca:	8e 83       	std	Y+6, r24	; 0x06
     bcc:	78 87       	std	Y+8, r23	; 0x08
     bce:	6f 83       	std	Y+7, r22	; 0x07
	u8 Local_u8ErrorState = OK;
     bd0:	1d 82       	std	Y+5, r1	; 0x05
	u32 Local_u32Counter = 0;
     bd2:	19 82       	std	Y+1, r1	; 0x01
     bd4:	1a 82       	std	Y+2, r1	; 0x02
     bd6:	1b 82       	std	Y+3, r1	; 0x03
     bd8:	1c 82       	std	Y+4, r1	; 0x04
	if(Global_u8BusyFlag==IDLE)
     bda:	80 91 84 00 	lds	r24, 0x0084
     bde:	88 23       	and	r24, r24
     be0:	09 f0       	breq	.+2      	; 0xbe4 <ADC_u8StartSingleConvPoll+0x2e>
     be2:	6e c0       	rjmp	.+220    	; 0xcc0 <ADC_u8StartSingleConvPoll+0x10a>
	{
		Global_u8BusyFlag = BUSY;
     be4:	81 e0       	ldi	r24, 0x01	; 1
     be6:	80 93 84 00 	sts	0x0084, r24
		if(Copy_pu16Read != NULL)
     bea:	8f 81       	ldd	r24, Y+7	; 0x07
     bec:	98 85       	ldd	r25, Y+8	; 0x08
     bee:	00 97       	sbiw	r24, 0x00	; 0
     bf0:	09 f4       	brne	.+2      	; 0xbf4 <ADC_u8StartSingleConvPoll+0x3e>
     bf2:	63 c0       	rjmp	.+198    	; 0xcba <ADC_u8StartSingleConvPoll+0x104>
		{
				if(Copy_u8Channel<=MAX_OPTION_CHANNEL)
     bf4:	8e 81       	ldd	r24, Y+6	; 0x06
     bf6:	80 32       	cpi	r24, 0x20	; 32
     bf8:	08 f0       	brcs	.+2      	; 0xbfc <ADC_u8StartSingleConvPoll+0x46>
     bfa:	5c c0       	rjmp	.+184    	; 0xcb4 <ADC_u8StartSingleConvPoll+0xfe>
				{
					ADMUX &= MASK_CHANNEL;
     bfc:	a7 e2       	ldi	r26, 0x27	; 39
     bfe:	b0 e0       	ldi	r27, 0x00	; 0
     c00:	e7 e2       	ldi	r30, 0x27	; 39
     c02:	f0 e0       	ldi	r31, 0x00	; 0
     c04:	80 81       	ld	r24, Z
     c06:	80 7e       	andi	r24, 0xE0	; 224
     c08:	8c 93       	st	X, r24
					ADMUX |= Copy_u8Channel<<ADMUX_MUX0;
     c0a:	a7 e2       	ldi	r26, 0x27	; 39
     c0c:	b0 e0       	ldi	r27, 0x00	; 0
     c0e:	e7 e2       	ldi	r30, 0x27	; 39
     c10:	f0 e0       	ldi	r31, 0x00	; 0
     c12:	90 81       	ld	r25, Z
     c14:	8e 81       	ldd	r24, Y+6	; 0x06
     c16:	89 2b       	or	r24, r25
     c18:	8c 93       	st	X, r24
					SET_BIT(ADCSRA,ADCSRA_ADSC);
     c1a:	a6 e2       	ldi	r26, 0x26	; 38
     c1c:	b0 e0       	ldi	r27, 0x00	; 0
     c1e:	e6 e2       	ldi	r30, 0x26	; 38
     c20:	f0 e0       	ldi	r31, 0x00	; 0
     c22:	80 81       	ld	r24, Z
     c24:	80 64       	ori	r24, 0x40	; 64
     c26:	8c 93       	st	X, r24
     c28:	0b c0       	rjmp	.+22     	; 0xc40 <ADC_u8StartSingleConvPoll+0x8a>
					while((GET_BIT(ADCSRA,ADCSRA_ADIF)==0)&&(Local_u32Counter<ADC_U32_TIMEOUT))
					{
						Local_u32Counter++;
     c2a:	89 81       	ldd	r24, Y+1	; 0x01
     c2c:	9a 81       	ldd	r25, Y+2	; 0x02
     c2e:	ab 81       	ldd	r26, Y+3	; 0x03
     c30:	bc 81       	ldd	r27, Y+4	; 0x04
     c32:	01 96       	adiw	r24, 0x01	; 1
     c34:	a1 1d       	adc	r26, r1
     c36:	b1 1d       	adc	r27, r1
     c38:	89 83       	std	Y+1, r24	; 0x01
     c3a:	9a 83       	std	Y+2, r25	; 0x02
     c3c:	ab 83       	std	Y+3, r26	; 0x03
     c3e:	bc 83       	std	Y+4, r27	; 0x04
				if(Copy_u8Channel<=MAX_OPTION_CHANNEL)
				{
					ADMUX &= MASK_CHANNEL;
					ADMUX |= Copy_u8Channel<<ADMUX_MUX0;
					SET_BIT(ADCSRA,ADCSRA_ADSC);
					while((GET_BIT(ADCSRA,ADCSRA_ADIF)==0)&&(Local_u32Counter<ADC_U32_TIMEOUT))
     c40:	e6 e2       	ldi	r30, 0x26	; 38
     c42:	f0 e0       	ldi	r31, 0x00	; 0
     c44:	80 81       	ld	r24, Z
     c46:	82 95       	swap	r24
     c48:	8f 70       	andi	r24, 0x0F	; 15
     c4a:	88 2f       	mov	r24, r24
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	81 70       	andi	r24, 0x01	; 1
     c50:	90 70       	andi	r25, 0x00	; 0
     c52:	00 97       	sbiw	r24, 0x00	; 0
     c54:	61 f4       	brne	.+24     	; 0xc6e <ADC_u8StartSingleConvPoll+0xb8>
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	9a 81       	ldd	r25, Y+2	; 0x02
     c5a:	ab 81       	ldd	r26, Y+3	; 0x03
     c5c:	bc 81       	ldd	r27, Y+4	; 0x04
     c5e:	80 35       	cpi	r24, 0x50	; 80
     c60:	23 ec       	ldi	r18, 0xC3	; 195
     c62:	92 07       	cpc	r25, r18
     c64:	20 e0       	ldi	r18, 0x00	; 0
     c66:	a2 07       	cpc	r26, r18
     c68:	20 e0       	ldi	r18, 0x00	; 0
     c6a:	b2 07       	cpc	r27, r18
     c6c:	f0 f2       	brcs	.-68     	; 0xc2a <ADC_u8StartSingleConvPoll+0x74>
					{
						Local_u32Counter++;
					}
					if(Local_u32Counter==ADC_U32_TIMEOUT)
     c6e:	89 81       	ldd	r24, Y+1	; 0x01
     c70:	9a 81       	ldd	r25, Y+2	; 0x02
     c72:	ab 81       	ldd	r26, Y+3	; 0x03
     c74:	bc 81       	ldd	r27, Y+4	; 0x04
     c76:	80 35       	cpi	r24, 0x50	; 80
     c78:	23 ec       	ldi	r18, 0xC3	; 195
     c7a:	92 07       	cpc	r25, r18
     c7c:	20 e0       	ldi	r18, 0x00	; 0
     c7e:	a2 07       	cpc	r26, r18
     c80:	20 e0       	ldi	r18, 0x00	; 0
     c82:	b2 07       	cpc	r27, r18
     c84:	19 f4       	brne	.+6      	; 0xc8c <ADC_u8StartSingleConvPoll+0xd6>
					{
						Local_u8ErrorState = NOTOK;
     c86:	81 e0       	ldi	r24, 0x01	; 1
     c88:	8d 83       	std	Y+5, r24	; 0x05
     c8a:	1c c0       	rjmp	.+56     	; 0xcc4 <ADC_u8StartSingleConvPoll+0x10e>
					}
					else{

						CLR_BIT(ADCSRA,ADCSRA_ADIF);
     c8c:	a6 e2       	ldi	r26, 0x26	; 38
     c8e:	b0 e0       	ldi	r27, 0x00	; 0
     c90:	e6 e2       	ldi	r30, 0x26	; 38
     c92:	f0 e0       	ldi	r31, 0x00	; 0
     c94:	80 81       	ld	r24, Z
     c96:	8f 7e       	andi	r24, 0xEF	; 239
     c98:	8c 93       	st	X, r24
						if(ADC_ADJUST_BIT == LEFT_ADJUST)
							*Copy_pu16Read = ADC_REG>>8;
     c9a:	e4 e2       	ldi	r30, 0x24	; 36
     c9c:	f0 e0       	ldi	r31, 0x00	; 0
     c9e:	80 81       	ld	r24, Z
     ca0:	91 81       	ldd	r25, Z+1	; 0x01
     ca2:	89 2f       	mov	r24, r25
     ca4:	99 27       	eor	r25, r25
     ca6:	ef 81       	ldd	r30, Y+7	; 0x07
     ca8:	f8 85       	ldd	r31, Y+8	; 0x08
     caa:	91 83       	std	Z+1, r25	; 0x01
     cac:	80 83       	st	Z, r24
						else if(ADC_ADJUST_BIT == RIGHT_ADJUST)
							*Copy_pu16Read = ADC_REG;
						Global_u8BusyFlag = IDLE;
     cae:	10 92 84 00 	sts	0x0084, r1
     cb2:	08 c0       	rjmp	.+16     	; 0xcc4 <ADC_u8StartSingleConvPoll+0x10e>
					}
				}
				else
					Local_u8ErrorState = NOTOK;
     cb4:	81 e0       	ldi	r24, 0x01	; 1
     cb6:	8d 83       	std	Y+5, r24	; 0x05
     cb8:	05 c0       	rjmp	.+10     	; 0xcc4 <ADC_u8StartSingleConvPoll+0x10e>
			}
			else
				Local_u8ErrorState = NULL_POINTER;
     cba:	82 e0       	ldi	r24, 0x02	; 2
     cbc:	8d 83       	std	Y+5, r24	; 0x05
     cbe:	02 c0       	rjmp	.+4      	; 0xcc4 <ADC_u8StartSingleConvPoll+0x10e>
	}
	else
		Local_u8ErrorState = BUSY_FUNC;
     cc0:	83 e0       	ldi	r24, 0x03	; 3
     cc2:	8d 83       	std	Y+5, r24	; 0x05
	return Local_u8ErrorState;
     cc4:	8d 81       	ldd	r24, Y+5	; 0x05
}
     cc6:	28 96       	adiw	r28, 0x08	; 8
     cc8:	0f b6       	in	r0, 0x3f	; 63
     cca:	f8 94       	cli
     ccc:	de bf       	out	0x3e, r29	; 62
     cce:	0f be       	out	0x3f, r0	; 63
     cd0:	cd bf       	out	0x3d, r28	; 61
     cd2:	cf 91       	pop	r28
     cd4:	df 91       	pop	r29
     cd6:	08 95       	ret

00000cd8 <ADC_u8StartSingleConvInt>:

u8 ADC_u8StartSingleConvInt(u8 Copy_u8Channel,u16 *Copy_pu16Read,void (*Notifiction)())
{
     cd8:	df 93       	push	r29
     cda:	cf 93       	push	r28
     cdc:	00 d0       	rcall	.+0      	; 0xcde <ADC_u8StartSingleConvInt+0x6>
     cde:	00 d0       	rcall	.+0      	; 0xce0 <ADC_u8StartSingleConvInt+0x8>
     ce0:	00 d0       	rcall	.+0      	; 0xce2 <ADC_u8StartSingleConvInt+0xa>
     ce2:	cd b7       	in	r28, 0x3d	; 61
     ce4:	de b7       	in	r29, 0x3e	; 62
     ce6:	8a 83       	std	Y+2, r24	; 0x02
     ce8:	7c 83       	std	Y+4, r23	; 0x04
     cea:	6b 83       	std	Y+3, r22	; 0x03
     cec:	5e 83       	std	Y+6, r21	; 0x06
     cee:	4d 83       	std	Y+5, r20	; 0x05
	u8 Local_u8ErrorState = OK;
     cf0:	19 82       	std	Y+1, r1	; 0x01
	if(Global_u8BusyFlag==IDLE)
     cf2:	80 91 84 00 	lds	r24, 0x0084
     cf6:	88 23       	and	r24, r24
     cf8:	09 f0       	breq	.+2      	; 0xcfc <ADC_u8StartSingleConvInt+0x24>
     cfa:	40 c0       	rjmp	.+128    	; 0xd7c <ADC_u8StartSingleConvInt+0xa4>
	{
		Global_u8BusyFlag = BUSY;
     cfc:	81 e0       	ldi	r24, 0x01	; 1
     cfe:	80 93 84 00 	sts	0x0084, r24
		ADC_u8DirectionOfConvFunc = SINGLE_CONVERISION;
     d02:	10 92 89 00 	sts	0x0089, r1
		if((Copy_pu16Read != NULL)||(Notifiction != NULL))
     d06:	8b 81       	ldd	r24, Y+3	; 0x03
     d08:	9c 81       	ldd	r25, Y+4	; 0x04
     d0a:	00 97       	sbiw	r24, 0x00	; 0
     d0c:	21 f4       	brne	.+8      	; 0xd16 <ADC_u8StartSingleConvInt+0x3e>
     d0e:	8d 81       	ldd	r24, Y+5	; 0x05
     d10:	9e 81       	ldd	r25, Y+6	; 0x06
     d12:	00 97       	sbiw	r24, 0x00	; 0
     d14:	81 f1       	breq	.+96     	; 0xd76 <ADC_u8StartSingleConvInt+0x9e>
		{

				if(Copy_u8Channel<=MAX_OPTION_CHANNEL)
     d16:	8a 81       	ldd	r24, Y+2	; 0x02
     d18:	80 32       	cpi	r24, 0x20	; 32
     d1a:	50 f5       	brcc	.+84     	; 0xd70 <ADC_u8StartSingleConvInt+0x98>
				{
					ADMUX &= MASK_CHANNEL;
     d1c:	a7 e2       	ldi	r26, 0x27	; 39
     d1e:	b0 e0       	ldi	r27, 0x00	; 0
     d20:	e7 e2       	ldi	r30, 0x27	; 39
     d22:	f0 e0       	ldi	r31, 0x00	; 0
     d24:	80 81       	ld	r24, Z
     d26:	80 7e       	andi	r24, 0xE0	; 224
     d28:	8c 93       	st	X, r24
					ADMUX |= Copy_u8Channel<<ADMUX_MUX0;
     d2a:	a7 e2       	ldi	r26, 0x27	; 39
     d2c:	b0 e0       	ldi	r27, 0x00	; 0
     d2e:	e7 e2       	ldi	r30, 0x27	; 39
     d30:	f0 e0       	ldi	r31, 0x00	; 0
     d32:	90 81       	ld	r25, Z
     d34:	8a 81       	ldd	r24, Y+2	; 0x02
     d36:	89 2b       	or	r24, r25
     d38:	8c 93       	st	X, r24
					Global_vCallBackFunc = Notifiction;
     d3a:	8d 81       	ldd	r24, Y+5	; 0x05
     d3c:	9e 81       	ldd	r25, Y+6	; 0x06
     d3e:	90 93 86 00 	sts	0x0086, r25
     d42:	80 93 85 00 	sts	0x0085, r24
					Global_pu8Read = Copy_pu16Read;
     d46:	8b 81       	ldd	r24, Y+3	; 0x03
     d48:	9c 81       	ldd	r25, Y+4	; 0x04
     d4a:	90 93 88 00 	sts	0x0088, r25
     d4e:	80 93 87 00 	sts	0x0087, r24
					SET_BIT(ADCSRA,ADCSRA_ADSC);
     d52:	a6 e2       	ldi	r26, 0x26	; 38
     d54:	b0 e0       	ldi	r27, 0x00	; 0
     d56:	e6 e2       	ldi	r30, 0x26	; 38
     d58:	f0 e0       	ldi	r31, 0x00	; 0
     d5a:	80 81       	ld	r24, Z
     d5c:	80 64       	ori	r24, 0x40	; 64
     d5e:	8c 93       	st	X, r24
					SET_BIT(ADCSRA,ADCSRA_ADIE);
     d60:	a6 e2       	ldi	r26, 0x26	; 38
     d62:	b0 e0       	ldi	r27, 0x00	; 0
     d64:	e6 e2       	ldi	r30, 0x26	; 38
     d66:	f0 e0       	ldi	r31, 0x00	; 0
     d68:	80 81       	ld	r24, Z
     d6a:	88 60       	ori	r24, 0x08	; 8
     d6c:	8c 93       	st	X, r24
     d6e:	08 c0       	rjmp	.+16     	; 0xd80 <ADC_u8StartSingleConvInt+0xa8>
				}
				else
					Local_u8ErrorState = NOTOK;
     d70:	81 e0       	ldi	r24, 0x01	; 1
     d72:	89 83       	std	Y+1, r24	; 0x01
     d74:	05 c0       	rjmp	.+10     	; 0xd80 <ADC_u8StartSingleConvInt+0xa8>
		}
		else
			Local_u8ErrorState = NULL_POINTER;
     d76:	82 e0       	ldi	r24, 0x02	; 2
     d78:	89 83       	std	Y+1, r24	; 0x01
     d7a:	02 c0       	rjmp	.+4      	; 0xd80 <ADC_u8StartSingleConvInt+0xa8>
	}
	else
		Local_u8ErrorState = BUSY_FUNC;
     d7c:	83 e0       	ldi	r24, 0x03	; 3
     d7e:	89 83       	std	Y+1, r24	; 0x01
	return Local_u8ErrorState;
     d80:	89 81       	ldd	r24, Y+1	; 0x01
}
     d82:	26 96       	adiw	r28, 0x06	; 6
     d84:	0f b6       	in	r0, 0x3f	; 63
     d86:	f8 94       	cli
     d88:	de bf       	out	0x3e, r29	; 62
     d8a:	0f be       	out	0x3f, r0	; 63
     d8c:	cd bf       	out	0x3d, r28	; 61
     d8e:	cf 91       	pop	r28
     d90:	df 91       	pop	r29
     d92:	08 95       	ret

00000d94 <ADC_u8StartChainConvAsynch>:
u8 ADC_u8StartChainConvAsynch(ADC_Chain *Copy_Chain)
{
     d94:	df 93       	push	r29
     d96:	cf 93       	push	r28
     d98:	00 d0       	rcall	.+0      	; 0xd9a <ADC_u8StartChainConvAsynch+0x6>
     d9a:	0f 92       	push	r0
     d9c:	cd b7       	in	r28, 0x3d	; 61
     d9e:	de b7       	in	r29, 0x3e	; 62
     da0:	9b 83       	std	Y+3, r25	; 0x03
     da2:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState = OK;
     da4:	19 82       	std	Y+1, r1	; 0x01
	if(Global_u8BusyFlag==IDLE)
     da6:	80 91 84 00 	lds	r24, 0x0084
     daa:	88 23       	and	r24, r24
     dac:	09 f0       	breq	.+2      	; 0xdb0 <ADC_u8StartChainConvAsynch+0x1c>
     dae:	74 c0       	rjmp	.+232    	; 0xe98 <ADC_u8StartChainConvAsynch+0x104>
	{
		Global_u8BusyFlag = BUSY;
     db0:	81 e0       	ldi	r24, 0x01	; 1
     db2:	80 93 84 00 	sts	0x0084, r24
		ADC_u8DirectionOfConvFunc = CHAIN_CONVERISION;
     db6:	81 e0       	ldi	r24, 0x01	; 1
     db8:	80 93 89 00 	sts	0x0089, r24
		if((Copy_Chain->ChainId != NULL)||(Copy_Chain->Notifction != NULL)||(Copy_Chain->Result != NULL))
     dbc:	ea 81       	ldd	r30, Y+2	; 0x02
     dbe:	fb 81       	ldd	r31, Y+3	; 0x03
     dc0:	80 81       	ld	r24, Z
     dc2:	91 81       	ldd	r25, Z+1	; 0x01
     dc4:	00 97       	sbiw	r24, 0x00	; 0
     dc6:	69 f4       	brne	.+26     	; 0xde2 <ADC_u8StartChainConvAsynch+0x4e>
     dc8:	ea 81       	ldd	r30, Y+2	; 0x02
     dca:	fb 81       	ldd	r31, Y+3	; 0x03
     dcc:	83 81       	ldd	r24, Z+3	; 0x03
     dce:	94 81       	ldd	r25, Z+4	; 0x04
     dd0:	00 97       	sbiw	r24, 0x00	; 0
     dd2:	39 f4       	brne	.+14     	; 0xde2 <ADC_u8StartChainConvAsynch+0x4e>
     dd4:	ea 81       	ldd	r30, Y+2	; 0x02
     dd6:	fb 81       	ldd	r31, Y+3	; 0x03
     dd8:	85 81       	ldd	r24, Z+5	; 0x05
     dda:	96 81       	ldd	r25, Z+6	; 0x06
     ddc:	00 97       	sbiw	r24, 0x00	; 0
     dde:	09 f4       	brne	.+2      	; 0xde2 <ADC_u8StartChainConvAsynch+0x4e>
     de0:	58 c0       	rjmp	.+176    	; 0xe92 <ADC_u8StartChainConvAsynch+0xfe>
		{
			if(Copy_Chain->ChainId[ADC_u8ChainIndex]<=MAX_OPTION_CHANNEL)
     de2:	ea 81       	ldd	r30, Y+2	; 0x02
     de4:	fb 81       	ldd	r31, Y+3	; 0x03
     de6:	20 81       	ld	r18, Z
     de8:	31 81       	ldd	r19, Z+1	; 0x01
     dea:	80 91 8a 00 	lds	r24, 0x008A
     dee:	88 2f       	mov	r24, r24
     df0:	90 e0       	ldi	r25, 0x00	; 0
     df2:	f9 01       	movw	r30, r18
     df4:	e8 0f       	add	r30, r24
     df6:	f9 1f       	adc	r31, r25
     df8:	80 81       	ld	r24, Z
     dfa:	80 32       	cpi	r24, 0x20	; 32
     dfc:	08 f0       	brcs	.+2      	; 0xe00 <ADC_u8StartChainConvAsynch+0x6c>
     dfe:	46 c0       	rjmp	.+140    	; 0xe8c <ADC_u8StartChainConvAsynch+0xf8>
			{
				ADMUX &= MASK_CHANNEL;
     e00:	a7 e2       	ldi	r26, 0x27	; 39
     e02:	b0 e0       	ldi	r27, 0x00	; 0
     e04:	e7 e2       	ldi	r30, 0x27	; 39
     e06:	f0 e0       	ldi	r31, 0x00	; 0
     e08:	80 81       	ld	r24, Z
     e0a:	80 7e       	andi	r24, 0xE0	; 224
     e0c:	8c 93       	st	X, r24
				ADMUX |= Copy_Chain->ChainId[ADC_u8ChainIndex]<<ADMUX_MUX0;
     e0e:	a7 e2       	ldi	r26, 0x27	; 39
     e10:	b0 e0       	ldi	r27, 0x00	; 0
     e12:	e7 e2       	ldi	r30, 0x27	; 39
     e14:	f0 e0       	ldi	r31, 0x00	; 0
     e16:	40 81       	ld	r20, Z
     e18:	ea 81       	ldd	r30, Y+2	; 0x02
     e1a:	fb 81       	ldd	r31, Y+3	; 0x03
     e1c:	20 81       	ld	r18, Z
     e1e:	31 81       	ldd	r19, Z+1	; 0x01
     e20:	80 91 8a 00 	lds	r24, 0x008A
     e24:	88 2f       	mov	r24, r24
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	f9 01       	movw	r30, r18
     e2a:	e8 0f       	add	r30, r24
     e2c:	f9 1f       	adc	r31, r25
     e2e:	80 81       	ld	r24, Z
     e30:	84 2b       	or	r24, r20
     e32:	8c 93       	st	X, r24
				ADC_pu8ChannelNum = Copy_Chain->ChainId;
     e34:	ea 81       	ldd	r30, Y+2	; 0x02
     e36:	fb 81       	ldd	r31, Y+3	; 0x03
     e38:	80 81       	ld	r24, Z
     e3a:	91 81       	ldd	r25, Z+1	; 0x01
     e3c:	90 93 8c 00 	sts	0x008C, r25
     e40:	80 93 8b 00 	sts	0x008B, r24
				Global_vChainCallBackFunc = Copy_Chain->Notifction;
     e44:	ea 81       	ldd	r30, Y+2	; 0x02
     e46:	fb 81       	ldd	r31, Y+3	; 0x03
     e48:	83 81       	ldd	r24, Z+3	; 0x03
     e4a:	94 81       	ldd	r25, Z+4	; 0x04
     e4c:	90 93 8e 00 	sts	0x008E, r25
     e50:	80 93 8d 00 	sts	0x008D, r24
				ADC_pu16ChannelReading = Copy_Chain->Result;
     e54:	ea 81       	ldd	r30, Y+2	; 0x02
     e56:	fb 81       	ldd	r31, Y+3	; 0x03
     e58:	85 81       	ldd	r24, Z+5	; 0x05
     e5a:	96 81       	ldd	r25, Z+6	; 0x06
     e5c:	90 93 90 00 	sts	0x0090, r25
     e60:	80 93 8f 00 	sts	0x008F, r24
				ADC_u8ChannelSize = Copy_Chain->ChannelSize;
     e64:	ea 81       	ldd	r30, Y+2	; 0x02
     e66:	fb 81       	ldd	r31, Y+3	; 0x03
     e68:	82 81       	ldd	r24, Z+2	; 0x02
     e6a:	80 93 91 00 	sts	0x0091, r24
				SET_BIT(ADCSRA,ADCSRA_ADSC);
     e6e:	a6 e2       	ldi	r26, 0x26	; 38
     e70:	b0 e0       	ldi	r27, 0x00	; 0
     e72:	e6 e2       	ldi	r30, 0x26	; 38
     e74:	f0 e0       	ldi	r31, 0x00	; 0
     e76:	80 81       	ld	r24, Z
     e78:	80 64       	ori	r24, 0x40	; 64
     e7a:	8c 93       	st	X, r24
				SET_BIT(ADCSRA,ADCSRA_ADIE);
     e7c:	a6 e2       	ldi	r26, 0x26	; 38
     e7e:	b0 e0       	ldi	r27, 0x00	; 0
     e80:	e6 e2       	ldi	r30, 0x26	; 38
     e82:	f0 e0       	ldi	r31, 0x00	; 0
     e84:	80 81       	ld	r24, Z
     e86:	88 60       	ori	r24, 0x08	; 8
     e88:	8c 93       	st	X, r24
     e8a:	08 c0       	rjmp	.+16     	; 0xe9c <ADC_u8StartChainConvAsynch+0x108>
			}
			else
				Local_u8ErrorState = NOTOK;
     e8c:	81 e0       	ldi	r24, 0x01	; 1
     e8e:	89 83       	std	Y+1, r24	; 0x01
     e90:	05 c0       	rjmp	.+10     	; 0xe9c <ADC_u8StartChainConvAsynch+0x108>
		}
		else
			Local_u8ErrorState = NULL_POINTER;
     e92:	82 e0       	ldi	r24, 0x02	; 2
     e94:	89 83       	std	Y+1, r24	; 0x01
     e96:	02 c0       	rjmp	.+4      	; 0xe9c <ADC_u8StartChainConvAsynch+0x108>
	}
	else
		Local_u8ErrorState = BUSY_FUNC;
     e98:	83 e0       	ldi	r24, 0x03	; 3
     e9a:	89 83       	std	Y+1, r24	; 0x01
	return Local_u8ErrorState;
     e9c:	89 81       	ldd	r24, Y+1	; 0x01

}
     e9e:	0f 90       	pop	r0
     ea0:	0f 90       	pop	r0
     ea2:	0f 90       	pop	r0
     ea4:	cf 91       	pop	r28
     ea6:	df 91       	pop	r29
     ea8:	08 95       	ret

00000eaa <__vector_16>:
void __vector_16 (void)	__attribute__((signal));
void __vector_16 (void)
{
     eaa:	1f 92       	push	r1
     eac:	0f 92       	push	r0
     eae:	0f b6       	in	r0, 0x3f	; 63
     eb0:	0f 92       	push	r0
     eb2:	11 24       	eor	r1, r1
     eb4:	2f 93       	push	r18
     eb6:	3f 93       	push	r19
     eb8:	4f 93       	push	r20
     eba:	5f 93       	push	r21
     ebc:	6f 93       	push	r22
     ebe:	7f 93       	push	r23
     ec0:	8f 93       	push	r24
     ec2:	9f 93       	push	r25
     ec4:	af 93       	push	r26
     ec6:	bf 93       	push	r27
     ec8:	ef 93       	push	r30
     eca:	ff 93       	push	r31
     ecc:	df 93       	push	r29
     ece:	cf 93       	push	r28
     ed0:	cd b7       	in	r28, 0x3d	; 61
     ed2:	de b7       	in	r29, 0x3e	; 62
	if(ADC_u8DirectionOfConvFunc == SINGLE_CONVERISION)
     ed4:	80 91 89 00 	lds	r24, 0x0089
     ed8:	88 23       	and	r24, r24
     eda:	d9 f4       	brne	.+54     	; 0xf12 <__vector_16+0x68>
	{
		if(ADC_ADJUST_BIT == LEFT_ADJUST)
			*Global_pu8Read = ADC_REG>>8;
     edc:	a0 91 87 00 	lds	r26, 0x0087
     ee0:	b0 91 88 00 	lds	r27, 0x0088
     ee4:	e4 e2       	ldi	r30, 0x24	; 36
     ee6:	f0 e0       	ldi	r31, 0x00	; 0
     ee8:	80 81       	ld	r24, Z
     eea:	91 81       	ldd	r25, Z+1	; 0x01
     eec:	89 2f       	mov	r24, r25
     eee:	99 27       	eor	r25, r25
     ef0:	8d 93       	st	X+, r24
     ef2:	9c 93       	st	X, r25
		else if(ADC_ADJUST_BIT == RIGHT_ADJUST)
			*Global_pu8Read = ADC_REG;

		Global_u8BusyFlag = IDLE;
     ef4:	10 92 84 00 	sts	0x0084, r1

		Global_vCallBackFunc();
     ef8:	e0 91 85 00 	lds	r30, 0x0085
     efc:	f0 91 86 00 	lds	r31, 0x0086
     f00:	09 95       	icall

		CLR_BIT(ADCSRA,ADCSRA_ADIE);
     f02:	a6 e2       	ldi	r26, 0x26	; 38
     f04:	b0 e0       	ldi	r27, 0x00	; 0
     f06:	e6 e2       	ldi	r30, 0x26	; 38
     f08:	f0 e0       	ldi	r31, 0x00	; 0
     f0a:	80 81       	ld	r24, Z
     f0c:	87 7f       	andi	r24, 0xF7	; 247
     f0e:	8c 93       	st	X, r24
     f10:	58 c0       	rjmp	.+176    	; 0xfc2 <__vector_16+0x118>
	}
	else if(ADC_u8DirectionOfConvFunc == CHAIN_CONVERISION)
     f12:	80 91 89 00 	lds	r24, 0x0089
     f16:	81 30       	cpi	r24, 0x01	; 1
     f18:	09 f0       	breq	.+2      	; 0xf1c <__vector_16+0x72>
     f1a:	53 c0       	rjmp	.+166    	; 0xfc2 <__vector_16+0x118>
	{
		if(ADC_ADJUST_BIT == LEFT_ADJUST)
			ADC_pu16ChannelReading[ADC_u8ChainIndex] = ADC_REG>>8;
     f1c:	20 91 8f 00 	lds	r18, 0x008F
     f20:	30 91 90 00 	lds	r19, 0x0090
     f24:	80 91 8a 00 	lds	r24, 0x008A
     f28:	88 2f       	mov	r24, r24
     f2a:	90 e0       	ldi	r25, 0x00	; 0
     f2c:	88 0f       	add	r24, r24
     f2e:	99 1f       	adc	r25, r25
     f30:	d9 01       	movw	r26, r18
     f32:	a8 0f       	add	r26, r24
     f34:	b9 1f       	adc	r27, r25
     f36:	e4 e2       	ldi	r30, 0x24	; 36
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	80 81       	ld	r24, Z
     f3c:	91 81       	ldd	r25, Z+1	; 0x01
     f3e:	89 2f       	mov	r24, r25
     f40:	99 27       	eor	r25, r25
     f42:	11 96       	adiw	r26, 0x01	; 1
     f44:	9c 93       	st	X, r25
     f46:	8e 93       	st	-X, r24
		else if(ADC_ADJUST_BIT == RIGHT_ADJUST)
			ADC_pu16ChannelReading[ADC_u8ChainIndex] = ADC_REG;

		ADC_u8ChainIndex++;
     f48:	80 91 8a 00 	lds	r24, 0x008A
     f4c:	8f 5f       	subi	r24, 0xFF	; 255
     f4e:	80 93 8a 00 	sts	0x008A, r24
		if(ADC_u8ChainIndex==ADC_u8ChannelSize)
     f52:	90 91 8a 00 	lds	r25, 0x008A
     f56:	80 91 91 00 	lds	r24, 0x0091
     f5a:	98 17       	cp	r25, r24
     f5c:	89 f4       	brne	.+34     	; 0xf80 <__vector_16+0xd6>
		{
			Global_u8BusyFlag = IDLE;
     f5e:	10 92 84 00 	sts	0x0084, r1

			Global_vChainCallBackFunc();
     f62:	e0 91 8d 00 	lds	r30, 0x008D
     f66:	f0 91 8e 00 	lds	r31, 0x008E
     f6a:	09 95       	icall

			CLR_BIT(ADCSRA,ADCSRA_ADIE);
     f6c:	a6 e2       	ldi	r26, 0x26	; 38
     f6e:	b0 e0       	ldi	r27, 0x00	; 0
     f70:	e6 e2       	ldi	r30, 0x26	; 38
     f72:	f0 e0       	ldi	r31, 0x00	; 0
     f74:	80 81       	ld	r24, Z
     f76:	87 7f       	andi	r24, 0xF7	; 247
     f78:	8c 93       	st	X, r24

			ADC_u8ChainIndex = 0;
     f7a:	10 92 8a 00 	sts	0x008A, r1
     f7e:	21 c0       	rjmp	.+66     	; 0xfc2 <__vector_16+0x118>
		}
		else
		{
			ADMUX &= MASK_CHANNEL;
     f80:	a7 e2       	ldi	r26, 0x27	; 39
     f82:	b0 e0       	ldi	r27, 0x00	; 0
     f84:	e7 e2       	ldi	r30, 0x27	; 39
     f86:	f0 e0       	ldi	r31, 0x00	; 0
     f88:	80 81       	ld	r24, Z
     f8a:	80 7e       	andi	r24, 0xE0	; 224
     f8c:	8c 93       	st	X, r24
			ADMUX |= ADC_pu8ChannelNum[ADC_u8ChainIndex]<<ADMUX_MUX0;
     f8e:	a7 e2       	ldi	r26, 0x27	; 39
     f90:	b0 e0       	ldi	r27, 0x00	; 0
     f92:	e7 e2       	ldi	r30, 0x27	; 39
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	40 81       	ld	r20, Z
     f98:	20 91 8b 00 	lds	r18, 0x008B
     f9c:	30 91 8c 00 	lds	r19, 0x008C
     fa0:	80 91 8a 00 	lds	r24, 0x008A
     fa4:	88 2f       	mov	r24, r24
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	f9 01       	movw	r30, r18
     faa:	e8 0f       	add	r30, r24
     fac:	f9 1f       	adc	r31, r25
     fae:	80 81       	ld	r24, Z
     fb0:	84 2b       	or	r24, r20
     fb2:	8c 93       	st	X, r24
			SET_BIT(ADCSRA,ADCSRA_ADSC);
     fb4:	a6 e2       	ldi	r26, 0x26	; 38
     fb6:	b0 e0       	ldi	r27, 0x00	; 0
     fb8:	e6 e2       	ldi	r30, 0x26	; 38
     fba:	f0 e0       	ldi	r31, 0x00	; 0
     fbc:	80 81       	ld	r24, Z
     fbe:	80 64       	ori	r24, 0x40	; 64
     fc0:	8c 93       	st	X, r24
		}

	}
}
     fc2:	cf 91       	pop	r28
     fc4:	df 91       	pop	r29
     fc6:	ff 91       	pop	r31
     fc8:	ef 91       	pop	r30
     fca:	bf 91       	pop	r27
     fcc:	af 91       	pop	r26
     fce:	9f 91       	pop	r25
     fd0:	8f 91       	pop	r24
     fd2:	7f 91       	pop	r23
     fd4:	6f 91       	pop	r22
     fd6:	5f 91       	pop	r21
     fd8:	4f 91       	pop	r20
     fda:	3f 91       	pop	r19
     fdc:	2f 91       	pop	r18
     fde:	0f 90       	pop	r0
     fe0:	0f be       	out	0x3f, r0	; 63
     fe2:	0f 90       	pop	r0
     fe4:	1f 90       	pop	r1
     fe6:	18 95       	reti

00000fe8 <CLCD_voidSendCommand>:
#include "../HAL/CLCD_interface.h"
#include "../HAL/CLCD_private.h"

static u8 iniIsFinich=0;
void CLCD_voidSendCommand(u8 Copy_u8Command)//math
{
     fe8:	df 93       	push	r29
     fea:	cf 93       	push	r28
     fec:	cd b7       	in	r28, 0x3d	; 61
     fee:	de b7       	in	r29, 0x3e	; 62
     ff0:	ac 97       	sbiw	r28, 0x2c	; 44
     ff2:	0f b6       	in	r0, 0x3f	; 63
     ff4:	f8 94       	cli
     ff6:	de bf       	out	0x3e, r29	; 62
     ff8:	0f be       	out	0x3f, r0	; 63
     ffa:	cd bf       	out	0x3d, r28	; 61
     ffc:	8c a7       	std	Y+44, r24	; 0x2c
	/*PIN SET  send pulse (E) */
	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_E_PIN, DIO_PIN_HIGH);
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_E_PIN, DIO_PIN_LOW);
#elif CLCD_CHIOCE_MODE==_4_BIT_MODE
	u8 Local_u8Mask = 0b11110000;
     ffe:	80 ef       	ldi	r24, 0xF0	; 240
    1000:	8b a7       	std	Y+43, r24	; 0x2b
	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_RS_PIN, DIO_PIN_LOW);
    1002:	80 e0       	ldi	r24, 0x00	; 0
    1004:	60 e0       	ldi	r22, 0x00	; 0
    1006:	40 e0       	ldi	r20, 0x00	; 0
    1008:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
	/*PIN RW SET LOW  */
//	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_RW_PIN, DIO_PIN_LOW);
	/*PORT SET COMMAND*/
	Local_u8Mask &= Copy_u8Command;
    100c:	9b a5       	ldd	r25, Y+43	; 0x2b
    100e:	8c a5       	ldd	r24, Y+44	; 0x2c
    1010:	89 23       	and	r24, r25
    1012:	8b a7       	std	Y+43, r24	; 0x2b
	DIO_u8SetPortValue(CLCD_DATA_PORT, Local_u8Mask);
    1014:	81 e0       	ldi	r24, 0x01	; 1
    1016:	6b a5       	ldd	r22, Y+43	; 0x2b
    1018:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <DIO_u8SetPortValue>
	/*PIN SET  send pulse (E) */
	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_E_PIN, DIO_PIN_HIGH);
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	62 e0       	ldi	r22, 0x02	; 2
    1020:	41 e0       	ldi	r20, 0x01	; 1
    1022:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
    1026:	80 e0       	ldi	r24, 0x00	; 0
    1028:	90 e0       	ldi	r25, 0x00	; 0
    102a:	a0 e0       	ldi	r26, 0x00	; 0
    102c:	b0 e4       	ldi	r27, 0x40	; 64
    102e:	8f a3       	std	Y+39, r24	; 0x27
    1030:	98 a7       	std	Y+40, r25	; 0x28
    1032:	a9 a7       	std	Y+41, r26	; 0x29
    1034:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1036:	6f a1       	ldd	r22, Y+39	; 0x27
    1038:	78 a5       	ldd	r23, Y+40	; 0x28
    103a:	89 a5       	ldd	r24, Y+41	; 0x29
    103c:	9a a5       	ldd	r25, Y+42	; 0x2a
    103e:	20 e0       	ldi	r18, 0x00	; 0
    1040:	30 e0       	ldi	r19, 0x00	; 0
    1042:	4a ef       	ldi	r20, 0xFA	; 250
    1044:	54 e4       	ldi	r21, 0x44	; 68
    1046:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    104a:	dc 01       	movw	r26, r24
    104c:	cb 01       	movw	r24, r22
    104e:	8b a3       	std	Y+35, r24	; 0x23
    1050:	9c a3       	std	Y+36, r25	; 0x24
    1052:	ad a3       	std	Y+37, r26	; 0x25
    1054:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1056:	6b a1       	ldd	r22, Y+35	; 0x23
    1058:	7c a1       	ldd	r23, Y+36	; 0x24
    105a:	8d a1       	ldd	r24, Y+37	; 0x25
    105c:	9e a1       	ldd	r25, Y+38	; 0x26
    105e:	20 e0       	ldi	r18, 0x00	; 0
    1060:	30 e0       	ldi	r19, 0x00	; 0
    1062:	40 e8       	ldi	r20, 0x80	; 128
    1064:	5f e3       	ldi	r21, 0x3F	; 63
    1066:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    106a:	88 23       	and	r24, r24
    106c:	2c f4       	brge	.+10     	; 0x1078 <CLCD_voidSendCommand+0x90>
		__ticks = 1;
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	9a a3       	std	Y+34, r25	; 0x22
    1074:	89 a3       	std	Y+33, r24	; 0x21
    1076:	3f c0       	rjmp	.+126    	; 0x10f6 <CLCD_voidSendCommand+0x10e>
	else if (__tmp > 65535)
    1078:	6b a1       	ldd	r22, Y+35	; 0x23
    107a:	7c a1       	ldd	r23, Y+36	; 0x24
    107c:	8d a1       	ldd	r24, Y+37	; 0x25
    107e:	9e a1       	ldd	r25, Y+38	; 0x26
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	3f ef       	ldi	r19, 0xFF	; 255
    1084:	4f e7       	ldi	r20, 0x7F	; 127
    1086:	57 e4       	ldi	r21, 0x47	; 71
    1088:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    108c:	18 16       	cp	r1, r24
    108e:	4c f5       	brge	.+82     	; 0x10e2 <CLCD_voidSendCommand+0xfa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1090:	6f a1       	ldd	r22, Y+39	; 0x27
    1092:	78 a5       	ldd	r23, Y+40	; 0x28
    1094:	89 a5       	ldd	r24, Y+41	; 0x29
    1096:	9a a5       	ldd	r25, Y+42	; 0x2a
    1098:	20 e0       	ldi	r18, 0x00	; 0
    109a:	30 e0       	ldi	r19, 0x00	; 0
    109c:	40 e2       	ldi	r20, 0x20	; 32
    109e:	51 e4       	ldi	r21, 0x41	; 65
    10a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    10a4:	dc 01       	movw	r26, r24
    10a6:	cb 01       	movw	r24, r22
    10a8:	bc 01       	movw	r22, r24
    10aa:	cd 01       	movw	r24, r26
    10ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    10b0:	dc 01       	movw	r26, r24
    10b2:	cb 01       	movw	r24, r22
    10b4:	9a a3       	std	Y+34, r25	; 0x22
    10b6:	89 a3       	std	Y+33, r24	; 0x21
    10b8:	0f c0       	rjmp	.+30     	; 0x10d8 <CLCD_voidSendCommand+0xf0>
    10ba:	88 ec       	ldi	r24, 0xC8	; 200
    10bc:	90 e0       	ldi	r25, 0x00	; 0
    10be:	98 a3       	std	Y+32, r25	; 0x20
    10c0:	8f 8f       	std	Y+31, r24	; 0x1f
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    10c2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    10c4:	98 a1       	ldd	r25, Y+32	; 0x20
    10c6:	01 97       	sbiw	r24, 0x01	; 1
    10c8:	f1 f7       	brne	.-4      	; 0x10c6 <CLCD_voidSendCommand+0xde>
    10ca:	98 a3       	std	Y+32, r25	; 0x20
    10cc:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    10ce:	89 a1       	ldd	r24, Y+33	; 0x21
    10d0:	9a a1       	ldd	r25, Y+34	; 0x22
    10d2:	01 97       	sbiw	r24, 0x01	; 1
    10d4:	9a a3       	std	Y+34, r25	; 0x22
    10d6:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    10d8:	89 a1       	ldd	r24, Y+33	; 0x21
    10da:	9a a1       	ldd	r25, Y+34	; 0x22
    10dc:	00 97       	sbiw	r24, 0x00	; 0
    10de:	69 f7       	brne	.-38     	; 0x10ba <CLCD_voidSendCommand+0xd2>
    10e0:	14 c0       	rjmp	.+40     	; 0x110a <CLCD_voidSendCommand+0x122>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    10e2:	6b a1       	ldd	r22, Y+35	; 0x23
    10e4:	7c a1       	ldd	r23, Y+36	; 0x24
    10e6:	8d a1       	ldd	r24, Y+37	; 0x25
    10e8:	9e a1       	ldd	r25, Y+38	; 0x26
    10ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    10ee:	dc 01       	movw	r26, r24
    10f0:	cb 01       	movw	r24, r22
    10f2:	9a a3       	std	Y+34, r25	; 0x22
    10f4:	89 a3       	std	Y+33, r24	; 0x21
    10f6:	89 a1       	ldd	r24, Y+33	; 0x21
    10f8:	9a a1       	ldd	r25, Y+34	; 0x22
    10fa:	9e 8f       	std	Y+30, r25	; 0x1e
    10fc:	8d 8f       	std	Y+29, r24	; 0x1d
    10fe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1100:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1102:	01 97       	sbiw	r24, 0x01	; 1
    1104:	f1 f7       	brne	.-4      	; 0x1102 <CLCD_voidSendCommand+0x11a>
    1106:	9e 8f       	std	Y+30, r25	; 0x1e
    1108:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_PIN_LOW);
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	62 e0       	ldi	r22, 0x02	; 2
    110e:	40 e0       	ldi	r20, 0x00	; 0
    1110:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
	if(iniIsFinich)
    1114:	80 91 92 00 	lds	r24, 0x0092
    1118:	88 23       	and	r24, r24
    111a:	09 f4       	brne	.+2      	; 0x111e <CLCD_voidSendCommand+0x136>
    111c:	8c c0       	rjmp	.+280    	; 0x1236 <CLCD_voidSendCommand+0x24e>
	{
		Local_u8Mask = 0b11110000;
    111e:	80 ef       	ldi	r24, 0xF0	; 240
    1120:	8b a7       	std	Y+43, r24	; 0x2b
		Local_u8Mask = ~(Local_u8Mask) & Copy_u8Command;
    1122:	8b a5       	ldd	r24, Y+43	; 0x2b
    1124:	98 2f       	mov	r25, r24
    1126:	90 95       	com	r25
    1128:	8c a5       	ldd	r24, Y+44	; 0x2c
    112a:	89 23       	and	r24, r25
    112c:	8b a7       	std	Y+43, r24	; 0x2b
		DIO_u8SetPortValue(CLCD_DATA_PORT, (Local_u8Mask << 4));
    112e:	8b a5       	ldd	r24, Y+43	; 0x2b
    1130:	98 2f       	mov	r25, r24
    1132:	92 95       	swap	r25
    1134:	90 7f       	andi	r25, 0xF0	; 240
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	69 2f       	mov	r22, r25
    113a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <DIO_u8SetPortValue>
		DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_PIN_HIGH);
    113e:	80 e0       	ldi	r24, 0x00	; 0
    1140:	62 e0       	ldi	r22, 0x02	; 2
    1142:	41 e0       	ldi	r20, 0x01	; 1
    1144:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
    1148:	80 e0       	ldi	r24, 0x00	; 0
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	a0 e0       	ldi	r26, 0x00	; 0
    114e:	b0 e4       	ldi	r27, 0x40	; 64
    1150:	89 8f       	std	Y+25, r24	; 0x19
    1152:	9a 8f       	std	Y+26, r25	; 0x1a
    1154:	ab 8f       	std	Y+27, r26	; 0x1b
    1156:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1158:	69 8d       	ldd	r22, Y+25	; 0x19
    115a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    115c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    115e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1160:	20 e0       	ldi	r18, 0x00	; 0
    1162:	30 e0       	ldi	r19, 0x00	; 0
    1164:	4a ef       	ldi	r20, 0xFA	; 250
    1166:	54 e4       	ldi	r21, 0x44	; 68
    1168:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    116c:	dc 01       	movw	r26, r24
    116e:	cb 01       	movw	r24, r22
    1170:	8d 8b       	std	Y+21, r24	; 0x15
    1172:	9e 8b       	std	Y+22, r25	; 0x16
    1174:	af 8b       	std	Y+23, r26	; 0x17
    1176:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1178:	6d 89       	ldd	r22, Y+21	; 0x15
    117a:	7e 89       	ldd	r23, Y+22	; 0x16
    117c:	8f 89       	ldd	r24, Y+23	; 0x17
    117e:	98 8d       	ldd	r25, Y+24	; 0x18
    1180:	20 e0       	ldi	r18, 0x00	; 0
    1182:	30 e0       	ldi	r19, 0x00	; 0
    1184:	40 e8       	ldi	r20, 0x80	; 128
    1186:	5f e3       	ldi	r21, 0x3F	; 63
    1188:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    118c:	88 23       	and	r24, r24
    118e:	2c f4       	brge	.+10     	; 0x119a <CLCD_voidSendCommand+0x1b2>
		__ticks = 1;
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	90 e0       	ldi	r25, 0x00	; 0
    1194:	9c 8b       	std	Y+20, r25	; 0x14
    1196:	8b 8b       	std	Y+19, r24	; 0x13
    1198:	3f c0       	rjmp	.+126    	; 0x1218 <CLCD_voidSendCommand+0x230>
	else if (__tmp > 65535)
    119a:	6d 89       	ldd	r22, Y+21	; 0x15
    119c:	7e 89       	ldd	r23, Y+22	; 0x16
    119e:	8f 89       	ldd	r24, Y+23	; 0x17
    11a0:	98 8d       	ldd	r25, Y+24	; 0x18
    11a2:	20 e0       	ldi	r18, 0x00	; 0
    11a4:	3f ef       	ldi	r19, 0xFF	; 255
    11a6:	4f e7       	ldi	r20, 0x7F	; 127
    11a8:	57 e4       	ldi	r21, 0x47	; 71
    11aa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    11ae:	18 16       	cp	r1, r24
    11b0:	4c f5       	brge	.+82     	; 0x1204 <CLCD_voidSendCommand+0x21c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    11b2:	69 8d       	ldd	r22, Y+25	; 0x19
    11b4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    11b6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    11b8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    11ba:	20 e0       	ldi	r18, 0x00	; 0
    11bc:	30 e0       	ldi	r19, 0x00	; 0
    11be:	40 e2       	ldi	r20, 0x20	; 32
    11c0:	51 e4       	ldi	r21, 0x41	; 65
    11c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    11c6:	dc 01       	movw	r26, r24
    11c8:	cb 01       	movw	r24, r22
    11ca:	bc 01       	movw	r22, r24
    11cc:	cd 01       	movw	r24, r26
    11ce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    11d2:	dc 01       	movw	r26, r24
    11d4:	cb 01       	movw	r24, r22
    11d6:	9c 8b       	std	Y+20, r25	; 0x14
    11d8:	8b 8b       	std	Y+19, r24	; 0x13
    11da:	0f c0       	rjmp	.+30     	; 0x11fa <CLCD_voidSendCommand+0x212>
    11dc:	88 ec       	ldi	r24, 0xC8	; 200
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	9a 8b       	std	Y+18, r25	; 0x12
    11e2:	89 8b       	std	Y+17, r24	; 0x11
    11e4:	89 89       	ldd	r24, Y+17	; 0x11
    11e6:	9a 89       	ldd	r25, Y+18	; 0x12
    11e8:	01 97       	sbiw	r24, 0x01	; 1
    11ea:	f1 f7       	brne	.-4      	; 0x11e8 <CLCD_voidSendCommand+0x200>
    11ec:	9a 8b       	std	Y+18, r25	; 0x12
    11ee:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    11f0:	8b 89       	ldd	r24, Y+19	; 0x13
    11f2:	9c 89       	ldd	r25, Y+20	; 0x14
    11f4:	01 97       	sbiw	r24, 0x01	; 1
    11f6:	9c 8b       	std	Y+20, r25	; 0x14
    11f8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    11fa:	8b 89       	ldd	r24, Y+19	; 0x13
    11fc:	9c 89       	ldd	r25, Y+20	; 0x14
    11fe:	00 97       	sbiw	r24, 0x00	; 0
    1200:	69 f7       	brne	.-38     	; 0x11dc <CLCD_voidSendCommand+0x1f4>
    1202:	14 c0       	rjmp	.+40     	; 0x122c <CLCD_voidSendCommand+0x244>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1204:	6d 89       	ldd	r22, Y+21	; 0x15
    1206:	7e 89       	ldd	r23, Y+22	; 0x16
    1208:	8f 89       	ldd	r24, Y+23	; 0x17
    120a:	98 8d       	ldd	r25, Y+24	; 0x18
    120c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1210:	dc 01       	movw	r26, r24
    1212:	cb 01       	movw	r24, r22
    1214:	9c 8b       	std	Y+20, r25	; 0x14
    1216:	8b 8b       	std	Y+19, r24	; 0x13
    1218:	8b 89       	ldd	r24, Y+19	; 0x13
    121a:	9c 89       	ldd	r25, Y+20	; 0x14
    121c:	98 8b       	std	Y+16, r25	; 0x10
    121e:	8f 87       	std	Y+15, r24	; 0x0f
    1220:	8f 85       	ldd	r24, Y+15	; 0x0f
    1222:	98 89       	ldd	r25, Y+16	; 0x10
    1224:	01 97       	sbiw	r24, 0x01	; 1
    1226:	f1 f7       	brne	.-4      	; 0x1224 <CLCD_voidSendCommand+0x23c>
    1228:	98 8b       	std	Y+16, r25	; 0x10
    122a:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_ms(2);
		DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_PIN_LOW);
    122c:	80 e0       	ldi	r24, 0x00	; 0
    122e:	62 e0       	ldi	r22, 0x02	; 2
    1230:	40 e0       	ldi	r20, 0x00	; 0
    1232:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
    1236:	80 e0       	ldi	r24, 0x00	; 0
    1238:	90 e0       	ldi	r25, 0x00	; 0
    123a:	a0 e0       	ldi	r26, 0x00	; 0
    123c:	b0 e4       	ldi	r27, 0x40	; 64
    123e:	8b 87       	std	Y+11, r24	; 0x0b
    1240:	9c 87       	std	Y+12, r25	; 0x0c
    1242:	ad 87       	std	Y+13, r26	; 0x0d
    1244:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1246:	6b 85       	ldd	r22, Y+11	; 0x0b
    1248:	7c 85       	ldd	r23, Y+12	; 0x0c
    124a:	8d 85       	ldd	r24, Y+13	; 0x0d
    124c:	9e 85       	ldd	r25, Y+14	; 0x0e
    124e:	20 e0       	ldi	r18, 0x00	; 0
    1250:	30 e0       	ldi	r19, 0x00	; 0
    1252:	4a ef       	ldi	r20, 0xFA	; 250
    1254:	54 e4       	ldi	r21, 0x44	; 68
    1256:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    125a:	dc 01       	movw	r26, r24
    125c:	cb 01       	movw	r24, r22
    125e:	8f 83       	std	Y+7, r24	; 0x07
    1260:	98 87       	std	Y+8, r25	; 0x08
    1262:	a9 87       	std	Y+9, r26	; 0x09
    1264:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1266:	6f 81       	ldd	r22, Y+7	; 0x07
    1268:	78 85       	ldd	r23, Y+8	; 0x08
    126a:	89 85       	ldd	r24, Y+9	; 0x09
    126c:	9a 85       	ldd	r25, Y+10	; 0x0a
    126e:	20 e0       	ldi	r18, 0x00	; 0
    1270:	30 e0       	ldi	r19, 0x00	; 0
    1272:	40 e8       	ldi	r20, 0x80	; 128
    1274:	5f e3       	ldi	r21, 0x3F	; 63
    1276:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    127a:	88 23       	and	r24, r24
    127c:	2c f4       	brge	.+10     	; 0x1288 <CLCD_voidSendCommand+0x2a0>
		__ticks = 1;
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	90 e0       	ldi	r25, 0x00	; 0
    1282:	9e 83       	std	Y+6, r25	; 0x06
    1284:	8d 83       	std	Y+5, r24	; 0x05
    1286:	3f c0       	rjmp	.+126    	; 0x1306 <CLCD_voidSendCommand+0x31e>
	else if (__tmp > 65535)
    1288:	6f 81       	ldd	r22, Y+7	; 0x07
    128a:	78 85       	ldd	r23, Y+8	; 0x08
    128c:	89 85       	ldd	r24, Y+9	; 0x09
    128e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1290:	20 e0       	ldi	r18, 0x00	; 0
    1292:	3f ef       	ldi	r19, 0xFF	; 255
    1294:	4f e7       	ldi	r20, 0x7F	; 127
    1296:	57 e4       	ldi	r21, 0x47	; 71
    1298:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    129c:	18 16       	cp	r1, r24
    129e:	4c f5       	brge	.+82     	; 0x12f2 <CLCD_voidSendCommand+0x30a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    12a0:	6b 85       	ldd	r22, Y+11	; 0x0b
    12a2:	7c 85       	ldd	r23, Y+12	; 0x0c
    12a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    12a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    12a8:	20 e0       	ldi	r18, 0x00	; 0
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	40 e2       	ldi	r20, 0x20	; 32
    12ae:	51 e4       	ldi	r21, 0x41	; 65
    12b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    12b4:	dc 01       	movw	r26, r24
    12b6:	cb 01       	movw	r24, r22
    12b8:	bc 01       	movw	r22, r24
    12ba:	cd 01       	movw	r24, r26
    12bc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    12c0:	dc 01       	movw	r26, r24
    12c2:	cb 01       	movw	r24, r22
    12c4:	9e 83       	std	Y+6, r25	; 0x06
    12c6:	8d 83       	std	Y+5, r24	; 0x05
    12c8:	0f c0       	rjmp	.+30     	; 0x12e8 <CLCD_voidSendCommand+0x300>
    12ca:	88 ec       	ldi	r24, 0xC8	; 200
    12cc:	90 e0       	ldi	r25, 0x00	; 0
    12ce:	9c 83       	std	Y+4, r25	; 0x04
    12d0:	8b 83       	std	Y+3, r24	; 0x03
    12d2:	8b 81       	ldd	r24, Y+3	; 0x03
    12d4:	9c 81       	ldd	r25, Y+4	; 0x04
    12d6:	01 97       	sbiw	r24, 0x01	; 1
    12d8:	f1 f7       	brne	.-4      	; 0x12d6 <CLCD_voidSendCommand+0x2ee>
    12da:	9c 83       	std	Y+4, r25	; 0x04
    12dc:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    12de:	8d 81       	ldd	r24, Y+5	; 0x05
    12e0:	9e 81       	ldd	r25, Y+6	; 0x06
    12e2:	01 97       	sbiw	r24, 0x01	; 1
    12e4:	9e 83       	std	Y+6, r25	; 0x06
    12e6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    12e8:	8d 81       	ldd	r24, Y+5	; 0x05
    12ea:	9e 81       	ldd	r25, Y+6	; 0x06
    12ec:	00 97       	sbiw	r24, 0x00	; 0
    12ee:	69 f7       	brne	.-38     	; 0x12ca <CLCD_voidSendCommand+0x2e2>
    12f0:	14 c0       	rjmp	.+40     	; 0x131a <CLCD_voidSendCommand+0x332>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    12f2:	6f 81       	ldd	r22, Y+7	; 0x07
    12f4:	78 85       	ldd	r23, Y+8	; 0x08
    12f6:	89 85       	ldd	r24, Y+9	; 0x09
    12f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    12fa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    12fe:	dc 01       	movw	r26, r24
    1300:	cb 01       	movw	r24, r22
    1302:	9e 83       	std	Y+6, r25	; 0x06
    1304:	8d 83       	std	Y+5, r24	; 0x05
    1306:	8d 81       	ldd	r24, Y+5	; 0x05
    1308:	9e 81       	ldd	r25, Y+6	; 0x06
    130a:	9a 83       	std	Y+2, r25	; 0x02
    130c:	89 83       	std	Y+1, r24	; 0x01
    130e:	89 81       	ldd	r24, Y+1	; 0x01
    1310:	9a 81       	ldd	r25, Y+2	; 0x02
    1312:	01 97       	sbiw	r24, 0x01	; 1
    1314:	f1 f7       	brne	.-4      	; 0x1312 <CLCD_voidSendCommand+0x32a>
    1316:	9a 83       	std	Y+2, r25	; 0x02
    1318:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
#else
#error "In correct cconfigrtion of LCD_MODE"
#endif

}
    131a:	ac 96       	adiw	r28, 0x2c	; 44
    131c:	0f b6       	in	r0, 0x3f	; 63
    131e:	f8 94       	cli
    1320:	de bf       	out	0x3e, r29	; 62
    1322:	0f be       	out	0x3f, r0	; 63
    1324:	cd bf       	out	0x3d, r28	; 61
    1326:	cf 91       	pop	r28
    1328:	df 91       	pop	r29
    132a:	08 95       	ret

0000132c <CLCD_Read_BF_AC>:
u8 CLCD_Read_BF_AC() {
    132c:	df 93       	push	r29
    132e:	cf 93       	push	r28
    1330:	00 d0       	rcall	.+0      	; 0x1332 <CLCD_Read_BF_AC+0x6>
    1332:	cd b7       	in	r28, 0x3d	; 61
    1334:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8Address = 0;
    1336:	1a 82       	std	Y+2, r1	; 0x02
	/*PIN RS SET LOW  */
	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_RS_PIN, DIO_PIN_LOW);
    1338:	80 e0       	ldi	r24, 0x00	; 0
    133a:	60 e0       	ldi	r22, 0x00	; 0
    133c:	40 e0       	ldi	r20, 0x00	; 0
    133e:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
	/*PIN RW SET HIGH  */
	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_RW_PIN, DIO_PIN_HIGH);
    1342:	80 e0       	ldi	r24, 0x00	; 0
    1344:	61 e0       	ldi	r22, 0x01	; 1
    1346:	41 e0       	ldi	r20, 0x01	; 1
    1348:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
	/*PIN SET  send pulse (E) */
	for (u8 i = 0; i < 7; i++) {
    134c:	19 82       	std	Y+1, r1	; 0x01
    134e:	1c c0       	rjmp	.+56     	; 0x1388 <CLCD_Read_BF_AC+0x5c>
		DIO_u8GetPinValue(CLCD_DATA_PORT, i, &Local_u8Address);
    1350:	9e 01       	movw	r18, r28
    1352:	2e 5f       	subi	r18, 0xFE	; 254
    1354:	3f 4f       	sbci	r19, 0xFF	; 255
    1356:	81 e0       	ldi	r24, 0x01	; 1
    1358:	69 81       	ldd	r22, Y+1	; 0x01
    135a:	a9 01       	movw	r20, r18
    135c:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <DIO_u8GetPinValue>
		Local_u8Address += Local_u8Address << i;
    1360:	8a 81       	ldd	r24, Y+2	; 0x02
    1362:	28 2f       	mov	r18, r24
    1364:	30 e0       	ldi	r19, 0x00	; 0
    1366:	89 81       	ldd	r24, Y+1	; 0x01
    1368:	88 2f       	mov	r24, r24
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	a9 01       	movw	r20, r18
    136e:	02 c0       	rjmp	.+4      	; 0x1374 <CLCD_Read_BF_AC+0x48>
    1370:	44 0f       	add	r20, r20
    1372:	55 1f       	adc	r21, r21
    1374:	8a 95       	dec	r24
    1376:	e2 f7       	brpl	.-8      	; 0x1370 <CLCD_Read_BF_AC+0x44>
    1378:	ca 01       	movw	r24, r20
    137a:	98 2f       	mov	r25, r24
    137c:	8a 81       	ldd	r24, Y+2	; 0x02
    137e:	89 0f       	add	r24, r25
    1380:	8a 83       	std	Y+2, r24	; 0x02
	/*PIN RS SET LOW  */
	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_RS_PIN, DIO_PIN_LOW);
	/*PIN RW SET HIGH  */
	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_RW_PIN, DIO_PIN_HIGH);
	/*PIN SET  send pulse (E) */
	for (u8 i = 0; i < 7; i++) {
    1382:	89 81       	ldd	r24, Y+1	; 0x01
    1384:	8f 5f       	subi	r24, 0xFF	; 255
    1386:	89 83       	std	Y+1, r24	; 0x01
    1388:	89 81       	ldd	r24, Y+1	; 0x01
    138a:	87 30       	cpi	r24, 0x07	; 7
    138c:	08 f3       	brcs	.-62     	; 0x1350 <CLCD_Read_BF_AC+0x24>
		DIO_u8GetPinValue(CLCD_DATA_PORT, i, &Local_u8Address);
		Local_u8Address += Local_u8Address << i;
	}
	return Local_u8Address;
    138e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1390:	0f 90       	pop	r0
    1392:	0f 90       	pop	r0
    1394:	cf 91       	pop	r28
    1396:	df 91       	pop	r29
    1398:	08 95       	ret

0000139a <CLCD_voidSendData>:

void CLCD_voidSendData(u8 Copy_u8Data)
{
    139a:	df 93       	push	r29
    139c:	cf 93       	push	r28
    139e:	cd b7       	in	r28, 0x3d	; 61
    13a0:	de b7       	in	r29, 0x3e	; 62
    13a2:	ac 97       	sbiw	r28, 0x2c	; 44
    13a4:	0f b6       	in	r0, 0x3f	; 63
    13a6:	f8 94       	cli
    13a8:	de bf       	out	0x3e, r29	; 62
    13aa:	0f be       	out	0x3f, r0	; 63
    13ac:	cd bf       	out	0x3d, r28	; 61
    13ae:	8c a7       	std	Y+44, r24	; 0x2c
	if (Local_u8Address > 0x0f)
		CLCD_voidSendCommand(0x0C);
	else
		CLCD_voidSendCommand(0x06);
#elif CLCD_CHIOCE_MODE==_4_BIT_MODE
	u8 Local_u8Mask = 0b11110000;
    13b0:	80 ef       	ldi	r24, 0xF0	; 240
    13b2:	8b a7       	std	Y+43, r24	; 0x2b
	/*PIN RS SET LOW  */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_RS_PIN,DIO_PIN_HIGH);
    13b4:	80 e0       	ldi	r24, 0x00	; 0
    13b6:	60 e0       	ldi	r22, 0x00	; 0
    13b8:	41 e0       	ldi	r20, 0x01	; 1
    13ba:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
	/*PIN RW SET LOW  */
	//DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_RW_PIN,DIO_PIN_LOW);
	/*PORT SET COMMAND*/
	Local_u8Mask &= Copy_u8Data;
    13be:	9b a5       	ldd	r25, Y+43	; 0x2b
    13c0:	8c a5       	ldd	r24, Y+44	; 0x2c
    13c2:	89 23       	and	r24, r25
    13c4:	8b a7       	std	Y+43, r24	; 0x2b
	DIO_u8SetPortValue(CLCD_DATA_PORT,Local_u8Mask);
    13c6:	81 e0       	ldi	r24, 0x01	; 1
    13c8:	6b a5       	ldd	r22, Y+43	; 0x2b
    13ca:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <DIO_u8SetPortValue>
	/*PIN SET send pulse (E) */
	DIO_u8SetPinValue(CLCD_CTRL_PORT, CLCD_E_PIN, DIO_PIN_HIGH);
    13ce:	80 e0       	ldi	r24, 0x00	; 0
    13d0:	62 e0       	ldi	r22, 0x02	; 2
    13d2:	41 e0       	ldi	r20, 0x01	; 1
    13d4:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
    13d8:	80 e0       	ldi	r24, 0x00	; 0
    13da:	90 e0       	ldi	r25, 0x00	; 0
    13dc:	a0 e0       	ldi	r26, 0x00	; 0
    13de:	b0 e4       	ldi	r27, 0x40	; 64
    13e0:	8f a3       	std	Y+39, r24	; 0x27
    13e2:	98 a7       	std	Y+40, r25	; 0x28
    13e4:	a9 a7       	std	Y+41, r26	; 0x29
    13e6:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    13e8:	6f a1       	ldd	r22, Y+39	; 0x27
    13ea:	78 a5       	ldd	r23, Y+40	; 0x28
    13ec:	89 a5       	ldd	r24, Y+41	; 0x29
    13ee:	9a a5       	ldd	r25, Y+42	; 0x2a
    13f0:	20 e0       	ldi	r18, 0x00	; 0
    13f2:	30 e0       	ldi	r19, 0x00	; 0
    13f4:	4a ef       	ldi	r20, 0xFA	; 250
    13f6:	54 e4       	ldi	r21, 0x44	; 68
    13f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    13fc:	dc 01       	movw	r26, r24
    13fe:	cb 01       	movw	r24, r22
    1400:	8b a3       	std	Y+35, r24	; 0x23
    1402:	9c a3       	std	Y+36, r25	; 0x24
    1404:	ad a3       	std	Y+37, r26	; 0x25
    1406:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1408:	6b a1       	ldd	r22, Y+35	; 0x23
    140a:	7c a1       	ldd	r23, Y+36	; 0x24
    140c:	8d a1       	ldd	r24, Y+37	; 0x25
    140e:	9e a1       	ldd	r25, Y+38	; 0x26
    1410:	20 e0       	ldi	r18, 0x00	; 0
    1412:	30 e0       	ldi	r19, 0x00	; 0
    1414:	40 e8       	ldi	r20, 0x80	; 128
    1416:	5f e3       	ldi	r21, 0x3F	; 63
    1418:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    141c:	88 23       	and	r24, r24
    141e:	2c f4       	brge	.+10     	; 0x142a <CLCD_voidSendData+0x90>
		__ticks = 1;
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	90 e0       	ldi	r25, 0x00	; 0
    1424:	9a a3       	std	Y+34, r25	; 0x22
    1426:	89 a3       	std	Y+33, r24	; 0x21
    1428:	3f c0       	rjmp	.+126    	; 0x14a8 <CLCD_voidSendData+0x10e>
	else if (__tmp > 65535)
    142a:	6b a1       	ldd	r22, Y+35	; 0x23
    142c:	7c a1       	ldd	r23, Y+36	; 0x24
    142e:	8d a1       	ldd	r24, Y+37	; 0x25
    1430:	9e a1       	ldd	r25, Y+38	; 0x26
    1432:	20 e0       	ldi	r18, 0x00	; 0
    1434:	3f ef       	ldi	r19, 0xFF	; 255
    1436:	4f e7       	ldi	r20, 0x7F	; 127
    1438:	57 e4       	ldi	r21, 0x47	; 71
    143a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    143e:	18 16       	cp	r1, r24
    1440:	4c f5       	brge	.+82     	; 0x1494 <CLCD_voidSendData+0xfa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1442:	6f a1       	ldd	r22, Y+39	; 0x27
    1444:	78 a5       	ldd	r23, Y+40	; 0x28
    1446:	89 a5       	ldd	r24, Y+41	; 0x29
    1448:	9a a5       	ldd	r25, Y+42	; 0x2a
    144a:	20 e0       	ldi	r18, 0x00	; 0
    144c:	30 e0       	ldi	r19, 0x00	; 0
    144e:	40 e2       	ldi	r20, 0x20	; 32
    1450:	51 e4       	ldi	r21, 0x41	; 65
    1452:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1456:	dc 01       	movw	r26, r24
    1458:	cb 01       	movw	r24, r22
    145a:	bc 01       	movw	r22, r24
    145c:	cd 01       	movw	r24, r26
    145e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1462:	dc 01       	movw	r26, r24
    1464:	cb 01       	movw	r24, r22
    1466:	9a a3       	std	Y+34, r25	; 0x22
    1468:	89 a3       	std	Y+33, r24	; 0x21
    146a:	0f c0       	rjmp	.+30     	; 0x148a <CLCD_voidSendData+0xf0>
    146c:	88 ec       	ldi	r24, 0xC8	; 200
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	98 a3       	std	Y+32, r25	; 0x20
    1472:	8f 8f       	std	Y+31, r24	; 0x1f
    1474:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1476:	98 a1       	ldd	r25, Y+32	; 0x20
    1478:	01 97       	sbiw	r24, 0x01	; 1
    147a:	f1 f7       	brne	.-4      	; 0x1478 <CLCD_voidSendData+0xde>
    147c:	98 a3       	std	Y+32, r25	; 0x20
    147e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1480:	89 a1       	ldd	r24, Y+33	; 0x21
    1482:	9a a1       	ldd	r25, Y+34	; 0x22
    1484:	01 97       	sbiw	r24, 0x01	; 1
    1486:	9a a3       	std	Y+34, r25	; 0x22
    1488:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    148a:	89 a1       	ldd	r24, Y+33	; 0x21
    148c:	9a a1       	ldd	r25, Y+34	; 0x22
    148e:	00 97       	sbiw	r24, 0x00	; 0
    1490:	69 f7       	brne	.-38     	; 0x146c <CLCD_voidSendData+0xd2>
    1492:	14 c0       	rjmp	.+40     	; 0x14bc <CLCD_voidSendData+0x122>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1494:	6b a1       	ldd	r22, Y+35	; 0x23
    1496:	7c a1       	ldd	r23, Y+36	; 0x24
    1498:	8d a1       	ldd	r24, Y+37	; 0x25
    149a:	9e a1       	ldd	r25, Y+38	; 0x26
    149c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    14a0:	dc 01       	movw	r26, r24
    14a2:	cb 01       	movw	r24, r22
    14a4:	9a a3       	std	Y+34, r25	; 0x22
    14a6:	89 a3       	std	Y+33, r24	; 0x21
    14a8:	89 a1       	ldd	r24, Y+33	; 0x21
    14aa:	9a a1       	ldd	r25, Y+34	; 0x22
    14ac:	9e 8f       	std	Y+30, r25	; 0x1e
    14ae:	8d 8f       	std	Y+29, r24	; 0x1d
    14b0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    14b2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    14b4:	01 97       	sbiw	r24, 0x01	; 1
    14b6:	f1 f7       	brne	.-4      	; 0x14b4 <CLCD_voidSendData+0x11a>
    14b8:	9e 8f       	std	Y+30, r25	; 0x1e
    14ba:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_PIN_LOW);
    14bc:	80 e0       	ldi	r24, 0x00	; 0
    14be:	62 e0       	ldi	r22, 0x02	; 2
    14c0:	40 e0       	ldi	r20, 0x00	; 0
    14c2:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
	Local_u8Mask=0b11110000;
    14c6:	80 ef       	ldi	r24, 0xF0	; 240
    14c8:	8b a7       	std	Y+43, r24	; 0x2b
	Local_u8Mask = ~(Local_u8Mask) & Copy_u8Data;
    14ca:	8b a5       	ldd	r24, Y+43	; 0x2b
    14cc:	98 2f       	mov	r25, r24
    14ce:	90 95       	com	r25
    14d0:	8c a5       	ldd	r24, Y+44	; 0x2c
    14d2:	89 23       	and	r24, r25
    14d4:	8b a7       	std	Y+43, r24	; 0x2b
	DIO_u8SetPortValue(CLCD_DATA_PORT, (Local_u8Mask << 4));
    14d6:	8b a5       	ldd	r24, Y+43	; 0x2b
    14d8:	98 2f       	mov	r25, r24
    14da:	92 95       	swap	r25
    14dc:	90 7f       	andi	r25, 0xF0	; 240
    14de:	81 e0       	ldi	r24, 0x01	; 1
    14e0:	69 2f       	mov	r22, r25
    14e2:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <DIO_u8SetPortValue>
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_PIN_HIGH);
    14e6:	80 e0       	ldi	r24, 0x00	; 0
    14e8:	62 e0       	ldi	r22, 0x02	; 2
    14ea:	41 e0       	ldi	r20, 0x01	; 1
    14ec:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
    14f0:	80 e0       	ldi	r24, 0x00	; 0
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	a0 e0       	ldi	r26, 0x00	; 0
    14f6:	b0 e4       	ldi	r27, 0x40	; 64
    14f8:	89 8f       	std	Y+25, r24	; 0x19
    14fa:	9a 8f       	std	Y+26, r25	; 0x1a
    14fc:	ab 8f       	std	Y+27, r26	; 0x1b
    14fe:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1500:	69 8d       	ldd	r22, Y+25	; 0x19
    1502:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1504:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1506:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1508:	20 e0       	ldi	r18, 0x00	; 0
    150a:	30 e0       	ldi	r19, 0x00	; 0
    150c:	4a ef       	ldi	r20, 0xFA	; 250
    150e:	54 e4       	ldi	r21, 0x44	; 68
    1510:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1514:	dc 01       	movw	r26, r24
    1516:	cb 01       	movw	r24, r22
    1518:	8d 8b       	std	Y+21, r24	; 0x15
    151a:	9e 8b       	std	Y+22, r25	; 0x16
    151c:	af 8b       	std	Y+23, r26	; 0x17
    151e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1520:	6d 89       	ldd	r22, Y+21	; 0x15
    1522:	7e 89       	ldd	r23, Y+22	; 0x16
    1524:	8f 89       	ldd	r24, Y+23	; 0x17
    1526:	98 8d       	ldd	r25, Y+24	; 0x18
    1528:	20 e0       	ldi	r18, 0x00	; 0
    152a:	30 e0       	ldi	r19, 0x00	; 0
    152c:	40 e8       	ldi	r20, 0x80	; 128
    152e:	5f e3       	ldi	r21, 0x3F	; 63
    1530:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1534:	88 23       	and	r24, r24
    1536:	2c f4       	brge	.+10     	; 0x1542 <CLCD_voidSendData+0x1a8>
		__ticks = 1;
    1538:	81 e0       	ldi	r24, 0x01	; 1
    153a:	90 e0       	ldi	r25, 0x00	; 0
    153c:	9c 8b       	std	Y+20, r25	; 0x14
    153e:	8b 8b       	std	Y+19, r24	; 0x13
    1540:	3f c0       	rjmp	.+126    	; 0x15c0 <CLCD_voidSendData+0x226>
	else if (__tmp > 65535)
    1542:	6d 89       	ldd	r22, Y+21	; 0x15
    1544:	7e 89       	ldd	r23, Y+22	; 0x16
    1546:	8f 89       	ldd	r24, Y+23	; 0x17
    1548:	98 8d       	ldd	r25, Y+24	; 0x18
    154a:	20 e0       	ldi	r18, 0x00	; 0
    154c:	3f ef       	ldi	r19, 0xFF	; 255
    154e:	4f e7       	ldi	r20, 0x7F	; 127
    1550:	57 e4       	ldi	r21, 0x47	; 71
    1552:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1556:	18 16       	cp	r1, r24
    1558:	4c f5       	brge	.+82     	; 0x15ac <CLCD_voidSendData+0x212>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    155a:	69 8d       	ldd	r22, Y+25	; 0x19
    155c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    155e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1560:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1562:	20 e0       	ldi	r18, 0x00	; 0
    1564:	30 e0       	ldi	r19, 0x00	; 0
    1566:	40 e2       	ldi	r20, 0x20	; 32
    1568:	51 e4       	ldi	r21, 0x41	; 65
    156a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    156e:	dc 01       	movw	r26, r24
    1570:	cb 01       	movw	r24, r22
    1572:	bc 01       	movw	r22, r24
    1574:	cd 01       	movw	r24, r26
    1576:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    157a:	dc 01       	movw	r26, r24
    157c:	cb 01       	movw	r24, r22
    157e:	9c 8b       	std	Y+20, r25	; 0x14
    1580:	8b 8b       	std	Y+19, r24	; 0x13
    1582:	0f c0       	rjmp	.+30     	; 0x15a2 <CLCD_voidSendData+0x208>
    1584:	88 ec       	ldi	r24, 0xC8	; 200
    1586:	90 e0       	ldi	r25, 0x00	; 0
    1588:	9a 8b       	std	Y+18, r25	; 0x12
    158a:	89 8b       	std	Y+17, r24	; 0x11
    158c:	89 89       	ldd	r24, Y+17	; 0x11
    158e:	9a 89       	ldd	r25, Y+18	; 0x12
    1590:	01 97       	sbiw	r24, 0x01	; 1
    1592:	f1 f7       	brne	.-4      	; 0x1590 <CLCD_voidSendData+0x1f6>
    1594:	9a 8b       	std	Y+18, r25	; 0x12
    1596:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1598:	8b 89       	ldd	r24, Y+19	; 0x13
    159a:	9c 89       	ldd	r25, Y+20	; 0x14
    159c:	01 97       	sbiw	r24, 0x01	; 1
    159e:	9c 8b       	std	Y+20, r25	; 0x14
    15a0:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    15a2:	8b 89       	ldd	r24, Y+19	; 0x13
    15a4:	9c 89       	ldd	r25, Y+20	; 0x14
    15a6:	00 97       	sbiw	r24, 0x00	; 0
    15a8:	69 f7       	brne	.-38     	; 0x1584 <CLCD_voidSendData+0x1ea>
    15aa:	14 c0       	rjmp	.+40     	; 0x15d4 <CLCD_voidSendData+0x23a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    15ac:	6d 89       	ldd	r22, Y+21	; 0x15
    15ae:	7e 89       	ldd	r23, Y+22	; 0x16
    15b0:	8f 89       	ldd	r24, Y+23	; 0x17
    15b2:	98 8d       	ldd	r25, Y+24	; 0x18
    15b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15b8:	dc 01       	movw	r26, r24
    15ba:	cb 01       	movw	r24, r22
    15bc:	9c 8b       	std	Y+20, r25	; 0x14
    15be:	8b 8b       	std	Y+19, r24	; 0x13
    15c0:	8b 89       	ldd	r24, Y+19	; 0x13
    15c2:	9c 89       	ldd	r25, Y+20	; 0x14
    15c4:	98 8b       	std	Y+16, r25	; 0x10
    15c6:	8f 87       	std	Y+15, r24	; 0x0f
    15c8:	8f 85       	ldd	r24, Y+15	; 0x0f
    15ca:	98 89       	ldd	r25, Y+16	; 0x10
    15cc:	01 97       	sbiw	r24, 0x01	; 1
    15ce:	f1 f7       	brne	.-4      	; 0x15cc <CLCD_voidSendData+0x232>
    15d0:	98 8b       	std	Y+16, r25	; 0x10
    15d2:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_PIN_LOW);
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	62 e0       	ldi	r22, 0x02	; 2
    15d8:	40 e0       	ldi	r20, 0x00	; 0
    15da:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
    15de:	80 e0       	ldi	r24, 0x00	; 0
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	a0 e0       	ldi	r26, 0x00	; 0
    15e4:	b0 e4       	ldi	r27, 0x40	; 64
    15e6:	8b 87       	std	Y+11, r24	; 0x0b
    15e8:	9c 87       	std	Y+12, r25	; 0x0c
    15ea:	ad 87       	std	Y+13, r26	; 0x0d
    15ec:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    15ee:	6b 85       	ldd	r22, Y+11	; 0x0b
    15f0:	7c 85       	ldd	r23, Y+12	; 0x0c
    15f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    15f4:	9e 85       	ldd	r25, Y+14	; 0x0e
    15f6:	20 e0       	ldi	r18, 0x00	; 0
    15f8:	30 e0       	ldi	r19, 0x00	; 0
    15fa:	4a ef       	ldi	r20, 0xFA	; 250
    15fc:	54 e4       	ldi	r21, 0x44	; 68
    15fe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1602:	dc 01       	movw	r26, r24
    1604:	cb 01       	movw	r24, r22
    1606:	8f 83       	std	Y+7, r24	; 0x07
    1608:	98 87       	std	Y+8, r25	; 0x08
    160a:	a9 87       	std	Y+9, r26	; 0x09
    160c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    160e:	6f 81       	ldd	r22, Y+7	; 0x07
    1610:	78 85       	ldd	r23, Y+8	; 0x08
    1612:	89 85       	ldd	r24, Y+9	; 0x09
    1614:	9a 85       	ldd	r25, Y+10	; 0x0a
    1616:	20 e0       	ldi	r18, 0x00	; 0
    1618:	30 e0       	ldi	r19, 0x00	; 0
    161a:	40 e8       	ldi	r20, 0x80	; 128
    161c:	5f e3       	ldi	r21, 0x3F	; 63
    161e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1622:	88 23       	and	r24, r24
    1624:	2c f4       	brge	.+10     	; 0x1630 <CLCD_voidSendData+0x296>
		__ticks = 1;
    1626:	81 e0       	ldi	r24, 0x01	; 1
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	9e 83       	std	Y+6, r25	; 0x06
    162c:	8d 83       	std	Y+5, r24	; 0x05
    162e:	3f c0       	rjmp	.+126    	; 0x16ae <CLCD_voidSendData+0x314>
	else if (__tmp > 65535)
    1630:	6f 81       	ldd	r22, Y+7	; 0x07
    1632:	78 85       	ldd	r23, Y+8	; 0x08
    1634:	89 85       	ldd	r24, Y+9	; 0x09
    1636:	9a 85       	ldd	r25, Y+10	; 0x0a
    1638:	20 e0       	ldi	r18, 0x00	; 0
    163a:	3f ef       	ldi	r19, 0xFF	; 255
    163c:	4f e7       	ldi	r20, 0x7F	; 127
    163e:	57 e4       	ldi	r21, 0x47	; 71
    1640:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1644:	18 16       	cp	r1, r24
    1646:	4c f5       	brge	.+82     	; 0x169a <CLCD_voidSendData+0x300>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1648:	6b 85       	ldd	r22, Y+11	; 0x0b
    164a:	7c 85       	ldd	r23, Y+12	; 0x0c
    164c:	8d 85       	ldd	r24, Y+13	; 0x0d
    164e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1650:	20 e0       	ldi	r18, 0x00	; 0
    1652:	30 e0       	ldi	r19, 0x00	; 0
    1654:	40 e2       	ldi	r20, 0x20	; 32
    1656:	51 e4       	ldi	r21, 0x41	; 65
    1658:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    165c:	dc 01       	movw	r26, r24
    165e:	cb 01       	movw	r24, r22
    1660:	bc 01       	movw	r22, r24
    1662:	cd 01       	movw	r24, r26
    1664:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1668:	dc 01       	movw	r26, r24
    166a:	cb 01       	movw	r24, r22
    166c:	9e 83       	std	Y+6, r25	; 0x06
    166e:	8d 83       	std	Y+5, r24	; 0x05
    1670:	0f c0       	rjmp	.+30     	; 0x1690 <CLCD_voidSendData+0x2f6>
    1672:	88 ec       	ldi	r24, 0xC8	; 200
    1674:	90 e0       	ldi	r25, 0x00	; 0
    1676:	9c 83       	std	Y+4, r25	; 0x04
    1678:	8b 83       	std	Y+3, r24	; 0x03
    167a:	8b 81       	ldd	r24, Y+3	; 0x03
    167c:	9c 81       	ldd	r25, Y+4	; 0x04
    167e:	01 97       	sbiw	r24, 0x01	; 1
    1680:	f1 f7       	brne	.-4      	; 0x167e <CLCD_voidSendData+0x2e4>
    1682:	9c 83       	std	Y+4, r25	; 0x04
    1684:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1686:	8d 81       	ldd	r24, Y+5	; 0x05
    1688:	9e 81       	ldd	r25, Y+6	; 0x06
    168a:	01 97       	sbiw	r24, 0x01	; 1
    168c:	9e 83       	std	Y+6, r25	; 0x06
    168e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1690:	8d 81       	ldd	r24, Y+5	; 0x05
    1692:	9e 81       	ldd	r25, Y+6	; 0x06
    1694:	00 97       	sbiw	r24, 0x00	; 0
    1696:	69 f7       	brne	.-38     	; 0x1672 <CLCD_voidSendData+0x2d8>
    1698:	14 c0       	rjmp	.+40     	; 0x16c2 <CLCD_voidSendData+0x328>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    169a:	6f 81       	ldd	r22, Y+7	; 0x07
    169c:	78 85       	ldd	r23, Y+8	; 0x08
    169e:	89 85       	ldd	r24, Y+9	; 0x09
    16a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    16a2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16a6:	dc 01       	movw	r26, r24
    16a8:	cb 01       	movw	r24, r22
    16aa:	9e 83       	std	Y+6, r25	; 0x06
    16ac:	8d 83       	std	Y+5, r24	; 0x05
    16ae:	8d 81       	ldd	r24, Y+5	; 0x05
    16b0:	9e 81       	ldd	r25, Y+6	; 0x06
    16b2:	9a 83       	std	Y+2, r25	; 0x02
    16b4:	89 83       	std	Y+1, r24	; 0x01
    16b6:	89 81       	ldd	r24, Y+1	; 0x01
    16b8:	9a 81       	ldd	r25, Y+2	; 0x02
    16ba:	01 97       	sbiw	r24, 0x01	; 1
    16bc:	f1 f7       	brne	.-4      	; 0x16ba <CLCD_voidSendData+0x320>
    16be:	9a 83       	std	Y+2, r25	; 0x02
    16c0:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	CLCD_voidSendCommand(0x06);
    16c2:	86 e0       	ldi	r24, 0x06	; 6
    16c4:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>
#else
#error "In correct cconfigrtion of LCD_MODE"
#endif
}
    16c8:	ac 96       	adiw	r28, 0x2c	; 44
    16ca:	0f b6       	in	r0, 0x3f	; 63
    16cc:	f8 94       	cli
    16ce:	de bf       	out	0x3e, r29	; 62
    16d0:	0f be       	out	0x3f, r0	; 63
    16d2:	cd bf       	out	0x3d, r28	; 61
    16d4:	cf 91       	pop	r28
    16d6:	df 91       	pop	r29
    16d8:	08 95       	ret

000016da <CLCD_voidInit>:

void CLCD_voidInit(void)
{
    16da:	df 93       	push	r29
    16dc:	cf 93       	push	r28
    16de:	cd b7       	in	r28, 0x3d	; 61
    16e0:	de b7       	in	r29, 0x3e	; 62
    16e2:	e8 97       	sbiw	r28, 0x38	; 56
    16e4:	0f b6       	in	r0, 0x3f	; 63
    16e6:	f8 94       	cli
    16e8:	de bf       	out	0x3e, r29	; 62
    16ea:	0f be       	out	0x3f, r0	; 63
    16ec:	cd bf       	out	0x3d, r28	; 61
    16ee:	80 e0       	ldi	r24, 0x00	; 0
    16f0:	90 e0       	ldi	r25, 0x00	; 0
    16f2:	a0 e2       	ldi	r26, 0x20	; 32
    16f4:	b2 e4       	ldi	r27, 0x42	; 66
    16f6:	8d ab       	std	Y+53, r24	; 0x35
    16f8:	9e ab       	std	Y+54, r25	; 0x36
    16fa:	af ab       	std	Y+55, r26	; 0x37
    16fc:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    16fe:	6d a9       	ldd	r22, Y+53	; 0x35
    1700:	7e a9       	ldd	r23, Y+54	; 0x36
    1702:	8f a9       	ldd	r24, Y+55	; 0x37
    1704:	98 ad       	ldd	r25, Y+56	; 0x38
    1706:	20 e0       	ldi	r18, 0x00	; 0
    1708:	30 e0       	ldi	r19, 0x00	; 0
    170a:	4a ef       	ldi	r20, 0xFA	; 250
    170c:	54 e4       	ldi	r21, 0x44	; 68
    170e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1712:	dc 01       	movw	r26, r24
    1714:	cb 01       	movw	r24, r22
    1716:	89 ab       	std	Y+49, r24	; 0x31
    1718:	9a ab       	std	Y+50, r25	; 0x32
    171a:	ab ab       	std	Y+51, r26	; 0x33
    171c:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    171e:	69 a9       	ldd	r22, Y+49	; 0x31
    1720:	7a a9       	ldd	r23, Y+50	; 0x32
    1722:	8b a9       	ldd	r24, Y+51	; 0x33
    1724:	9c a9       	ldd	r25, Y+52	; 0x34
    1726:	20 e0       	ldi	r18, 0x00	; 0
    1728:	30 e0       	ldi	r19, 0x00	; 0
    172a:	40 e8       	ldi	r20, 0x80	; 128
    172c:	5f e3       	ldi	r21, 0x3F	; 63
    172e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1732:	88 23       	and	r24, r24
    1734:	2c f4       	brge	.+10     	; 0x1740 <CLCD_voidInit+0x66>
		__ticks = 1;
    1736:	81 e0       	ldi	r24, 0x01	; 1
    1738:	90 e0       	ldi	r25, 0x00	; 0
    173a:	98 ab       	std	Y+48, r25	; 0x30
    173c:	8f a7       	std	Y+47, r24	; 0x2f
    173e:	3f c0       	rjmp	.+126    	; 0x17be <CLCD_voidInit+0xe4>
	else if (__tmp > 65535)
    1740:	69 a9       	ldd	r22, Y+49	; 0x31
    1742:	7a a9       	ldd	r23, Y+50	; 0x32
    1744:	8b a9       	ldd	r24, Y+51	; 0x33
    1746:	9c a9       	ldd	r25, Y+52	; 0x34
    1748:	20 e0       	ldi	r18, 0x00	; 0
    174a:	3f ef       	ldi	r19, 0xFF	; 255
    174c:	4f e7       	ldi	r20, 0x7F	; 127
    174e:	57 e4       	ldi	r21, 0x47	; 71
    1750:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1754:	18 16       	cp	r1, r24
    1756:	4c f5       	brge	.+82     	; 0x17aa <CLCD_voidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1758:	6d a9       	ldd	r22, Y+53	; 0x35
    175a:	7e a9       	ldd	r23, Y+54	; 0x36
    175c:	8f a9       	ldd	r24, Y+55	; 0x37
    175e:	98 ad       	ldd	r25, Y+56	; 0x38
    1760:	20 e0       	ldi	r18, 0x00	; 0
    1762:	30 e0       	ldi	r19, 0x00	; 0
    1764:	40 e2       	ldi	r20, 0x20	; 32
    1766:	51 e4       	ldi	r21, 0x41	; 65
    1768:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    176c:	dc 01       	movw	r26, r24
    176e:	cb 01       	movw	r24, r22
    1770:	bc 01       	movw	r22, r24
    1772:	cd 01       	movw	r24, r26
    1774:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1778:	dc 01       	movw	r26, r24
    177a:	cb 01       	movw	r24, r22
    177c:	98 ab       	std	Y+48, r25	; 0x30
    177e:	8f a7       	std	Y+47, r24	; 0x2f
    1780:	0f c0       	rjmp	.+30     	; 0x17a0 <CLCD_voidInit+0xc6>
    1782:	88 ec       	ldi	r24, 0xC8	; 200
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	9e a7       	std	Y+46, r25	; 0x2e
    1788:	8d a7       	std	Y+45, r24	; 0x2d
    178a:	8d a5       	ldd	r24, Y+45	; 0x2d
    178c:	9e a5       	ldd	r25, Y+46	; 0x2e
    178e:	01 97       	sbiw	r24, 0x01	; 1
    1790:	f1 f7       	brne	.-4      	; 0x178e <CLCD_voidInit+0xb4>
    1792:	9e a7       	std	Y+46, r25	; 0x2e
    1794:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1796:	8f a5       	ldd	r24, Y+47	; 0x2f
    1798:	98 a9       	ldd	r25, Y+48	; 0x30
    179a:	01 97       	sbiw	r24, 0x01	; 1
    179c:	98 ab       	std	Y+48, r25	; 0x30
    179e:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17a0:	8f a5       	ldd	r24, Y+47	; 0x2f
    17a2:	98 a9       	ldd	r25, Y+48	; 0x30
    17a4:	00 97       	sbiw	r24, 0x00	; 0
    17a6:	69 f7       	brne	.-38     	; 0x1782 <CLCD_voidInit+0xa8>
    17a8:	14 c0       	rjmp	.+40     	; 0x17d2 <CLCD_voidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    17aa:	69 a9       	ldd	r22, Y+49	; 0x31
    17ac:	7a a9       	ldd	r23, Y+50	; 0x32
    17ae:	8b a9       	ldd	r24, Y+51	; 0x33
    17b0:	9c a9       	ldd	r25, Y+52	; 0x34
    17b2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17b6:	dc 01       	movw	r26, r24
    17b8:	cb 01       	movw	r24, r22
    17ba:	98 ab       	std	Y+48, r25	; 0x30
    17bc:	8f a7       	std	Y+47, r24	; 0x2f
    17be:	8f a5       	ldd	r24, Y+47	; 0x2f
    17c0:	98 a9       	ldd	r25, Y+48	; 0x30
    17c2:	9c a7       	std	Y+44, r25	; 0x2c
    17c4:	8b a7       	std	Y+43, r24	; 0x2b
    17c6:	8b a5       	ldd	r24, Y+43	; 0x2b
    17c8:	9c a5       	ldd	r25, Y+44	; 0x2c
    17ca:	01 97       	sbiw	r24, 0x01	; 1
    17cc:	f1 f7       	brne	.-4      	; 0x17ca <CLCD_voidInit+0xf0>
    17ce:	9c a7       	std	Y+44, r25	; 0x2c
    17d0:	8b a7       	std	Y+43, r24	; 0x2b
	CLCD_voidSendCommand(0b00000001);
#elif CLCD_CHIOCE_MODE==_4_BIT_MODE
	/*WAIT FOR MORE THEN 30 MS*/
	_delay_ms(40);
	/*function set command: Set Bit 5 */
	CLCD_voidSendCommand(0b00100000);
    17d2:	80 e2       	ldi	r24, 0x20	; 32
    17d4:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>
	CLCD_voidSendCommand(0b00100000);
    17d8:	80 e2       	ldi	r24, 0x20	; 32
    17da:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>

	/*function set command:(7_Bit) N --> Lines,(6_Bit) F --> 5*8 font */
	CLCD_voidSendCommand(0b10000000);
    17de:	80 e8       	ldi	r24, 0x80	; 128
    17e0:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>
    17e4:	80 e0       	ldi	r24, 0x00	; 0
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	a0 e8       	ldi	r26, 0x80	; 128
    17ea:	bf e3       	ldi	r27, 0x3F	; 63
    17ec:	8f a3       	std	Y+39, r24	; 0x27
    17ee:	98 a7       	std	Y+40, r25	; 0x28
    17f0:	a9 a7       	std	Y+41, r26	; 0x29
    17f2:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    17f4:	6f a1       	ldd	r22, Y+39	; 0x27
    17f6:	78 a5       	ldd	r23, Y+40	; 0x28
    17f8:	89 a5       	ldd	r24, Y+41	; 0x29
    17fa:	9a a5       	ldd	r25, Y+42	; 0x2a
    17fc:	20 e0       	ldi	r18, 0x00	; 0
    17fe:	30 e0       	ldi	r19, 0x00	; 0
    1800:	4a ef       	ldi	r20, 0xFA	; 250
    1802:	54 e4       	ldi	r21, 0x44	; 68
    1804:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1808:	dc 01       	movw	r26, r24
    180a:	cb 01       	movw	r24, r22
    180c:	8b a3       	std	Y+35, r24	; 0x23
    180e:	9c a3       	std	Y+36, r25	; 0x24
    1810:	ad a3       	std	Y+37, r26	; 0x25
    1812:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1814:	6b a1       	ldd	r22, Y+35	; 0x23
    1816:	7c a1       	ldd	r23, Y+36	; 0x24
    1818:	8d a1       	ldd	r24, Y+37	; 0x25
    181a:	9e a1       	ldd	r25, Y+38	; 0x26
    181c:	20 e0       	ldi	r18, 0x00	; 0
    181e:	30 e0       	ldi	r19, 0x00	; 0
    1820:	40 e8       	ldi	r20, 0x80	; 128
    1822:	5f e3       	ldi	r21, 0x3F	; 63
    1824:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1828:	88 23       	and	r24, r24
    182a:	2c f4       	brge	.+10     	; 0x1836 <CLCD_voidInit+0x15c>
		__ticks = 1;
    182c:	81 e0       	ldi	r24, 0x01	; 1
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	9a a3       	std	Y+34, r25	; 0x22
    1832:	89 a3       	std	Y+33, r24	; 0x21
    1834:	3f c0       	rjmp	.+126    	; 0x18b4 <CLCD_voidInit+0x1da>
	else if (__tmp > 65535)
    1836:	6b a1       	ldd	r22, Y+35	; 0x23
    1838:	7c a1       	ldd	r23, Y+36	; 0x24
    183a:	8d a1       	ldd	r24, Y+37	; 0x25
    183c:	9e a1       	ldd	r25, Y+38	; 0x26
    183e:	20 e0       	ldi	r18, 0x00	; 0
    1840:	3f ef       	ldi	r19, 0xFF	; 255
    1842:	4f e7       	ldi	r20, 0x7F	; 127
    1844:	57 e4       	ldi	r21, 0x47	; 71
    1846:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    184a:	18 16       	cp	r1, r24
    184c:	4c f5       	brge	.+82     	; 0x18a0 <CLCD_voidInit+0x1c6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    184e:	6f a1       	ldd	r22, Y+39	; 0x27
    1850:	78 a5       	ldd	r23, Y+40	; 0x28
    1852:	89 a5       	ldd	r24, Y+41	; 0x29
    1854:	9a a5       	ldd	r25, Y+42	; 0x2a
    1856:	20 e0       	ldi	r18, 0x00	; 0
    1858:	30 e0       	ldi	r19, 0x00	; 0
    185a:	40 e2       	ldi	r20, 0x20	; 32
    185c:	51 e4       	ldi	r21, 0x41	; 65
    185e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1862:	dc 01       	movw	r26, r24
    1864:	cb 01       	movw	r24, r22
    1866:	bc 01       	movw	r22, r24
    1868:	cd 01       	movw	r24, r26
    186a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    186e:	dc 01       	movw	r26, r24
    1870:	cb 01       	movw	r24, r22
    1872:	9a a3       	std	Y+34, r25	; 0x22
    1874:	89 a3       	std	Y+33, r24	; 0x21
    1876:	0f c0       	rjmp	.+30     	; 0x1896 <CLCD_voidInit+0x1bc>
    1878:	88 ec       	ldi	r24, 0xC8	; 200
    187a:	90 e0       	ldi	r25, 0x00	; 0
    187c:	98 a3       	std	Y+32, r25	; 0x20
    187e:	8f 8f       	std	Y+31, r24	; 0x1f
    1880:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1882:	98 a1       	ldd	r25, Y+32	; 0x20
    1884:	01 97       	sbiw	r24, 0x01	; 1
    1886:	f1 f7       	brne	.-4      	; 0x1884 <CLCD_voidInit+0x1aa>
    1888:	98 a3       	std	Y+32, r25	; 0x20
    188a:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    188c:	89 a1       	ldd	r24, Y+33	; 0x21
    188e:	9a a1       	ldd	r25, Y+34	; 0x22
    1890:	01 97       	sbiw	r24, 0x01	; 1
    1892:	9a a3       	std	Y+34, r25	; 0x22
    1894:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1896:	89 a1       	ldd	r24, Y+33	; 0x21
    1898:	9a a1       	ldd	r25, Y+34	; 0x22
    189a:	00 97       	sbiw	r24, 0x00	; 0
    189c:	69 f7       	brne	.-38     	; 0x1878 <CLCD_voidInit+0x19e>
    189e:	14 c0       	rjmp	.+40     	; 0x18c8 <CLCD_voidInit+0x1ee>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18a0:	6b a1       	ldd	r22, Y+35	; 0x23
    18a2:	7c a1       	ldd	r23, Y+36	; 0x24
    18a4:	8d a1       	ldd	r24, Y+37	; 0x25
    18a6:	9e a1       	ldd	r25, Y+38	; 0x26
    18a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18ac:	dc 01       	movw	r26, r24
    18ae:	cb 01       	movw	r24, r22
    18b0:	9a a3       	std	Y+34, r25	; 0x22
    18b2:	89 a3       	std	Y+33, r24	; 0x21
    18b4:	89 a1       	ldd	r24, Y+33	; 0x21
    18b6:	9a a1       	ldd	r25, Y+34	; 0x22
    18b8:	9e 8f       	std	Y+30, r25	; 0x1e
    18ba:	8d 8f       	std	Y+29, r24	; 0x1d
    18bc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    18be:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18c0:	01 97       	sbiw	r24, 0x01	; 1
    18c2:	f1 f7       	brne	.-4      	; 0x18c0 <CLCD_voidInit+0x1e6>
    18c4:	9e 8f       	std	Y+30, r25	; 0x1e
    18c6:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	CLCD_voidSendCommand(0b0000);
    18c8:	80 e0       	ldi	r24, 0x00	; 0
    18ca:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>
	/*Display No/00f ctrl  */
	/*Set Bit 7 ,(6_Bit) D --> display enable ,C --> disable cursor ,B --> no blink cursor*/
	CLCD_voidSendCommand(0b11000000);
    18ce:	80 ec       	ldi	r24, 0xC0	; 192
    18d0:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>
    18d4:	80 e0       	ldi	r24, 0x00	; 0
    18d6:	90 e0       	ldi	r25, 0x00	; 0
    18d8:	a0 e8       	ldi	r26, 0x80	; 128
    18da:	bf e3       	ldi	r27, 0x3F	; 63
    18dc:	89 8f       	std	Y+25, r24	; 0x19
    18de:	9a 8f       	std	Y+26, r25	; 0x1a
    18e0:	ab 8f       	std	Y+27, r26	; 0x1b
    18e2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    18e4:	69 8d       	ldd	r22, Y+25	; 0x19
    18e6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    18e8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18ec:	20 e0       	ldi	r18, 0x00	; 0
    18ee:	30 e0       	ldi	r19, 0x00	; 0
    18f0:	4a ef       	ldi	r20, 0xFA	; 250
    18f2:	54 e4       	ldi	r21, 0x44	; 68
    18f4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18f8:	dc 01       	movw	r26, r24
    18fa:	cb 01       	movw	r24, r22
    18fc:	8d 8b       	std	Y+21, r24	; 0x15
    18fe:	9e 8b       	std	Y+22, r25	; 0x16
    1900:	af 8b       	std	Y+23, r26	; 0x17
    1902:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1904:	6d 89       	ldd	r22, Y+21	; 0x15
    1906:	7e 89       	ldd	r23, Y+22	; 0x16
    1908:	8f 89       	ldd	r24, Y+23	; 0x17
    190a:	98 8d       	ldd	r25, Y+24	; 0x18
    190c:	20 e0       	ldi	r18, 0x00	; 0
    190e:	30 e0       	ldi	r19, 0x00	; 0
    1910:	40 e8       	ldi	r20, 0x80	; 128
    1912:	5f e3       	ldi	r21, 0x3F	; 63
    1914:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1918:	88 23       	and	r24, r24
    191a:	2c f4       	brge	.+10     	; 0x1926 <CLCD_voidInit+0x24c>
		__ticks = 1;
    191c:	81 e0       	ldi	r24, 0x01	; 1
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	9c 8b       	std	Y+20, r25	; 0x14
    1922:	8b 8b       	std	Y+19, r24	; 0x13
    1924:	3f c0       	rjmp	.+126    	; 0x19a4 <CLCD_voidInit+0x2ca>
	else if (__tmp > 65535)
    1926:	6d 89       	ldd	r22, Y+21	; 0x15
    1928:	7e 89       	ldd	r23, Y+22	; 0x16
    192a:	8f 89       	ldd	r24, Y+23	; 0x17
    192c:	98 8d       	ldd	r25, Y+24	; 0x18
    192e:	20 e0       	ldi	r18, 0x00	; 0
    1930:	3f ef       	ldi	r19, 0xFF	; 255
    1932:	4f e7       	ldi	r20, 0x7F	; 127
    1934:	57 e4       	ldi	r21, 0x47	; 71
    1936:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    193a:	18 16       	cp	r1, r24
    193c:	4c f5       	brge	.+82     	; 0x1990 <CLCD_voidInit+0x2b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    193e:	69 8d       	ldd	r22, Y+25	; 0x19
    1940:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1942:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1944:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1946:	20 e0       	ldi	r18, 0x00	; 0
    1948:	30 e0       	ldi	r19, 0x00	; 0
    194a:	40 e2       	ldi	r20, 0x20	; 32
    194c:	51 e4       	ldi	r21, 0x41	; 65
    194e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1952:	dc 01       	movw	r26, r24
    1954:	cb 01       	movw	r24, r22
    1956:	bc 01       	movw	r22, r24
    1958:	cd 01       	movw	r24, r26
    195a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    195e:	dc 01       	movw	r26, r24
    1960:	cb 01       	movw	r24, r22
    1962:	9c 8b       	std	Y+20, r25	; 0x14
    1964:	8b 8b       	std	Y+19, r24	; 0x13
    1966:	0f c0       	rjmp	.+30     	; 0x1986 <CLCD_voidInit+0x2ac>
    1968:	88 ec       	ldi	r24, 0xC8	; 200
    196a:	90 e0       	ldi	r25, 0x00	; 0
    196c:	9a 8b       	std	Y+18, r25	; 0x12
    196e:	89 8b       	std	Y+17, r24	; 0x11
    1970:	89 89       	ldd	r24, Y+17	; 0x11
    1972:	9a 89       	ldd	r25, Y+18	; 0x12
    1974:	01 97       	sbiw	r24, 0x01	; 1
    1976:	f1 f7       	brne	.-4      	; 0x1974 <CLCD_voidInit+0x29a>
    1978:	9a 8b       	std	Y+18, r25	; 0x12
    197a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    197c:	8b 89       	ldd	r24, Y+19	; 0x13
    197e:	9c 89       	ldd	r25, Y+20	; 0x14
    1980:	01 97       	sbiw	r24, 0x01	; 1
    1982:	9c 8b       	std	Y+20, r25	; 0x14
    1984:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1986:	8b 89       	ldd	r24, Y+19	; 0x13
    1988:	9c 89       	ldd	r25, Y+20	; 0x14
    198a:	00 97       	sbiw	r24, 0x00	; 0
    198c:	69 f7       	brne	.-38     	; 0x1968 <CLCD_voidInit+0x28e>
    198e:	14 c0       	rjmp	.+40     	; 0x19b8 <CLCD_voidInit+0x2de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1990:	6d 89       	ldd	r22, Y+21	; 0x15
    1992:	7e 89       	ldd	r23, Y+22	; 0x16
    1994:	8f 89       	ldd	r24, Y+23	; 0x17
    1996:	98 8d       	ldd	r25, Y+24	; 0x18
    1998:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    199c:	dc 01       	movw	r26, r24
    199e:	cb 01       	movw	r24, r22
    19a0:	9c 8b       	std	Y+20, r25	; 0x14
    19a2:	8b 8b       	std	Y+19, r24	; 0x13
    19a4:	8b 89       	ldd	r24, Y+19	; 0x13
    19a6:	9c 89       	ldd	r25, Y+20	; 0x14
    19a8:	98 8b       	std	Y+16, r25	; 0x10
    19aa:	8f 87       	std	Y+15, r24	; 0x0f
    19ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    19ae:	98 89       	ldd	r25, Y+16	; 0x10
    19b0:	01 97       	sbiw	r24, 0x01	; 1
    19b2:	f1 f7       	brne	.-4      	; 0x19b0 <CLCD_voidInit+0x2d6>
    19b4:	98 8b       	std	Y+16, r25	; 0x10
    19b6:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	CLCD_voidSendCommand(0b0000);
    19b8:	80 e0       	ldi	r24, 0x00	; 0
    19ba:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>
	/*Display Clear */
	CLCD_voidSendCommand(0b00010000);
    19be:	80 e1       	ldi	r24, 0x10	; 16
    19c0:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>
    19c4:	80 e0       	ldi	r24, 0x00	; 0
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	a0 e0       	ldi	r26, 0x00	; 0
    19ca:	b0 e4       	ldi	r27, 0x40	; 64
    19cc:	8b 87       	std	Y+11, r24	; 0x0b
    19ce:	9c 87       	std	Y+12, r25	; 0x0c
    19d0:	ad 87       	std	Y+13, r26	; 0x0d
    19d2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    19d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    19d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    19d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    19da:	9e 85       	ldd	r25, Y+14	; 0x0e
    19dc:	20 e0       	ldi	r18, 0x00	; 0
    19de:	30 e0       	ldi	r19, 0x00	; 0
    19e0:	4a ef       	ldi	r20, 0xFA	; 250
    19e2:	54 e4       	ldi	r21, 0x44	; 68
    19e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19e8:	dc 01       	movw	r26, r24
    19ea:	cb 01       	movw	r24, r22
    19ec:	8f 83       	std	Y+7, r24	; 0x07
    19ee:	98 87       	std	Y+8, r25	; 0x08
    19f0:	a9 87       	std	Y+9, r26	; 0x09
    19f2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    19f4:	6f 81       	ldd	r22, Y+7	; 0x07
    19f6:	78 85       	ldd	r23, Y+8	; 0x08
    19f8:	89 85       	ldd	r24, Y+9	; 0x09
    19fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    19fc:	20 e0       	ldi	r18, 0x00	; 0
    19fe:	30 e0       	ldi	r19, 0x00	; 0
    1a00:	40 e8       	ldi	r20, 0x80	; 128
    1a02:	5f e3       	ldi	r21, 0x3F	; 63
    1a04:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1a08:	88 23       	and	r24, r24
    1a0a:	2c f4       	brge	.+10     	; 0x1a16 <CLCD_voidInit+0x33c>
		__ticks = 1;
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
    1a0e:	90 e0       	ldi	r25, 0x00	; 0
    1a10:	9e 83       	std	Y+6, r25	; 0x06
    1a12:	8d 83       	std	Y+5, r24	; 0x05
    1a14:	3f c0       	rjmp	.+126    	; 0x1a94 <CLCD_voidInit+0x3ba>
	else if (__tmp > 65535)
    1a16:	6f 81       	ldd	r22, Y+7	; 0x07
    1a18:	78 85       	ldd	r23, Y+8	; 0x08
    1a1a:	89 85       	ldd	r24, Y+9	; 0x09
    1a1c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a1e:	20 e0       	ldi	r18, 0x00	; 0
    1a20:	3f ef       	ldi	r19, 0xFF	; 255
    1a22:	4f e7       	ldi	r20, 0x7F	; 127
    1a24:	57 e4       	ldi	r21, 0x47	; 71
    1a26:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a2a:	18 16       	cp	r1, r24
    1a2c:	4c f5       	brge	.+82     	; 0x1a80 <CLCD_voidInit+0x3a6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a2e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a30:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a32:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a34:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a36:	20 e0       	ldi	r18, 0x00	; 0
    1a38:	30 e0       	ldi	r19, 0x00	; 0
    1a3a:	40 e2       	ldi	r20, 0x20	; 32
    1a3c:	51 e4       	ldi	r21, 0x41	; 65
    1a3e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a42:	dc 01       	movw	r26, r24
    1a44:	cb 01       	movw	r24, r22
    1a46:	bc 01       	movw	r22, r24
    1a48:	cd 01       	movw	r24, r26
    1a4a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a4e:	dc 01       	movw	r26, r24
    1a50:	cb 01       	movw	r24, r22
    1a52:	9e 83       	std	Y+6, r25	; 0x06
    1a54:	8d 83       	std	Y+5, r24	; 0x05
    1a56:	0f c0       	rjmp	.+30     	; 0x1a76 <CLCD_voidInit+0x39c>
    1a58:	88 ec       	ldi	r24, 0xC8	; 200
    1a5a:	90 e0       	ldi	r25, 0x00	; 0
    1a5c:	9c 83       	std	Y+4, r25	; 0x04
    1a5e:	8b 83       	std	Y+3, r24	; 0x03
    1a60:	8b 81       	ldd	r24, Y+3	; 0x03
    1a62:	9c 81       	ldd	r25, Y+4	; 0x04
    1a64:	01 97       	sbiw	r24, 0x01	; 1
    1a66:	f1 f7       	brne	.-4      	; 0x1a64 <CLCD_voidInit+0x38a>
    1a68:	9c 83       	std	Y+4, r25	; 0x04
    1a6a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a70:	01 97       	sbiw	r24, 0x01	; 1
    1a72:	9e 83       	std	Y+6, r25	; 0x06
    1a74:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a76:	8d 81       	ldd	r24, Y+5	; 0x05
    1a78:	9e 81       	ldd	r25, Y+6	; 0x06
    1a7a:	00 97       	sbiw	r24, 0x00	; 0
    1a7c:	69 f7       	brne	.-38     	; 0x1a58 <CLCD_voidInit+0x37e>
    1a7e:	14 c0       	rjmp	.+40     	; 0x1aa8 <CLCD_voidInit+0x3ce>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a80:	6f 81       	ldd	r22, Y+7	; 0x07
    1a82:	78 85       	ldd	r23, Y+8	; 0x08
    1a84:	89 85       	ldd	r24, Y+9	; 0x09
    1a86:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a88:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a8c:	dc 01       	movw	r26, r24
    1a8e:	cb 01       	movw	r24, r22
    1a90:	9e 83       	std	Y+6, r25	; 0x06
    1a92:	8d 83       	std	Y+5, r24	; 0x05
    1a94:	8d 81       	ldd	r24, Y+5	; 0x05
    1a96:	9e 81       	ldd	r25, Y+6	; 0x06
    1a98:	9a 83       	std	Y+2, r25	; 0x02
    1a9a:	89 83       	std	Y+1, r24	; 0x01
    1a9c:	89 81       	ldd	r24, Y+1	; 0x01
    1a9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa0:	01 97       	sbiw	r24, 0x01	; 1
    1aa2:	f1 f7       	brne	.-4      	; 0x1aa0 <CLCD_voidInit+0x3c6>
    1aa4:	9a 83       	std	Y+2, r25	; 0x02
    1aa6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);

	iniIsFinich=1;
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	80 93 92 00 	sts	0x0092, r24
#else
#error "In correct cconfigrtion of LCD_MODE"
#endif
}
    1aae:	e8 96       	adiw	r28, 0x38	; 56
    1ab0:	0f b6       	in	r0, 0x3f	; 63
    1ab2:	f8 94       	cli
    1ab4:	de bf       	out	0x3e, r29	; 62
    1ab6:	0f be       	out	0x3f, r0	; 63
    1ab8:	cd bf       	out	0x3d, r28	; 61
    1aba:	cf 91       	pop	r28
    1abc:	df 91       	pop	r29
    1abe:	08 95       	ret

00001ac0 <CLCD_voidSendString>:
void CLCD_voidSendString(const char* Copy_pcString)//char ASCII Value Constant not allow the func to change the sent string
{
    1ac0:	df 93       	push	r29
    1ac2:	cf 93       	push	r28
    1ac4:	00 d0       	rcall	.+0      	; 0x1ac6 <CLCD_voidSendString+0x6>
    1ac6:	0f 92       	push	r0
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	9b 83       	std	Y+3, r25	; 0x03
    1ace:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8cnt=0;
    1ad0:	19 82       	std	Y+1, r1	; 0x01
    1ad2:	0e c0       	rjmp	.+28     	; 0x1af0 <CLCD_voidSendString+0x30>
	while(Copy_pcString[Local_u8cnt]!='\0')
	{
		CLCD_voidSendData(Copy_pcString[Local_u8cnt]);
    1ad4:	89 81       	ldd	r24, Y+1	; 0x01
    1ad6:	28 2f       	mov	r18, r24
    1ad8:	30 e0       	ldi	r19, 0x00	; 0
    1ada:	8a 81       	ldd	r24, Y+2	; 0x02
    1adc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ade:	fc 01       	movw	r30, r24
    1ae0:	e2 0f       	add	r30, r18
    1ae2:	f3 1f       	adc	r31, r19
    1ae4:	80 81       	ld	r24, Z
    1ae6:	0e 94 cd 09 	call	0x139a	; 0x139a <CLCD_voidSendData>
		Local_u8cnt++;
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
    1aec:	8f 5f       	subi	r24, 0xFF	; 255
    1aee:	89 83       	std	Y+1, r24	; 0x01
#endif
}
void CLCD_voidSendString(const char* Copy_pcString)//char ASCII Value Constant not allow the func to change the sent string
{
	u8 Local_u8cnt=0;
	while(Copy_pcString[Local_u8cnt]!='\0')
    1af0:	89 81       	ldd	r24, Y+1	; 0x01
    1af2:	28 2f       	mov	r18, r24
    1af4:	30 e0       	ldi	r19, 0x00	; 0
    1af6:	8a 81       	ldd	r24, Y+2	; 0x02
    1af8:	9b 81       	ldd	r25, Y+3	; 0x03
    1afa:	fc 01       	movw	r30, r24
    1afc:	e2 0f       	add	r30, r18
    1afe:	f3 1f       	adc	r31, r19
    1b00:	80 81       	ld	r24, Z
    1b02:	88 23       	and	r24, r24
    1b04:	39 f7       	brne	.-50     	; 0x1ad4 <CLCD_voidSendString+0x14>
	{
		CLCD_voidSendData(Copy_pcString[Local_u8cnt]);
		Local_u8cnt++;
	}
}
    1b06:	0f 90       	pop	r0
    1b08:	0f 90       	pop	r0
    1b0a:	0f 90       	pop	r0
    1b0c:	cf 91       	pop	r28
    1b0e:	df 91       	pop	r29
    1b10:	08 95       	ret

00001b12 <CLCD_voidGoToXY>:

void CLCD_voidGoToXY(u8 Copy_u8XPos,u8 Copy_u8YPos)
{
    1b12:	df 93       	push	r29
    1b14:	cf 93       	push	r28
    1b16:	00 d0       	rcall	.+0      	; 0x1b18 <CLCD_voidGoToXY+0x6>
    1b18:	0f 92       	push	r0
    1b1a:	cd b7       	in	r28, 0x3d	; 61
    1b1c:	de b7       	in	r29, 0x3e	; 62
    1b1e:	8a 83       	std	Y+2, r24	; 0x02
    1b20:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8Address;
	if(Copy_u8XPos==0)
    1b22:	8a 81       	ldd	r24, Y+2	; 0x02
    1b24:	88 23       	and	r24, r24
    1b26:	51 f4       	brne	.+20     	; 0x1b3c <CLCD_voidGoToXY+0x2a>
	{
		if (Copy_u8YPos > 15) {
    1b28:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2a:	80 31       	cpi	r24, 0x10	; 16
    1b2c:	20 f0       	brcs	.+8      	; 0x1b36 <CLCD_voidGoToXY+0x24>
			Local_u8Address = 0x40 + Copy_u8YPos;
    1b2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b30:	80 5c       	subi	r24, 0xC0	; 192
    1b32:	89 83       	std	Y+1, r24	; 0x01
    1b34:	09 c0       	rjmp	.+18     	; 0x1b48 <CLCD_voidGoToXY+0x36>
		} else {
			Local_u8Address = Copy_u8YPos;
    1b36:	8b 81       	ldd	r24, Y+3	; 0x03
    1b38:	89 83       	std	Y+1, r24	; 0x01
    1b3a:	06 c0       	rjmp	.+12     	; 0x1b48 <CLCD_voidGoToXY+0x36>
		}
	}
	else if(Copy_u8XPos==1)
    1b3c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b3e:	81 30       	cpi	r24, 0x01	; 1
    1b40:	19 f4       	brne	.+6      	; 0x1b48 <CLCD_voidGoToXY+0x36>
	{
		Local_u8Address=0x40+Copy_u8YPos;
    1b42:	8b 81       	ldd	r24, Y+3	; 0x03
    1b44:	80 5c       	subi	r24, 0xC0	; 192
    1b46:	89 83       	std	Y+1, r24	; 0x01
	}
	//put command from data sheet
	CLCD_voidSendCommand(Local_u8Address+128);
    1b48:	89 81       	ldd	r24, Y+1	; 0x01
    1b4a:	80 58       	subi	r24, 0x80	; 128
    1b4c:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>
}
    1b50:	0f 90       	pop	r0
    1b52:	0f 90       	pop	r0
    1b54:	0f 90       	pop	r0
    1b56:	cf 91       	pop	r28
    1b58:	df 91       	pop	r29
    1b5a:	08 95       	ret

00001b5c <CLCD_voidWriteSpecialCharacter>:

void CLCD_voidWriteSpecialCharacter(u8* Copy_pu8Pattern, u8 Copy_u8PatternNmber,u8 Copy_u8XPos,u8 Copy_u8Ypos)
{
    1b5c:	df 93       	push	r29
    1b5e:	cf 93       	push	r28
    1b60:	cd b7       	in	r28, 0x3d	; 61
    1b62:	de b7       	in	r29, 0x3e	; 62
    1b64:	27 97       	sbiw	r28, 0x07	; 7
    1b66:	0f b6       	in	r0, 0x3f	; 63
    1b68:	f8 94       	cli
    1b6a:	de bf       	out	0x3e, r29	; 62
    1b6c:	0f be       	out	0x3f, r0	; 63
    1b6e:	cd bf       	out	0x3d, r28	; 61
    1b70:	9c 83       	std	Y+4, r25	; 0x04
    1b72:	8b 83       	std	Y+3, r24	; 0x03
    1b74:	6d 83       	std	Y+5, r22	; 0x05
    1b76:	4e 83       	std	Y+6, r20	; 0x06
    1b78:	2f 83       	std	Y+7, r18	; 0x07
	u8 Local_u8CGRAMAddress=0;
    1b7a:	1a 82       	std	Y+2, r1	; 0x02
	u8 Local_u8iterator;
	/*Calculate the CGRAM address whose each block is 8 bytes */
	Local_u8CGRAMAddress= Copy_u8PatternNmber*8;
    1b7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b7e:	88 2f       	mov	r24, r24
    1b80:	90 e0       	ldi	r25, 0x00	; 0
    1b82:	88 0f       	add	r24, r24
    1b84:	99 1f       	adc	r25, r25
    1b86:	88 0f       	add	r24, r24
    1b88:	99 1f       	adc	r25, r25
    1b8a:	88 0f       	add	r24, r24
    1b8c:	99 1f       	adc	r25, r25
    1b8e:	8a 83       	std	Y+2, r24	; 0x02

	/*Send CGRAM address command to LCD, with setting bit 6 , clear bit 7 */
	CLCD_voidSendCommand(Local_u8CGRAMAddress+64);
    1b90:	8a 81       	ldd	r24, Y+2	; 0x02
    1b92:	80 5c       	subi	r24, 0xC0	; 192
    1b94:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <CLCD_voidSendCommand>

	/*Write the pattern into CGRAM */
	for(Local_u8iterator=0;Local_u8iterator<8;Local_u8iterator++)
    1b98:	19 82       	std	Y+1, r1	; 0x01
    1b9a:	0e c0       	rjmp	.+28     	; 0x1bb8 <CLCD_voidWriteSpecialCharacter+0x5c>
	{
		CLCD_voidSendData(Copy_pu8Pattern[Local_u8iterator]);
    1b9c:	89 81       	ldd	r24, Y+1	; 0x01
    1b9e:	28 2f       	mov	r18, r24
    1ba0:	30 e0       	ldi	r19, 0x00	; 0
    1ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ba4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ba6:	fc 01       	movw	r30, r24
    1ba8:	e2 0f       	add	r30, r18
    1baa:	f3 1f       	adc	r31, r19
    1bac:	80 81       	ld	r24, Z
    1bae:	0e 94 cd 09 	call	0x139a	; 0x139a <CLCD_voidSendData>

	/*Send CGRAM address command to LCD, with setting bit 6 , clear bit 7 */
	CLCD_voidSendCommand(Local_u8CGRAMAddress+64);

	/*Write the pattern into CGRAM */
	for(Local_u8iterator=0;Local_u8iterator<8;Local_u8iterator++)
    1bb2:	89 81       	ldd	r24, Y+1	; 0x01
    1bb4:	8f 5f       	subi	r24, 0xFF	; 255
    1bb6:	89 83       	std	Y+1, r24	; 0x01
    1bb8:	89 81       	ldd	r24, Y+1	; 0x01
    1bba:	88 30       	cpi	r24, 0x08	; 8
    1bbc:	78 f3       	brcs	.-34     	; 0x1b9c <CLCD_voidWriteSpecialCharacter+0x40>
	{
		CLCD_voidSendData(Copy_pu8Pattern[Local_u8iterator]);
	}
	/* Go back to DDRAM to display the pattern */
	CLCD_voidGoToXY(Copy_u8XPos,Copy_u8Ypos);
    1bbe:	8e 81       	ldd	r24, Y+6	; 0x06
    1bc0:	6f 81       	ldd	r22, Y+7	; 0x07
    1bc2:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <CLCD_voidGoToXY>

	/* Display the pattern written  in the CGRAM */
	CLCD_voidSendData(Copy_u8PatternNmber);
    1bc6:	8d 81       	ldd	r24, Y+5	; 0x05
    1bc8:	0e 94 cd 09 	call	0x139a	; 0x139a <CLCD_voidSendData>

}
    1bcc:	27 96       	adiw	r28, 0x07	; 7
    1bce:	0f b6       	in	r0, 0x3f	; 63
    1bd0:	f8 94       	cli
    1bd2:	de bf       	out	0x3e, r29	; 62
    1bd4:	0f be       	out	0x3f, r0	; 63
    1bd6:	cd bf       	out	0x3d, r28	; 61
    1bd8:	cf 91       	pop	r28
    1bda:	df 91       	pop	r29
    1bdc:	08 95       	ret

00001bde <CLCD_voidWriteNumber>:

void CLCD_voidWriteNumber(u32 Copy_u32Number)
{
    1bde:	df 93       	push	r29
    1be0:	cf 93       	push	r28
    1be2:	00 d0       	rcall	.+0      	; 0x1be4 <CLCD_voidWriteNumber+0x6>
    1be4:	00 d0       	rcall	.+0      	; 0x1be6 <CLCD_voidWriteNumber+0x8>
    1be6:	00 d0       	rcall	.+0      	; 0x1be8 <CLCD_voidWriteNumber+0xa>
    1be8:	cd b7       	in	r28, 0x3d	; 61
    1bea:	de b7       	in	r29, 0x3e	; 62
    1bec:	6b 83       	std	Y+3, r22	; 0x03
    1bee:	7c 83       	std	Y+4, r23	; 0x04
    1bf0:	8d 83       	std	Y+5, r24	; 0x05
    1bf2:	9e 83       	std	Y+6, r25	; 0x06

	u8 Max_Digits = Num_length(Copy_u32Number);
    1bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bf8:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <Num_length>
    1bfc:	8a 83       	std	Y+2, r24	; 0x02
	for (s8 i = Max_Digits; i > 0; i--) {
    1bfe:	8a 81       	ldd	r24, Y+2	; 0x02
    1c00:	89 83       	std	Y+1, r24	; 0x01
    1c02:	2c c0       	rjmp	.+88     	; 0x1c5c <CLCD_voidWriteNumber+0x7e>
		CLCD_voidSendData((Copy_u32Number / Multi_N_10(i - 1)) + '0');
    1c04:	89 81       	ldd	r24, Y+1	; 0x01
    1c06:	81 50       	subi	r24, 0x01	; 1
    1c08:	0e 94 65 0e 	call	0x1cca	; 0x1cca <Multi_N_10>
    1c0c:	9c 01       	movw	r18, r24
    1c0e:	40 e0       	ldi	r20, 0x00	; 0
    1c10:	50 e0       	ldi	r21, 0x00	; 0
    1c12:	8b 81       	ldd	r24, Y+3	; 0x03
    1c14:	9c 81       	ldd	r25, Y+4	; 0x04
    1c16:	ad 81       	ldd	r26, Y+5	; 0x05
    1c18:	be 81       	ldd	r27, Y+6	; 0x06
    1c1a:	bc 01       	movw	r22, r24
    1c1c:	cd 01       	movw	r24, r26
    1c1e:	0e 94 22 28 	call	0x5044	; 0x5044 <__udivmodsi4>
    1c22:	da 01       	movw	r26, r20
    1c24:	c9 01       	movw	r24, r18
    1c26:	80 5d       	subi	r24, 0xD0	; 208
    1c28:	0e 94 cd 09 	call	0x139a	; 0x139a <CLCD_voidSendData>
		Copy_u32Number = (Copy_u32Number % Multi_N_10(i - 1));
    1c2c:	89 81       	ldd	r24, Y+1	; 0x01
    1c2e:	81 50       	subi	r24, 0x01	; 1
    1c30:	0e 94 65 0e 	call	0x1cca	; 0x1cca <Multi_N_10>
    1c34:	9c 01       	movw	r18, r24
    1c36:	40 e0       	ldi	r20, 0x00	; 0
    1c38:	50 e0       	ldi	r21, 0x00	; 0
    1c3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c3c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c3e:	ad 81       	ldd	r26, Y+5	; 0x05
    1c40:	be 81       	ldd	r27, Y+6	; 0x06
    1c42:	bc 01       	movw	r22, r24
    1c44:	cd 01       	movw	r24, r26
    1c46:	0e 94 22 28 	call	0x5044	; 0x5044 <__udivmodsi4>
    1c4a:	dc 01       	movw	r26, r24
    1c4c:	cb 01       	movw	r24, r22
    1c4e:	8b 83       	std	Y+3, r24	; 0x03
    1c50:	9c 83       	std	Y+4, r25	; 0x04
    1c52:	ad 83       	std	Y+5, r26	; 0x05
    1c54:	be 83       	std	Y+6, r27	; 0x06

void CLCD_voidWriteNumber(u32 Copy_u32Number)
{

	u8 Max_Digits = Num_length(Copy_u32Number);
	for (s8 i = Max_Digits; i > 0; i--) {
    1c56:	89 81       	ldd	r24, Y+1	; 0x01
    1c58:	81 50       	subi	r24, 0x01	; 1
    1c5a:	89 83       	std	Y+1, r24	; 0x01
    1c5c:	89 81       	ldd	r24, Y+1	; 0x01
    1c5e:	18 16       	cp	r1, r24
    1c60:	8c f2       	brlt	.-94     	; 0x1c04 <CLCD_voidWriteNumber+0x26>
		CLCD_voidSendData((Copy_u32Number / Multi_N_10(i - 1)) + '0');
		Copy_u32Number = (Copy_u32Number % Multi_N_10(i - 1));
	}
}
    1c62:	26 96       	adiw	r28, 0x06	; 6
    1c64:	0f b6       	in	r0, 0x3f	; 63
    1c66:	f8 94       	cli
    1c68:	de bf       	out	0x3e, r29	; 62
    1c6a:	0f be       	out	0x3f, r0	; 63
    1c6c:	cd bf       	out	0x3d, r28	; 61
    1c6e:	cf 91       	pop	r28
    1c70:	df 91       	pop	r29
    1c72:	08 95       	ret

00001c74 <Num_length>:


static u8 Num_length(u16 num) {
    1c74:	df 93       	push	r29
    1c76:	cf 93       	push	r28
    1c78:	00 d0       	rcall	.+0      	; 0x1c7a <Num_length+0x6>
    1c7a:	00 d0       	rcall	.+0      	; 0x1c7c <Num_length+0x8>
    1c7c:	cd b7       	in	r28, 0x3d	; 61
    1c7e:	de b7       	in	r29, 0x3e	; 62
    1c80:	9b 83       	std	Y+3, r25	; 0x03
    1c82:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8Cnt = 0;
    1c84:	19 82       	std	Y+1, r1	; 0x01
	if(num == 0)
    1c86:	8a 81       	ldd	r24, Y+2	; 0x02
    1c88:	9b 81       	ldd	r25, Y+3	; 0x03
    1c8a:	00 97       	sbiw	r24, 0x00	; 0
    1c8c:	81 f4       	brne	.+32     	; 0x1cae <Num_length+0x3a>
		return 1;
    1c8e:	81 e0       	ldi	r24, 0x01	; 1
    1c90:	8c 83       	std	Y+4, r24	; 0x04
    1c92:	13 c0       	rjmp	.+38     	; 0x1cba <Num_length+0x46>
	while (num != 0) {
		num /= 10;
    1c94:	8a 81       	ldd	r24, Y+2	; 0x02
    1c96:	9b 81       	ldd	r25, Y+3	; 0x03
    1c98:	2a e0       	ldi	r18, 0x0A	; 10
    1c9a:	30 e0       	ldi	r19, 0x00	; 0
    1c9c:	b9 01       	movw	r22, r18
    1c9e:	0e 94 0e 28 	call	0x501c	; 0x501c <__udivmodhi4>
    1ca2:	cb 01       	movw	r24, r22
    1ca4:	9b 83       	std	Y+3, r25	; 0x03
    1ca6:	8a 83       	std	Y+2, r24	; 0x02
		Local_u8Cnt++;
    1ca8:	89 81       	ldd	r24, Y+1	; 0x01
    1caa:	8f 5f       	subi	r24, 0xFF	; 255
    1cac:	89 83       	std	Y+1, r24	; 0x01

static u8 Num_length(u16 num) {
	u8 Local_u8Cnt = 0;
	if(num == 0)
		return 1;
	while (num != 0) {
    1cae:	8a 81       	ldd	r24, Y+2	; 0x02
    1cb0:	9b 81       	ldd	r25, Y+3	; 0x03
    1cb2:	00 97       	sbiw	r24, 0x00	; 0
    1cb4:	79 f7       	brne	.-34     	; 0x1c94 <Num_length+0x20>
		num /= 10;
		Local_u8Cnt++;
	}
	return Local_u8Cnt;
    1cb6:	89 81       	ldd	r24, Y+1	; 0x01
    1cb8:	8c 83       	std	Y+4, r24	; 0x04
    1cba:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1cbc:	0f 90       	pop	r0
    1cbe:	0f 90       	pop	r0
    1cc0:	0f 90       	pop	r0
    1cc2:	0f 90       	pop	r0
    1cc4:	cf 91       	pop	r28
    1cc6:	df 91       	pop	r29
    1cc8:	08 95       	ret

00001cca <Multi_N_10>:
static u16 Multi_N_10(u8 N) {
    1cca:	df 93       	push	r29
    1ccc:	cf 93       	push	r28
    1cce:	00 d0       	rcall	.+0      	; 0x1cd0 <Multi_N_10+0x6>
    1cd0:	00 d0       	rcall	.+0      	; 0x1cd2 <Multi_N_10+0x8>
    1cd2:	cd b7       	in	r28, 0x3d	; 61
    1cd4:	de b7       	in	r29, 0x3e	; 62
    1cd6:	8c 83       	std	Y+4, r24	; 0x04
	u8 Local_u8Cnt;
	u16 p = 1;
    1cd8:	81 e0       	ldi	r24, 0x01	; 1
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	9a 83       	std	Y+2, r25	; 0x02
    1cde:	89 83       	std	Y+1, r24	; 0x01
	for (Local_u8Cnt = 0; Local_u8Cnt < N; Local_u8Cnt++)
    1ce0:	1b 82       	std	Y+3, r1	; 0x03
    1ce2:	11 c0       	rjmp	.+34     	; 0x1d06 <Multi_N_10+0x3c>
		p *= 10;
    1ce4:	89 81       	ldd	r24, Y+1	; 0x01
    1ce6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ce8:	9c 01       	movw	r18, r24
    1cea:	22 0f       	add	r18, r18
    1cec:	33 1f       	adc	r19, r19
    1cee:	c9 01       	movw	r24, r18
    1cf0:	88 0f       	add	r24, r24
    1cf2:	99 1f       	adc	r25, r25
    1cf4:	88 0f       	add	r24, r24
    1cf6:	99 1f       	adc	r25, r25
    1cf8:	82 0f       	add	r24, r18
    1cfa:	93 1f       	adc	r25, r19
    1cfc:	9a 83       	std	Y+2, r25	; 0x02
    1cfe:	89 83       	std	Y+1, r24	; 0x01
	return Local_u8Cnt;
}
static u16 Multi_N_10(u8 N) {
	u8 Local_u8Cnt;
	u16 p = 1;
	for (Local_u8Cnt = 0; Local_u8Cnt < N; Local_u8Cnt++)
    1d00:	8b 81       	ldd	r24, Y+3	; 0x03
    1d02:	8f 5f       	subi	r24, 0xFF	; 255
    1d04:	8b 83       	std	Y+3, r24	; 0x03
    1d06:	9b 81       	ldd	r25, Y+3	; 0x03
    1d08:	8c 81       	ldd	r24, Y+4	; 0x04
    1d0a:	98 17       	cp	r25, r24
    1d0c:	58 f3       	brcs	.-42     	; 0x1ce4 <Multi_N_10+0x1a>
		p *= 10;
	return p;
    1d0e:	89 81       	ldd	r24, Y+1	; 0x01
    1d10:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1d12:	0f 90       	pop	r0
    1d14:	0f 90       	pop	r0
    1d16:	0f 90       	pop	r0
    1d18:	0f 90       	pop	r0
    1d1a:	cf 91       	pop	r28
    1d1c:	df 91       	pop	r29
    1d1e:	08 95       	ret

00001d20 <DIO_u8SetPinValue>:
#include "../MCAL/DIO_config.h"
#include "../MCAL/DIO_interface.h"
#include "../MCAL/DIO_register.h"

u8 DIO_u8SetPinValue(u8 Copy_u8Port,u8 Copy_u8Pin,u8 Copy_u8Value)
{
    1d20:	df 93       	push	r29
    1d22:	cf 93       	push	r28
    1d24:	cd b7       	in	r28, 0x3d	; 61
    1d26:	de b7       	in	r29, 0x3e	; 62
    1d28:	28 97       	sbiw	r28, 0x08	; 8
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	f8 94       	cli
    1d2e:	de bf       	out	0x3e, r29	; 62
    1d30:	0f be       	out	0x3f, r0	; 63
    1d32:	cd bf       	out	0x3d, r28	; 61
    1d34:	8a 83       	std	Y+2, r24	; 0x02
    1d36:	6b 83       	std	Y+3, r22	; 0x03
    1d38:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
    1d3a:	19 82       	std	Y+1, r1	; 0x01
	if(DIO_PIN_HIGH==Copy_u8Value)
    1d3c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d3e:	81 30       	cpi	r24, 0x01	; 1
    1d40:	09 f0       	breq	.+2      	; 0x1d44 <DIO_u8SetPinValue+0x24>
    1d42:	79 c0       	rjmp	.+242    	; 0x1e36 <DIO_u8SetPinValue+0x116>
	{
		if((0<=Copy_u8Pin)&&(Copy_u8Pin<=7))
    1d44:	8b 81       	ldd	r24, Y+3	; 0x03
    1d46:	88 30       	cpi	r24, 0x08	; 8
    1d48:	08 f0       	brcs	.+2      	; 0x1d4c <DIO_u8SetPinValue+0x2c>
    1d4a:	72 c0       	rjmp	.+228    	; 0x1e30 <DIO_u8SetPinValue+0x110>
		{
			switch(Copy_u8Port)
    1d4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d4e:	28 2f       	mov	r18, r24
    1d50:	30 e0       	ldi	r19, 0x00	; 0
    1d52:	38 87       	std	Y+8, r19	; 0x08
    1d54:	2f 83       	std	Y+7, r18	; 0x07
    1d56:	8f 81       	ldd	r24, Y+7	; 0x07
    1d58:	98 85       	ldd	r25, Y+8	; 0x08
    1d5a:	81 30       	cpi	r24, 0x01	; 1
    1d5c:	91 05       	cpc	r25, r1
    1d5e:	49 f1       	breq	.+82     	; 0x1db2 <DIO_u8SetPinValue+0x92>
    1d60:	2f 81       	ldd	r18, Y+7	; 0x07
    1d62:	38 85       	ldd	r19, Y+8	; 0x08
    1d64:	22 30       	cpi	r18, 0x02	; 2
    1d66:	31 05       	cpc	r19, r1
    1d68:	2c f4       	brge	.+10     	; 0x1d74 <DIO_u8SetPinValue+0x54>
    1d6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1d6c:	98 85       	ldd	r25, Y+8	; 0x08
    1d6e:	00 97       	sbiw	r24, 0x00	; 0
    1d70:	61 f0       	breq	.+24     	; 0x1d8a <DIO_u8SetPinValue+0x6a>
    1d72:	5b c0       	rjmp	.+182    	; 0x1e2a <DIO_u8SetPinValue+0x10a>
    1d74:	2f 81       	ldd	r18, Y+7	; 0x07
    1d76:	38 85       	ldd	r19, Y+8	; 0x08
    1d78:	22 30       	cpi	r18, 0x02	; 2
    1d7a:	31 05       	cpc	r19, r1
    1d7c:	71 f1       	breq	.+92     	; 0x1dda <DIO_u8SetPinValue+0xba>
    1d7e:	8f 81       	ldd	r24, Y+7	; 0x07
    1d80:	98 85       	ldd	r25, Y+8	; 0x08
    1d82:	83 30       	cpi	r24, 0x03	; 3
    1d84:	91 05       	cpc	r25, r1
    1d86:	e9 f1       	breq	.+122    	; 0x1e02 <DIO_u8SetPinValue+0xe2>
    1d88:	50 c0       	rjmp	.+160    	; 0x1e2a <DIO_u8SetPinValue+0x10a>
			{
				case DIO_PORTA:SET_BIT(PORTA,Copy_u8Pin);break;
    1d8a:	ab e3       	ldi	r26, 0x3B	; 59
    1d8c:	b0 e0       	ldi	r27, 0x00	; 0
    1d8e:	eb e3       	ldi	r30, 0x3B	; 59
    1d90:	f0 e0       	ldi	r31, 0x00	; 0
    1d92:	80 81       	ld	r24, Z
    1d94:	48 2f       	mov	r20, r24
    1d96:	8b 81       	ldd	r24, Y+3	; 0x03
    1d98:	28 2f       	mov	r18, r24
    1d9a:	30 e0       	ldi	r19, 0x00	; 0
    1d9c:	81 e0       	ldi	r24, 0x01	; 1
    1d9e:	90 e0       	ldi	r25, 0x00	; 0
    1da0:	02 2e       	mov	r0, r18
    1da2:	02 c0       	rjmp	.+4      	; 0x1da8 <DIO_u8SetPinValue+0x88>
    1da4:	88 0f       	add	r24, r24
    1da6:	99 1f       	adc	r25, r25
    1da8:	0a 94       	dec	r0
    1daa:	e2 f7       	brpl	.-8      	; 0x1da4 <DIO_u8SetPinValue+0x84>
    1dac:	84 2b       	or	r24, r20
    1dae:	8c 93       	st	X, r24
    1db0:	c6 c0       	rjmp	.+396    	; 0x1f3e <DIO_u8SetPinValue+0x21e>
				case DIO_PORTB:SET_BIT(PORTB,Copy_u8Pin);break;
    1db2:	a8 e3       	ldi	r26, 0x38	; 56
    1db4:	b0 e0       	ldi	r27, 0x00	; 0
    1db6:	e8 e3       	ldi	r30, 0x38	; 56
    1db8:	f0 e0       	ldi	r31, 0x00	; 0
    1dba:	80 81       	ld	r24, Z
    1dbc:	48 2f       	mov	r20, r24
    1dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc0:	28 2f       	mov	r18, r24
    1dc2:	30 e0       	ldi	r19, 0x00	; 0
    1dc4:	81 e0       	ldi	r24, 0x01	; 1
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	02 2e       	mov	r0, r18
    1dca:	02 c0       	rjmp	.+4      	; 0x1dd0 <DIO_u8SetPinValue+0xb0>
    1dcc:	88 0f       	add	r24, r24
    1dce:	99 1f       	adc	r25, r25
    1dd0:	0a 94       	dec	r0
    1dd2:	e2 f7       	brpl	.-8      	; 0x1dcc <DIO_u8SetPinValue+0xac>
    1dd4:	84 2b       	or	r24, r20
    1dd6:	8c 93       	st	X, r24
    1dd8:	b2 c0       	rjmp	.+356    	; 0x1f3e <DIO_u8SetPinValue+0x21e>
				case DIO_PORTC:SET_BIT(PORTC,Copy_u8Pin);break;
    1dda:	a5 e3       	ldi	r26, 0x35	; 53
    1ddc:	b0 e0       	ldi	r27, 0x00	; 0
    1dde:	e5 e3       	ldi	r30, 0x35	; 53
    1de0:	f0 e0       	ldi	r31, 0x00	; 0
    1de2:	80 81       	ld	r24, Z
    1de4:	48 2f       	mov	r20, r24
    1de6:	8b 81       	ldd	r24, Y+3	; 0x03
    1de8:	28 2f       	mov	r18, r24
    1dea:	30 e0       	ldi	r19, 0x00	; 0
    1dec:	81 e0       	ldi	r24, 0x01	; 1
    1dee:	90 e0       	ldi	r25, 0x00	; 0
    1df0:	02 2e       	mov	r0, r18
    1df2:	02 c0       	rjmp	.+4      	; 0x1df8 <DIO_u8SetPinValue+0xd8>
    1df4:	88 0f       	add	r24, r24
    1df6:	99 1f       	adc	r25, r25
    1df8:	0a 94       	dec	r0
    1dfa:	e2 f7       	brpl	.-8      	; 0x1df4 <DIO_u8SetPinValue+0xd4>
    1dfc:	84 2b       	or	r24, r20
    1dfe:	8c 93       	st	X, r24
    1e00:	9e c0       	rjmp	.+316    	; 0x1f3e <DIO_u8SetPinValue+0x21e>
				case DIO_PORTD:SET_BIT(PORTD,Copy_u8Pin);break;
    1e02:	a2 e3       	ldi	r26, 0x32	; 50
    1e04:	b0 e0       	ldi	r27, 0x00	; 0
    1e06:	e2 e3       	ldi	r30, 0x32	; 50
    1e08:	f0 e0       	ldi	r31, 0x00	; 0
    1e0a:	80 81       	ld	r24, Z
    1e0c:	48 2f       	mov	r20, r24
    1e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e10:	28 2f       	mov	r18, r24
    1e12:	30 e0       	ldi	r19, 0x00	; 0
    1e14:	81 e0       	ldi	r24, 0x01	; 1
    1e16:	90 e0       	ldi	r25, 0x00	; 0
    1e18:	02 2e       	mov	r0, r18
    1e1a:	02 c0       	rjmp	.+4      	; 0x1e20 <DIO_u8SetPinValue+0x100>
    1e1c:	88 0f       	add	r24, r24
    1e1e:	99 1f       	adc	r25, r25
    1e20:	0a 94       	dec	r0
    1e22:	e2 f7       	brpl	.-8      	; 0x1e1c <DIO_u8SetPinValue+0xfc>
    1e24:	84 2b       	or	r24, r20
    1e26:	8c 93       	st	X, r24
    1e28:	8a c0       	rjmp	.+276    	; 0x1f3e <DIO_u8SetPinValue+0x21e>
				default: Local_u8ErrorState=1;				
    1e2a:	81 e0       	ldi	r24, 0x01	; 1
    1e2c:	89 83       	std	Y+1, r24	; 0x01
    1e2e:	87 c0       	rjmp	.+270    	; 0x1f3e <DIO_u8SetPinValue+0x21e>
			}
		}
		else
			Local_u8ErrorState=1;
    1e30:	81 e0       	ldi	r24, 0x01	; 1
    1e32:	89 83       	std	Y+1, r24	; 0x01
    1e34:	84 c0       	rjmp	.+264    	; 0x1f3e <DIO_u8SetPinValue+0x21e>
	}
	else if(DIO_PIN_LOW==Copy_u8Value)
    1e36:	8c 81       	ldd	r24, Y+4	; 0x04
    1e38:	88 23       	and	r24, r24
    1e3a:	09 f0       	breq	.+2      	; 0x1e3e <DIO_u8SetPinValue+0x11e>
    1e3c:	7e c0       	rjmp	.+252    	; 0x1f3a <DIO_u8SetPinValue+0x21a>
	{
		if((0<=Copy_u8Pin)&&(Copy_u8Pin<=7))
    1e3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e40:	88 30       	cpi	r24, 0x08	; 8
    1e42:	08 f0       	brcs	.+2      	; 0x1e46 <DIO_u8SetPinValue+0x126>
    1e44:	77 c0       	rjmp	.+238    	; 0x1f34 <DIO_u8SetPinValue+0x214>
		{
			switch(Copy_u8Port)
    1e46:	8a 81       	ldd	r24, Y+2	; 0x02
    1e48:	28 2f       	mov	r18, r24
    1e4a:	30 e0       	ldi	r19, 0x00	; 0
    1e4c:	3e 83       	std	Y+6, r19	; 0x06
    1e4e:	2d 83       	std	Y+5, r18	; 0x05
    1e50:	8d 81       	ldd	r24, Y+5	; 0x05
    1e52:	9e 81       	ldd	r25, Y+6	; 0x06
    1e54:	81 30       	cpi	r24, 0x01	; 1
    1e56:	91 05       	cpc	r25, r1
    1e58:	59 f1       	breq	.+86     	; 0x1eb0 <DIO_u8SetPinValue+0x190>
    1e5a:	2d 81       	ldd	r18, Y+5	; 0x05
    1e5c:	3e 81       	ldd	r19, Y+6	; 0x06
    1e5e:	22 30       	cpi	r18, 0x02	; 2
    1e60:	31 05       	cpc	r19, r1
    1e62:	2c f4       	brge	.+10     	; 0x1e6e <DIO_u8SetPinValue+0x14e>
    1e64:	8d 81       	ldd	r24, Y+5	; 0x05
    1e66:	9e 81       	ldd	r25, Y+6	; 0x06
    1e68:	00 97       	sbiw	r24, 0x00	; 0
    1e6a:	69 f0       	breq	.+26     	; 0x1e86 <DIO_u8SetPinValue+0x166>
    1e6c:	60 c0       	rjmp	.+192    	; 0x1f2e <DIO_u8SetPinValue+0x20e>
    1e6e:	2d 81       	ldd	r18, Y+5	; 0x05
    1e70:	3e 81       	ldd	r19, Y+6	; 0x06
    1e72:	22 30       	cpi	r18, 0x02	; 2
    1e74:	31 05       	cpc	r19, r1
    1e76:	89 f1       	breq	.+98     	; 0x1eda <DIO_u8SetPinValue+0x1ba>
    1e78:	8d 81       	ldd	r24, Y+5	; 0x05
    1e7a:	9e 81       	ldd	r25, Y+6	; 0x06
    1e7c:	83 30       	cpi	r24, 0x03	; 3
    1e7e:	91 05       	cpc	r25, r1
    1e80:	09 f4       	brne	.+2      	; 0x1e84 <DIO_u8SetPinValue+0x164>
    1e82:	40 c0       	rjmp	.+128    	; 0x1f04 <DIO_u8SetPinValue+0x1e4>
    1e84:	54 c0       	rjmp	.+168    	; 0x1f2e <DIO_u8SetPinValue+0x20e>
			{
				case DIO_PORTA:CLR_BIT(PORTA,Copy_u8Pin);break;
    1e86:	ab e3       	ldi	r26, 0x3B	; 59
    1e88:	b0 e0       	ldi	r27, 0x00	; 0
    1e8a:	eb e3       	ldi	r30, 0x3B	; 59
    1e8c:	f0 e0       	ldi	r31, 0x00	; 0
    1e8e:	80 81       	ld	r24, Z
    1e90:	48 2f       	mov	r20, r24
    1e92:	8b 81       	ldd	r24, Y+3	; 0x03
    1e94:	28 2f       	mov	r18, r24
    1e96:	30 e0       	ldi	r19, 0x00	; 0
    1e98:	81 e0       	ldi	r24, 0x01	; 1
    1e9a:	90 e0       	ldi	r25, 0x00	; 0
    1e9c:	02 2e       	mov	r0, r18
    1e9e:	02 c0       	rjmp	.+4      	; 0x1ea4 <DIO_u8SetPinValue+0x184>
    1ea0:	88 0f       	add	r24, r24
    1ea2:	99 1f       	adc	r25, r25
    1ea4:	0a 94       	dec	r0
    1ea6:	e2 f7       	brpl	.-8      	; 0x1ea0 <DIO_u8SetPinValue+0x180>
    1ea8:	80 95       	com	r24
    1eaa:	84 23       	and	r24, r20
    1eac:	8c 93       	st	X, r24
    1eae:	47 c0       	rjmp	.+142    	; 0x1f3e <DIO_u8SetPinValue+0x21e>
				case DIO_PORTB:CLR_BIT(PORTB,Copy_u8Pin);break;
    1eb0:	a8 e3       	ldi	r26, 0x38	; 56
    1eb2:	b0 e0       	ldi	r27, 0x00	; 0
    1eb4:	e8 e3       	ldi	r30, 0x38	; 56
    1eb6:	f0 e0       	ldi	r31, 0x00	; 0
    1eb8:	80 81       	ld	r24, Z
    1eba:	48 2f       	mov	r20, r24
    1ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ebe:	28 2f       	mov	r18, r24
    1ec0:	30 e0       	ldi	r19, 0x00	; 0
    1ec2:	81 e0       	ldi	r24, 0x01	; 1
    1ec4:	90 e0       	ldi	r25, 0x00	; 0
    1ec6:	02 2e       	mov	r0, r18
    1ec8:	02 c0       	rjmp	.+4      	; 0x1ece <DIO_u8SetPinValue+0x1ae>
    1eca:	88 0f       	add	r24, r24
    1ecc:	99 1f       	adc	r25, r25
    1ece:	0a 94       	dec	r0
    1ed0:	e2 f7       	brpl	.-8      	; 0x1eca <DIO_u8SetPinValue+0x1aa>
    1ed2:	80 95       	com	r24
    1ed4:	84 23       	and	r24, r20
    1ed6:	8c 93       	st	X, r24
    1ed8:	32 c0       	rjmp	.+100    	; 0x1f3e <DIO_u8SetPinValue+0x21e>
				case DIO_PORTC:CLR_BIT(PORTC,Copy_u8Pin);break;
    1eda:	a5 e3       	ldi	r26, 0x35	; 53
    1edc:	b0 e0       	ldi	r27, 0x00	; 0
    1ede:	e5 e3       	ldi	r30, 0x35	; 53
    1ee0:	f0 e0       	ldi	r31, 0x00	; 0
    1ee2:	80 81       	ld	r24, Z
    1ee4:	48 2f       	mov	r20, r24
    1ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee8:	28 2f       	mov	r18, r24
    1eea:	30 e0       	ldi	r19, 0x00	; 0
    1eec:	81 e0       	ldi	r24, 0x01	; 1
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	02 2e       	mov	r0, r18
    1ef2:	02 c0       	rjmp	.+4      	; 0x1ef8 <DIO_u8SetPinValue+0x1d8>
    1ef4:	88 0f       	add	r24, r24
    1ef6:	99 1f       	adc	r25, r25
    1ef8:	0a 94       	dec	r0
    1efa:	e2 f7       	brpl	.-8      	; 0x1ef4 <DIO_u8SetPinValue+0x1d4>
    1efc:	80 95       	com	r24
    1efe:	84 23       	and	r24, r20
    1f00:	8c 93       	st	X, r24
    1f02:	1d c0       	rjmp	.+58     	; 0x1f3e <DIO_u8SetPinValue+0x21e>
				case DIO_PORTD:CLR_BIT(PORTD,Copy_u8Pin);break;
    1f04:	a2 e3       	ldi	r26, 0x32	; 50
    1f06:	b0 e0       	ldi	r27, 0x00	; 0
    1f08:	e2 e3       	ldi	r30, 0x32	; 50
    1f0a:	f0 e0       	ldi	r31, 0x00	; 0
    1f0c:	80 81       	ld	r24, Z
    1f0e:	48 2f       	mov	r20, r24
    1f10:	8b 81       	ldd	r24, Y+3	; 0x03
    1f12:	28 2f       	mov	r18, r24
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	81 e0       	ldi	r24, 0x01	; 1
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	02 2e       	mov	r0, r18
    1f1c:	02 c0       	rjmp	.+4      	; 0x1f22 <DIO_u8SetPinValue+0x202>
    1f1e:	88 0f       	add	r24, r24
    1f20:	99 1f       	adc	r25, r25
    1f22:	0a 94       	dec	r0
    1f24:	e2 f7       	brpl	.-8      	; 0x1f1e <DIO_u8SetPinValue+0x1fe>
    1f26:	80 95       	com	r24
    1f28:	84 23       	and	r24, r20
    1f2a:	8c 93       	st	X, r24
    1f2c:	08 c0       	rjmp	.+16     	; 0x1f3e <DIO_u8SetPinValue+0x21e>
				default: Local_u8ErrorState=1;	
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	89 83       	std	Y+1, r24	; 0x01
    1f32:	05 c0       	rjmp	.+10     	; 0x1f3e <DIO_u8SetPinValue+0x21e>
			}
		}
		else
			Local_u8ErrorState=1;	
    1f34:	81 e0       	ldi	r24, 0x01	; 1
    1f36:	89 83       	std	Y+1, r24	; 0x01
    1f38:	02 c0       	rjmp	.+4      	; 0x1f3e <DIO_u8SetPinValue+0x21e>
	}
	else
		Local_u8ErrorState=1;	
    1f3a:	81 e0       	ldi	r24, 0x01	; 1
    1f3c:	89 83       	std	Y+1, r24	; 0x01
	return Local_u8ErrorState;
    1f3e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f40:	28 96       	adiw	r28, 0x08	; 8
    1f42:	0f b6       	in	r0, 0x3f	; 63
    1f44:	f8 94       	cli
    1f46:	de bf       	out	0x3e, r29	; 62
    1f48:	0f be       	out	0x3f, r0	; 63
    1f4a:	cd bf       	out	0x3d, r28	; 61
    1f4c:	cf 91       	pop	r28
    1f4e:	df 91       	pop	r29
    1f50:	08 95       	ret

00001f52 <DIO_u8SetPortValue>:
u8 DIO_u8SetPortValue(u8 Copy_u8Port,u8 Copy_u8Value)
{
    1f52:	df 93       	push	r29
    1f54:	cf 93       	push	r28
    1f56:	00 d0       	rcall	.+0      	; 0x1f58 <DIO_u8SetPortValue+0x6>
    1f58:	00 d0       	rcall	.+0      	; 0x1f5a <DIO_u8SetPortValue+0x8>
    1f5a:	0f 92       	push	r0
    1f5c:	cd b7       	in	r28, 0x3d	; 61
    1f5e:	de b7       	in	r29, 0x3e	; 62
    1f60:	8a 83       	std	Y+2, r24	; 0x02
    1f62:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    1f64:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8Port<=7)
    1f66:	8a 81       	ldd	r24, Y+2	; 0x02
    1f68:	88 30       	cpi	r24, 0x08	; 8
    1f6a:	b0 f5       	brcc	.+108    	; 0x1fd8 <DIO_u8SetPortValue+0x86>
	{
		switch(Copy_u8Port)
    1f6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f6e:	28 2f       	mov	r18, r24
    1f70:	30 e0       	ldi	r19, 0x00	; 0
    1f72:	3d 83       	std	Y+5, r19	; 0x05
    1f74:	2c 83       	std	Y+4, r18	; 0x04
    1f76:	8c 81       	ldd	r24, Y+4	; 0x04
    1f78:	9d 81       	ldd	r25, Y+5	; 0x05
    1f7a:	81 30       	cpi	r24, 0x01	; 1
    1f7c:	91 05       	cpc	r25, r1
    1f7e:	d1 f0       	breq	.+52     	; 0x1fb4 <DIO_u8SetPortValue+0x62>
    1f80:	2c 81       	ldd	r18, Y+4	; 0x04
    1f82:	3d 81       	ldd	r19, Y+5	; 0x05
    1f84:	22 30       	cpi	r18, 0x02	; 2
    1f86:	31 05       	cpc	r19, r1
    1f88:	2c f4       	brge	.+10     	; 0x1f94 <DIO_u8SetPortValue+0x42>
    1f8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1f8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1f8e:	00 97       	sbiw	r24, 0x00	; 0
    1f90:	61 f0       	breq	.+24     	; 0x1faa <DIO_u8SetPortValue+0x58>
    1f92:	1f c0       	rjmp	.+62     	; 0x1fd2 <DIO_u8SetPortValue+0x80>
    1f94:	2c 81       	ldd	r18, Y+4	; 0x04
    1f96:	3d 81       	ldd	r19, Y+5	; 0x05
    1f98:	22 30       	cpi	r18, 0x02	; 2
    1f9a:	31 05       	cpc	r19, r1
    1f9c:	81 f0       	breq	.+32     	; 0x1fbe <DIO_u8SetPortValue+0x6c>
    1f9e:	8c 81       	ldd	r24, Y+4	; 0x04
    1fa0:	9d 81       	ldd	r25, Y+5	; 0x05
    1fa2:	83 30       	cpi	r24, 0x03	; 3
    1fa4:	91 05       	cpc	r25, r1
    1fa6:	81 f0       	breq	.+32     	; 0x1fc8 <DIO_u8SetPortValue+0x76>
    1fa8:	14 c0       	rjmp	.+40     	; 0x1fd2 <DIO_u8SetPortValue+0x80>
		{
			case DIO_PORTA:PORTA=Copy_u8Value;break;
    1faa:	eb e3       	ldi	r30, 0x3B	; 59
    1fac:	f0 e0       	ldi	r31, 0x00	; 0
    1fae:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb0:	80 83       	st	Z, r24
    1fb2:	14 c0       	rjmp	.+40     	; 0x1fdc <DIO_u8SetPortValue+0x8a>
			case DIO_PORTB:PORTB=Copy_u8Value;break;
    1fb4:	e8 e3       	ldi	r30, 0x38	; 56
    1fb6:	f0 e0       	ldi	r31, 0x00	; 0
    1fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    1fba:	80 83       	st	Z, r24
    1fbc:	0f c0       	rjmp	.+30     	; 0x1fdc <DIO_u8SetPortValue+0x8a>
			case DIO_PORTC:PORTC=Copy_u8Value;break;
    1fbe:	e5 e3       	ldi	r30, 0x35	; 53
    1fc0:	f0 e0       	ldi	r31, 0x00	; 0
    1fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fc4:	80 83       	st	Z, r24
    1fc6:	0a c0       	rjmp	.+20     	; 0x1fdc <DIO_u8SetPortValue+0x8a>
			case DIO_PORTD:PORTD=Copy_u8Value;break;
    1fc8:	e2 e3       	ldi	r30, 0x32	; 50
    1fca:	f0 e0       	ldi	r31, 0x00	; 0
    1fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fce:	80 83       	st	Z, r24
    1fd0:	05 c0       	rjmp	.+10     	; 0x1fdc <DIO_u8SetPortValue+0x8a>
			default: Local_u8ErrorState=1;
    1fd2:	81 e0       	ldi	r24, 0x01	; 1
    1fd4:	89 83       	std	Y+1, r24	; 0x01
    1fd6:	02 c0       	rjmp	.+4      	; 0x1fdc <DIO_u8SetPortValue+0x8a>
		}
	}
	else
		Local_u8ErrorState = NOTOK;
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	89 83       	std	Y+1, r24	; 0x01
	return Local_u8ErrorState;
    1fdc:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fde:	0f 90       	pop	r0
    1fe0:	0f 90       	pop	r0
    1fe2:	0f 90       	pop	r0
    1fe4:	0f 90       	pop	r0
    1fe6:	0f 90       	pop	r0
    1fe8:	cf 91       	pop	r28
    1fea:	df 91       	pop	r29
    1fec:	08 95       	ret

00001fee <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 Copy_u8Port,u8 Copy_u8Pin,u8 *Copy_pu8Value)
{
    1fee:	df 93       	push	r29
    1ff0:	cf 93       	push	r28
    1ff2:	cd b7       	in	r28, 0x3d	; 61
    1ff4:	de b7       	in	r29, 0x3e	; 62
    1ff6:	27 97       	sbiw	r28, 0x07	; 7
    1ff8:	0f b6       	in	r0, 0x3f	; 63
    1ffa:	f8 94       	cli
    1ffc:	de bf       	out	0x3e, r29	; 62
    1ffe:	0f be       	out	0x3f, r0	; 63
    2000:	cd bf       	out	0x3d, r28	; 61
    2002:	8a 83       	std	Y+2, r24	; 0x02
    2004:	6b 83       	std	Y+3, r22	; 0x03
    2006:	5d 83       	std	Y+5, r21	; 0x05
    2008:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
    200a:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_pu8Value!=NULL)
    200c:	8c 81       	ldd	r24, Y+4	; 0x04
    200e:	9d 81       	ldd	r25, Y+5	; 0x05
    2010:	00 97       	sbiw	r24, 0x00	; 0
    2012:	09 f4       	brne	.+2      	; 0x2016 <DIO_u8GetPinValue+0x28>
    2014:	7b c0       	rjmp	.+246    	; 0x210c <DIO_u8GetPinValue+0x11e>
	{


		if((0<=Copy_u8Pin)&&(Copy_u8Pin<=7))
    2016:	8b 81       	ldd	r24, Y+3	; 0x03
    2018:	88 30       	cpi	r24, 0x08	; 8
    201a:	08 f0       	brcs	.+2      	; 0x201e <DIO_u8GetPinValue+0x30>
    201c:	74 c0       	rjmp	.+232    	; 0x2106 <DIO_u8GetPinValue+0x118>
		{
			switch(Copy_u8Port)
    201e:	8a 81       	ldd	r24, Y+2	; 0x02
    2020:	28 2f       	mov	r18, r24
    2022:	30 e0       	ldi	r19, 0x00	; 0
    2024:	3f 83       	std	Y+7, r19	; 0x07
    2026:	2e 83       	std	Y+6, r18	; 0x06
    2028:	4e 81       	ldd	r20, Y+6	; 0x06
    202a:	5f 81       	ldd	r21, Y+7	; 0x07
    202c:	41 30       	cpi	r20, 0x01	; 1
    202e:	51 05       	cpc	r21, r1
    2030:	59 f1       	breq	.+86     	; 0x2088 <DIO_u8GetPinValue+0x9a>
    2032:	8e 81       	ldd	r24, Y+6	; 0x06
    2034:	9f 81       	ldd	r25, Y+7	; 0x07
    2036:	82 30       	cpi	r24, 0x02	; 2
    2038:	91 05       	cpc	r25, r1
    203a:	34 f4       	brge	.+12     	; 0x2048 <DIO_u8GetPinValue+0x5a>
    203c:	2e 81       	ldd	r18, Y+6	; 0x06
    203e:	3f 81       	ldd	r19, Y+7	; 0x07
    2040:	21 15       	cp	r18, r1
    2042:	31 05       	cpc	r19, r1
    2044:	69 f0       	breq	.+26     	; 0x2060 <DIO_u8GetPinValue+0x72>
    2046:	5c c0       	rjmp	.+184    	; 0x2100 <DIO_u8GetPinValue+0x112>
    2048:	4e 81       	ldd	r20, Y+6	; 0x06
    204a:	5f 81       	ldd	r21, Y+7	; 0x07
    204c:	42 30       	cpi	r20, 0x02	; 2
    204e:	51 05       	cpc	r21, r1
    2050:	79 f1       	breq	.+94     	; 0x20b0 <DIO_u8GetPinValue+0xc2>
    2052:	8e 81       	ldd	r24, Y+6	; 0x06
    2054:	9f 81       	ldd	r25, Y+7	; 0x07
    2056:	83 30       	cpi	r24, 0x03	; 3
    2058:	91 05       	cpc	r25, r1
    205a:	09 f4       	brne	.+2      	; 0x205e <DIO_u8GetPinValue+0x70>
    205c:	3d c0       	rjmp	.+122    	; 0x20d8 <DIO_u8GetPinValue+0xea>
    205e:	50 c0       	rjmp	.+160    	; 0x2100 <DIO_u8GetPinValue+0x112>
			{
				case DIO_PORTA:*Copy_pu8Value=GET_BIT(PINA,Copy_u8Pin);break;
    2060:	e9 e3       	ldi	r30, 0x39	; 57
    2062:	f0 e0       	ldi	r31, 0x00	; 0
    2064:	80 81       	ld	r24, Z
    2066:	28 2f       	mov	r18, r24
    2068:	30 e0       	ldi	r19, 0x00	; 0
    206a:	8b 81       	ldd	r24, Y+3	; 0x03
    206c:	88 2f       	mov	r24, r24
    206e:	90 e0       	ldi	r25, 0x00	; 0
    2070:	a9 01       	movw	r20, r18
    2072:	02 c0       	rjmp	.+4      	; 0x2078 <DIO_u8GetPinValue+0x8a>
    2074:	55 95       	asr	r21
    2076:	47 95       	ror	r20
    2078:	8a 95       	dec	r24
    207a:	e2 f7       	brpl	.-8      	; 0x2074 <DIO_u8GetPinValue+0x86>
    207c:	ca 01       	movw	r24, r20
    207e:	81 70       	andi	r24, 0x01	; 1
    2080:	ec 81       	ldd	r30, Y+4	; 0x04
    2082:	fd 81       	ldd	r31, Y+5	; 0x05
    2084:	80 83       	st	Z, r24
    2086:	44 c0       	rjmp	.+136    	; 0x2110 <DIO_u8GetPinValue+0x122>
				case DIO_PORTB:*Copy_pu8Value=GET_BIT(PINB,Copy_u8Pin);break;
    2088:	e6 e3       	ldi	r30, 0x36	; 54
    208a:	f0 e0       	ldi	r31, 0x00	; 0
    208c:	80 81       	ld	r24, Z
    208e:	28 2f       	mov	r18, r24
    2090:	30 e0       	ldi	r19, 0x00	; 0
    2092:	8b 81       	ldd	r24, Y+3	; 0x03
    2094:	88 2f       	mov	r24, r24
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	a9 01       	movw	r20, r18
    209a:	02 c0       	rjmp	.+4      	; 0x20a0 <DIO_u8GetPinValue+0xb2>
    209c:	55 95       	asr	r21
    209e:	47 95       	ror	r20
    20a0:	8a 95       	dec	r24
    20a2:	e2 f7       	brpl	.-8      	; 0x209c <DIO_u8GetPinValue+0xae>
    20a4:	ca 01       	movw	r24, r20
    20a6:	81 70       	andi	r24, 0x01	; 1
    20a8:	ec 81       	ldd	r30, Y+4	; 0x04
    20aa:	fd 81       	ldd	r31, Y+5	; 0x05
    20ac:	80 83       	st	Z, r24
    20ae:	30 c0       	rjmp	.+96     	; 0x2110 <DIO_u8GetPinValue+0x122>
				case DIO_PORTC:*Copy_pu8Value=GET_BIT(PINC,Copy_u8Pin);break;
    20b0:	e3 e3       	ldi	r30, 0x33	; 51
    20b2:	f0 e0       	ldi	r31, 0x00	; 0
    20b4:	80 81       	ld	r24, Z
    20b6:	28 2f       	mov	r18, r24
    20b8:	30 e0       	ldi	r19, 0x00	; 0
    20ba:	8b 81       	ldd	r24, Y+3	; 0x03
    20bc:	88 2f       	mov	r24, r24
    20be:	90 e0       	ldi	r25, 0x00	; 0
    20c0:	a9 01       	movw	r20, r18
    20c2:	02 c0       	rjmp	.+4      	; 0x20c8 <DIO_u8GetPinValue+0xda>
    20c4:	55 95       	asr	r21
    20c6:	47 95       	ror	r20
    20c8:	8a 95       	dec	r24
    20ca:	e2 f7       	brpl	.-8      	; 0x20c4 <DIO_u8GetPinValue+0xd6>
    20cc:	ca 01       	movw	r24, r20
    20ce:	81 70       	andi	r24, 0x01	; 1
    20d0:	ec 81       	ldd	r30, Y+4	; 0x04
    20d2:	fd 81       	ldd	r31, Y+5	; 0x05
    20d4:	80 83       	st	Z, r24
    20d6:	1c c0       	rjmp	.+56     	; 0x2110 <DIO_u8GetPinValue+0x122>
				case DIO_PORTD:*Copy_pu8Value=GET_BIT(PIND,Copy_u8Pin);break;
    20d8:	e0 e3       	ldi	r30, 0x30	; 48
    20da:	f0 e0       	ldi	r31, 0x00	; 0
    20dc:	80 81       	ld	r24, Z
    20de:	28 2f       	mov	r18, r24
    20e0:	30 e0       	ldi	r19, 0x00	; 0
    20e2:	8b 81       	ldd	r24, Y+3	; 0x03
    20e4:	88 2f       	mov	r24, r24
    20e6:	90 e0       	ldi	r25, 0x00	; 0
    20e8:	a9 01       	movw	r20, r18
    20ea:	02 c0       	rjmp	.+4      	; 0x20f0 <DIO_u8GetPinValue+0x102>
    20ec:	55 95       	asr	r21
    20ee:	47 95       	ror	r20
    20f0:	8a 95       	dec	r24
    20f2:	e2 f7       	brpl	.-8      	; 0x20ec <DIO_u8GetPinValue+0xfe>
    20f4:	ca 01       	movw	r24, r20
    20f6:	81 70       	andi	r24, 0x01	; 1
    20f8:	ec 81       	ldd	r30, Y+4	; 0x04
    20fa:	fd 81       	ldd	r31, Y+5	; 0x05
    20fc:	80 83       	st	Z, r24
    20fe:	08 c0       	rjmp	.+16     	; 0x2110 <DIO_u8GetPinValue+0x122>
				default: Local_u8ErrorState=1;
    2100:	81 e0       	ldi	r24, 0x01	; 1
    2102:	89 83       	std	Y+1, r24	; 0x01
    2104:	05 c0       	rjmp	.+10     	; 0x2110 <DIO_u8GetPinValue+0x122>
			}
		}
		else
			Local_u8ErrorState=1;
    2106:	81 e0       	ldi	r24, 0x01	; 1
    2108:	89 83       	std	Y+1, r24	; 0x01
    210a:	02 c0       	rjmp	.+4      	; 0x2110 <DIO_u8GetPinValue+0x122>
	}
	else
		Local_u8ErrorState = NULL_POINTER;
    210c:	82 e0       	ldi	r24, 0x02	; 2
    210e:	89 83       	std	Y+1, r24	; 0x01
	return Local_u8ErrorState;
    2110:	89 81       	ldd	r24, Y+1	; 0x01
}
    2112:	27 96       	adiw	r28, 0x07	; 7
    2114:	0f b6       	in	r0, 0x3f	; 63
    2116:	f8 94       	cli
    2118:	de bf       	out	0x3e, r29	; 62
    211a:	0f be       	out	0x3f, r0	; 63
    211c:	cd bf       	out	0x3d, r28	; 61
    211e:	cf 91       	pop	r28
    2120:	df 91       	pop	r29
    2122:	08 95       	ret

00002124 <DIO_u8TogglePinValue>:
u8 DIO_u8TogglePinValue(u8 Copy_u8Port,u8 Copy_u8Pin)
{
    2124:	df 93       	push	r29
    2126:	cf 93       	push	r28
    2128:	00 d0       	rcall	.+0      	; 0x212a <DIO_u8TogglePinValue+0x6>
    212a:	00 d0       	rcall	.+0      	; 0x212c <DIO_u8TogglePinValue+0x8>
    212c:	0f 92       	push	r0
    212e:	cd b7       	in	r28, 0x3d	; 61
    2130:	de b7       	in	r29, 0x3e	; 62
    2132:	8a 83       	std	Y+2, r24	; 0x02
    2134:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    2136:	19 82       	std	Y+1, r1	; 0x01
	if((0<=Copy_u8Pin)&&(Copy_u8Pin<=7))
    2138:	8b 81       	ldd	r24, Y+3	; 0x03
    213a:	88 30       	cpi	r24, 0x08	; 8
    213c:	08 f0       	brcs	.+2      	; 0x2140 <DIO_u8TogglePinValue+0x1c>
    213e:	72 c0       	rjmp	.+228    	; 0x2224 <DIO_u8TogglePinValue+0x100>
	{
		switch(Copy_u8Port)
    2140:	8a 81       	ldd	r24, Y+2	; 0x02
    2142:	28 2f       	mov	r18, r24
    2144:	30 e0       	ldi	r19, 0x00	; 0
    2146:	3d 83       	std	Y+5, r19	; 0x05
    2148:	2c 83       	std	Y+4, r18	; 0x04
    214a:	8c 81       	ldd	r24, Y+4	; 0x04
    214c:	9d 81       	ldd	r25, Y+5	; 0x05
    214e:	81 30       	cpi	r24, 0x01	; 1
    2150:	91 05       	cpc	r25, r1
    2152:	49 f1       	breq	.+82     	; 0x21a6 <DIO_u8TogglePinValue+0x82>
    2154:	2c 81       	ldd	r18, Y+4	; 0x04
    2156:	3d 81       	ldd	r19, Y+5	; 0x05
    2158:	22 30       	cpi	r18, 0x02	; 2
    215a:	31 05       	cpc	r19, r1
    215c:	2c f4       	brge	.+10     	; 0x2168 <DIO_u8TogglePinValue+0x44>
    215e:	8c 81       	ldd	r24, Y+4	; 0x04
    2160:	9d 81       	ldd	r25, Y+5	; 0x05
    2162:	00 97       	sbiw	r24, 0x00	; 0
    2164:	61 f0       	breq	.+24     	; 0x217e <DIO_u8TogglePinValue+0x5a>
    2166:	5b c0       	rjmp	.+182    	; 0x221e <DIO_u8TogglePinValue+0xfa>
    2168:	2c 81       	ldd	r18, Y+4	; 0x04
    216a:	3d 81       	ldd	r19, Y+5	; 0x05
    216c:	22 30       	cpi	r18, 0x02	; 2
    216e:	31 05       	cpc	r19, r1
    2170:	71 f1       	breq	.+92     	; 0x21ce <DIO_u8TogglePinValue+0xaa>
    2172:	8c 81       	ldd	r24, Y+4	; 0x04
    2174:	9d 81       	ldd	r25, Y+5	; 0x05
    2176:	83 30       	cpi	r24, 0x03	; 3
    2178:	91 05       	cpc	r25, r1
    217a:	e9 f1       	breq	.+122    	; 0x21f6 <DIO_u8TogglePinValue+0xd2>
    217c:	50 c0       	rjmp	.+160    	; 0x221e <DIO_u8TogglePinValue+0xfa>
		{
			case DIO_PORTA:TOG_BIT(PORTA,Copy_u8Pin);break;
    217e:	ab e3       	ldi	r26, 0x3B	; 59
    2180:	b0 e0       	ldi	r27, 0x00	; 0
    2182:	eb e3       	ldi	r30, 0x3B	; 59
    2184:	f0 e0       	ldi	r31, 0x00	; 0
    2186:	80 81       	ld	r24, Z
    2188:	48 2f       	mov	r20, r24
    218a:	8b 81       	ldd	r24, Y+3	; 0x03
    218c:	28 2f       	mov	r18, r24
    218e:	30 e0       	ldi	r19, 0x00	; 0
    2190:	81 e0       	ldi	r24, 0x01	; 1
    2192:	90 e0       	ldi	r25, 0x00	; 0
    2194:	02 2e       	mov	r0, r18
    2196:	02 c0       	rjmp	.+4      	; 0x219c <DIO_u8TogglePinValue+0x78>
    2198:	88 0f       	add	r24, r24
    219a:	99 1f       	adc	r25, r25
    219c:	0a 94       	dec	r0
    219e:	e2 f7       	brpl	.-8      	; 0x2198 <DIO_u8TogglePinValue+0x74>
    21a0:	84 27       	eor	r24, r20
    21a2:	8c 93       	st	X, r24
    21a4:	41 c0       	rjmp	.+130    	; 0x2228 <DIO_u8TogglePinValue+0x104>
			case DIO_PORTB:TOG_BIT(PORTB,Copy_u8Pin);break;
    21a6:	a8 e3       	ldi	r26, 0x38	; 56
    21a8:	b0 e0       	ldi	r27, 0x00	; 0
    21aa:	e8 e3       	ldi	r30, 0x38	; 56
    21ac:	f0 e0       	ldi	r31, 0x00	; 0
    21ae:	80 81       	ld	r24, Z
    21b0:	48 2f       	mov	r20, r24
    21b2:	8b 81       	ldd	r24, Y+3	; 0x03
    21b4:	28 2f       	mov	r18, r24
    21b6:	30 e0       	ldi	r19, 0x00	; 0
    21b8:	81 e0       	ldi	r24, 0x01	; 1
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	02 2e       	mov	r0, r18
    21be:	02 c0       	rjmp	.+4      	; 0x21c4 <DIO_u8TogglePinValue+0xa0>
    21c0:	88 0f       	add	r24, r24
    21c2:	99 1f       	adc	r25, r25
    21c4:	0a 94       	dec	r0
    21c6:	e2 f7       	brpl	.-8      	; 0x21c0 <DIO_u8TogglePinValue+0x9c>
    21c8:	84 27       	eor	r24, r20
    21ca:	8c 93       	st	X, r24
    21cc:	2d c0       	rjmp	.+90     	; 0x2228 <DIO_u8TogglePinValue+0x104>
			case DIO_PORTC:TOG_BIT(PORTC,Copy_u8Pin);break;
    21ce:	a5 e3       	ldi	r26, 0x35	; 53
    21d0:	b0 e0       	ldi	r27, 0x00	; 0
    21d2:	e5 e3       	ldi	r30, 0x35	; 53
    21d4:	f0 e0       	ldi	r31, 0x00	; 0
    21d6:	80 81       	ld	r24, Z
    21d8:	48 2f       	mov	r20, r24
    21da:	8b 81       	ldd	r24, Y+3	; 0x03
    21dc:	28 2f       	mov	r18, r24
    21de:	30 e0       	ldi	r19, 0x00	; 0
    21e0:	81 e0       	ldi	r24, 0x01	; 1
    21e2:	90 e0       	ldi	r25, 0x00	; 0
    21e4:	02 2e       	mov	r0, r18
    21e6:	02 c0       	rjmp	.+4      	; 0x21ec <DIO_u8TogglePinValue+0xc8>
    21e8:	88 0f       	add	r24, r24
    21ea:	99 1f       	adc	r25, r25
    21ec:	0a 94       	dec	r0
    21ee:	e2 f7       	brpl	.-8      	; 0x21e8 <DIO_u8TogglePinValue+0xc4>
    21f0:	84 27       	eor	r24, r20
    21f2:	8c 93       	st	X, r24
    21f4:	19 c0       	rjmp	.+50     	; 0x2228 <DIO_u8TogglePinValue+0x104>
			case DIO_PORTD:TOG_BIT(PORTD,Copy_u8Pin);break;
    21f6:	a2 e3       	ldi	r26, 0x32	; 50
    21f8:	b0 e0       	ldi	r27, 0x00	; 0
    21fa:	e2 e3       	ldi	r30, 0x32	; 50
    21fc:	f0 e0       	ldi	r31, 0x00	; 0
    21fe:	80 81       	ld	r24, Z
    2200:	48 2f       	mov	r20, r24
    2202:	8b 81       	ldd	r24, Y+3	; 0x03
    2204:	28 2f       	mov	r18, r24
    2206:	30 e0       	ldi	r19, 0x00	; 0
    2208:	81 e0       	ldi	r24, 0x01	; 1
    220a:	90 e0       	ldi	r25, 0x00	; 0
    220c:	02 2e       	mov	r0, r18
    220e:	02 c0       	rjmp	.+4      	; 0x2214 <DIO_u8TogglePinValue+0xf0>
    2210:	88 0f       	add	r24, r24
    2212:	99 1f       	adc	r25, r25
    2214:	0a 94       	dec	r0
    2216:	e2 f7       	brpl	.-8      	; 0x2210 <DIO_u8TogglePinValue+0xec>
    2218:	84 27       	eor	r24, r20
    221a:	8c 93       	st	X, r24
    221c:	05 c0       	rjmp	.+10     	; 0x2228 <DIO_u8TogglePinValue+0x104>
			default: Local_u8ErrorState=1;
    221e:	81 e0       	ldi	r24, 0x01	; 1
    2220:	89 83       	std	Y+1, r24	; 0x01
    2222:	02 c0       	rjmp	.+4      	; 0x2228 <DIO_u8TogglePinValue+0x104>
		}
	}
	else
		Local_u8ErrorState=1;
    2224:	81 e0       	ldi	r24, 0x01	; 1
    2226:	89 83       	std	Y+1, r24	; 0x01
	return Local_u8ErrorState;
    2228:	89 81       	ldd	r24, Y+1	; 0x01
}
    222a:	0f 90       	pop	r0
    222c:	0f 90       	pop	r0
    222e:	0f 90       	pop	r0
    2230:	0f 90       	pop	r0
    2232:	0f 90       	pop	r0
    2234:	cf 91       	pop	r28
    2236:	df 91       	pop	r29
    2238:	08 95       	ret

0000223a <DIO_u8SetLowNibbleValue>:

u8 DIO_u8SetLowNibbleValue(u8 Copy_u8Port,u8 Copy_u8Value)
{
    223a:	df 93       	push	r29
    223c:	cf 93       	push	r28
    223e:	00 d0       	rcall	.+0      	; 0x2240 <DIO_u8SetLowNibbleValue+0x6>
    2240:	00 d0       	rcall	.+0      	; 0x2242 <DIO_u8SetLowNibbleValue+0x8>
    2242:	0f 92       	push	r0
    2244:	cd b7       	in	r28, 0x3d	; 61
    2246:	de b7       	in	r29, 0x3e	; 62
    2248:	8a 83       	std	Y+2, r24	; 0x02
    224a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    224c:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8Port<=DIO_PORTD){
    224e:	8a 81       	ldd	r24, Y+2	; 0x02
    2250:	84 30       	cpi	r24, 0x04	; 4
    2252:	08 f0       	brcs	.+2      	; 0x2256 <DIO_u8SetLowNibbleValue+0x1c>
    2254:	62 c0       	rjmp	.+196    	; 0x231a <DIO_u8SetLowNibbleValue+0xe0>
		switch(Copy_u8Port)
    2256:	8a 81       	ldd	r24, Y+2	; 0x02
    2258:	28 2f       	mov	r18, r24
    225a:	30 e0       	ldi	r19, 0x00	; 0
    225c:	3d 83       	std	Y+5, r19	; 0x05
    225e:	2c 83       	std	Y+4, r18	; 0x04
    2260:	8c 81       	ldd	r24, Y+4	; 0x04
    2262:	9d 81       	ldd	r25, Y+5	; 0x05
    2264:	81 30       	cpi	r24, 0x01	; 1
    2266:	91 05       	cpc	r25, r1
    2268:	29 f1       	breq	.+74     	; 0x22b4 <DIO_u8SetLowNibbleValue+0x7a>
    226a:	2c 81       	ldd	r18, Y+4	; 0x04
    226c:	3d 81       	ldd	r19, Y+5	; 0x05
    226e:	22 30       	cpi	r18, 0x02	; 2
    2270:	31 05       	cpc	r19, r1
    2272:	2c f4       	brge	.+10     	; 0x227e <DIO_u8SetLowNibbleValue+0x44>
    2274:	8c 81       	ldd	r24, Y+4	; 0x04
    2276:	9d 81       	ldd	r25, Y+5	; 0x05
    2278:	00 97       	sbiw	r24, 0x00	; 0
    227a:	61 f0       	breq	.+24     	; 0x2294 <DIO_u8SetLowNibbleValue+0x5a>
    227c:	4b c0       	rjmp	.+150    	; 0x2314 <DIO_u8SetLowNibbleValue+0xda>
    227e:	2c 81       	ldd	r18, Y+4	; 0x04
    2280:	3d 81       	ldd	r19, Y+5	; 0x05
    2282:	22 30       	cpi	r18, 0x02	; 2
    2284:	31 05       	cpc	r19, r1
    2286:	31 f1       	breq	.+76     	; 0x22d4 <DIO_u8SetLowNibbleValue+0x9a>
    2288:	8c 81       	ldd	r24, Y+4	; 0x04
    228a:	9d 81       	ldd	r25, Y+5	; 0x05
    228c:	83 30       	cpi	r24, 0x03	; 3
    228e:	91 05       	cpc	r25, r1
    2290:	89 f1       	breq	.+98     	; 0x22f4 <DIO_u8SetLowNibbleValue+0xba>
    2292:	40 c0       	rjmp	.+128    	; 0x2314 <DIO_u8SetLowNibbleValue+0xda>
		{
			case DIO_PORTA:PORTA&=DIO_LOWNIBBLE_MASK;PORTA|=Copy_u8Value;break;
    2294:	ab e3       	ldi	r26, 0x3B	; 59
    2296:	b0 e0       	ldi	r27, 0x00	; 0
    2298:	eb e3       	ldi	r30, 0x3B	; 59
    229a:	f0 e0       	ldi	r31, 0x00	; 0
    229c:	80 81       	ld	r24, Z
    229e:	80 7f       	andi	r24, 0xF0	; 240
    22a0:	8c 93       	st	X, r24
    22a2:	ab e3       	ldi	r26, 0x3B	; 59
    22a4:	b0 e0       	ldi	r27, 0x00	; 0
    22a6:	eb e3       	ldi	r30, 0x3B	; 59
    22a8:	f0 e0       	ldi	r31, 0x00	; 0
    22aa:	90 81       	ld	r25, Z
    22ac:	8b 81       	ldd	r24, Y+3	; 0x03
    22ae:	89 2b       	or	r24, r25
    22b0:	8c 93       	st	X, r24
    22b2:	35 c0       	rjmp	.+106    	; 0x231e <DIO_u8SetLowNibbleValue+0xe4>
			case DIO_PORTB:PORTB&=DIO_LOWNIBBLE_MASK;PORTB|=Copy_u8Value;break;
    22b4:	a8 e3       	ldi	r26, 0x38	; 56
    22b6:	b0 e0       	ldi	r27, 0x00	; 0
    22b8:	e8 e3       	ldi	r30, 0x38	; 56
    22ba:	f0 e0       	ldi	r31, 0x00	; 0
    22bc:	80 81       	ld	r24, Z
    22be:	80 7f       	andi	r24, 0xF0	; 240
    22c0:	8c 93       	st	X, r24
    22c2:	a8 e3       	ldi	r26, 0x38	; 56
    22c4:	b0 e0       	ldi	r27, 0x00	; 0
    22c6:	e8 e3       	ldi	r30, 0x38	; 56
    22c8:	f0 e0       	ldi	r31, 0x00	; 0
    22ca:	90 81       	ld	r25, Z
    22cc:	8b 81       	ldd	r24, Y+3	; 0x03
    22ce:	89 2b       	or	r24, r25
    22d0:	8c 93       	st	X, r24
    22d2:	25 c0       	rjmp	.+74     	; 0x231e <DIO_u8SetLowNibbleValue+0xe4>
			case DIO_PORTC:PORTC&=DIO_LOWNIBBLE_MASK;PORTC|=Copy_u8Value;break;
    22d4:	a5 e3       	ldi	r26, 0x35	; 53
    22d6:	b0 e0       	ldi	r27, 0x00	; 0
    22d8:	e5 e3       	ldi	r30, 0x35	; 53
    22da:	f0 e0       	ldi	r31, 0x00	; 0
    22dc:	80 81       	ld	r24, Z
    22de:	80 7f       	andi	r24, 0xF0	; 240
    22e0:	8c 93       	st	X, r24
    22e2:	a5 e3       	ldi	r26, 0x35	; 53
    22e4:	b0 e0       	ldi	r27, 0x00	; 0
    22e6:	e5 e3       	ldi	r30, 0x35	; 53
    22e8:	f0 e0       	ldi	r31, 0x00	; 0
    22ea:	90 81       	ld	r25, Z
    22ec:	8b 81       	ldd	r24, Y+3	; 0x03
    22ee:	89 2b       	or	r24, r25
    22f0:	8c 93       	st	X, r24
    22f2:	15 c0       	rjmp	.+42     	; 0x231e <DIO_u8SetLowNibbleValue+0xe4>
			case DIO_PORTD:PORTD&=DIO_LOWNIBBLE_MASK;PORTD|=Copy_u8Value;break;
    22f4:	a2 e3       	ldi	r26, 0x32	; 50
    22f6:	b0 e0       	ldi	r27, 0x00	; 0
    22f8:	e2 e3       	ldi	r30, 0x32	; 50
    22fa:	f0 e0       	ldi	r31, 0x00	; 0
    22fc:	80 81       	ld	r24, Z
    22fe:	80 7f       	andi	r24, 0xF0	; 240
    2300:	8c 93       	st	X, r24
    2302:	a2 e3       	ldi	r26, 0x32	; 50
    2304:	b0 e0       	ldi	r27, 0x00	; 0
    2306:	e2 e3       	ldi	r30, 0x32	; 50
    2308:	f0 e0       	ldi	r31, 0x00	; 0
    230a:	90 81       	ld	r25, Z
    230c:	8b 81       	ldd	r24, Y+3	; 0x03
    230e:	89 2b       	or	r24, r25
    2310:	8c 93       	st	X, r24
    2312:	05 c0       	rjmp	.+10     	; 0x231e <DIO_u8SetLowNibbleValue+0xe4>
			default: Local_u8ErrorState=1;
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	89 83       	std	Y+1, r24	; 0x01
    2318:	02 c0       	rjmp	.+4      	; 0x231e <DIO_u8SetLowNibbleValue+0xe4>
		}
	}
	else
		Local_u8ErrorState=1;
    231a:	81 e0       	ldi	r24, 0x01	; 1
    231c:	89 83       	std	Y+1, r24	; 0x01
	return Local_u8ErrorState;
    231e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2320:	0f 90       	pop	r0
    2322:	0f 90       	pop	r0
    2324:	0f 90       	pop	r0
    2326:	0f 90       	pop	r0
    2328:	0f 90       	pop	r0
    232a:	cf 91       	pop	r28
    232c:	df 91       	pop	r29
    232e:	08 95       	ret

00002330 <DIO_u8SetHighNibbleValue>:
u8 DIO_u8SetHighNibbleValue(u8 Copy_u8Port,u8 Copy_u8Value)
{
    2330:	df 93       	push	r29
    2332:	cf 93       	push	r28
    2334:	00 d0       	rcall	.+0      	; 0x2336 <DIO_u8SetHighNibbleValue+0x6>
    2336:	00 d0       	rcall	.+0      	; 0x2338 <DIO_u8SetHighNibbleValue+0x8>
    2338:	0f 92       	push	r0
    233a:	cd b7       	in	r28, 0x3d	; 61
    233c:	de b7       	in	r29, 0x3e	; 62
    233e:	8a 83       	std	Y+2, r24	; 0x02
    2340:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    2342:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8Port<=DIO_PORTD){
    2344:	8a 81       	ldd	r24, Y+2	; 0x02
    2346:	84 30       	cpi	r24, 0x04	; 4
    2348:	08 f0       	brcs	.+2      	; 0x234c <DIO_u8SetHighNibbleValue+0x1c>
    234a:	87 c0       	rjmp	.+270    	; 0x245a <DIO_u8SetHighNibbleValue+0x12a>
		switch(Copy_u8Port)
    234c:	8a 81       	ldd	r24, Y+2	; 0x02
    234e:	28 2f       	mov	r18, r24
    2350:	30 e0       	ldi	r19, 0x00	; 0
    2352:	3d 83       	std	Y+5, r19	; 0x05
    2354:	2c 83       	std	Y+4, r18	; 0x04
    2356:	8c 81       	ldd	r24, Y+4	; 0x04
    2358:	9d 81       	ldd	r25, Y+5	; 0x05
    235a:	81 30       	cpi	r24, 0x01	; 1
    235c:	91 05       	cpc	r25, r1
    235e:	79 f1       	breq	.+94     	; 0x23be <DIO_u8SetHighNibbleValue+0x8e>
    2360:	2c 81       	ldd	r18, Y+4	; 0x04
    2362:	3d 81       	ldd	r19, Y+5	; 0x05
    2364:	22 30       	cpi	r18, 0x02	; 2
    2366:	31 05       	cpc	r19, r1
    2368:	2c f4       	brge	.+10     	; 0x2374 <DIO_u8SetHighNibbleValue+0x44>
    236a:	8c 81       	ldd	r24, Y+4	; 0x04
    236c:	9d 81       	ldd	r25, Y+5	; 0x05
    236e:	00 97       	sbiw	r24, 0x00	; 0
    2370:	69 f0       	breq	.+26     	; 0x238c <DIO_u8SetHighNibbleValue+0x5c>
    2372:	70 c0       	rjmp	.+224    	; 0x2454 <DIO_u8SetHighNibbleValue+0x124>
    2374:	2c 81       	ldd	r18, Y+4	; 0x04
    2376:	3d 81       	ldd	r19, Y+5	; 0x05
    2378:	22 30       	cpi	r18, 0x02	; 2
    237a:	31 05       	cpc	r19, r1
    237c:	c9 f1       	breq	.+114    	; 0x23f0 <DIO_u8SetHighNibbleValue+0xc0>
    237e:	8c 81       	ldd	r24, Y+4	; 0x04
    2380:	9d 81       	ldd	r25, Y+5	; 0x05
    2382:	83 30       	cpi	r24, 0x03	; 3
    2384:	91 05       	cpc	r25, r1
    2386:	09 f4       	brne	.+2      	; 0x238a <DIO_u8SetHighNibbleValue+0x5a>
    2388:	4c c0       	rjmp	.+152    	; 0x2422 <DIO_u8SetHighNibbleValue+0xf2>
    238a:	64 c0       	rjmp	.+200    	; 0x2454 <DIO_u8SetHighNibbleValue+0x124>
		{
			case DIO_PORTA:PORTA &= DIO_HIGHNIBBLE_MASK;PORTA |= (Copy_u8Value<<4);break;
    238c:	ab e3       	ldi	r26, 0x3B	; 59
    238e:	b0 e0       	ldi	r27, 0x00	; 0
    2390:	eb e3       	ldi	r30, 0x3B	; 59
    2392:	f0 e0       	ldi	r31, 0x00	; 0
    2394:	80 81       	ld	r24, Z
    2396:	8f 70       	andi	r24, 0x0F	; 15
    2398:	8c 93       	st	X, r24
    239a:	ab e3       	ldi	r26, 0x3B	; 59
    239c:	b0 e0       	ldi	r27, 0x00	; 0
    239e:	eb e3       	ldi	r30, 0x3B	; 59
    23a0:	f0 e0       	ldi	r31, 0x00	; 0
    23a2:	80 81       	ld	r24, Z
    23a4:	28 2f       	mov	r18, r24
    23a6:	8b 81       	ldd	r24, Y+3	; 0x03
    23a8:	88 2f       	mov	r24, r24
    23aa:	90 e0       	ldi	r25, 0x00	; 0
    23ac:	82 95       	swap	r24
    23ae:	92 95       	swap	r25
    23b0:	90 7f       	andi	r25, 0xF0	; 240
    23b2:	98 27       	eor	r25, r24
    23b4:	80 7f       	andi	r24, 0xF0	; 240
    23b6:	98 27       	eor	r25, r24
    23b8:	82 2b       	or	r24, r18
    23ba:	8c 93       	st	X, r24
    23bc:	50 c0       	rjmp	.+160    	; 0x245e <DIO_u8SetHighNibbleValue+0x12e>
			case DIO_PORTB:PORTB &= DIO_HIGHNIBBLE_MASK;PORTB |= (Copy_u8Value<<4);break;
    23be:	a8 e3       	ldi	r26, 0x38	; 56
    23c0:	b0 e0       	ldi	r27, 0x00	; 0
    23c2:	e8 e3       	ldi	r30, 0x38	; 56
    23c4:	f0 e0       	ldi	r31, 0x00	; 0
    23c6:	80 81       	ld	r24, Z
    23c8:	8f 70       	andi	r24, 0x0F	; 15
    23ca:	8c 93       	st	X, r24
    23cc:	a8 e3       	ldi	r26, 0x38	; 56
    23ce:	b0 e0       	ldi	r27, 0x00	; 0
    23d0:	e8 e3       	ldi	r30, 0x38	; 56
    23d2:	f0 e0       	ldi	r31, 0x00	; 0
    23d4:	80 81       	ld	r24, Z
    23d6:	28 2f       	mov	r18, r24
    23d8:	8b 81       	ldd	r24, Y+3	; 0x03
    23da:	88 2f       	mov	r24, r24
    23dc:	90 e0       	ldi	r25, 0x00	; 0
    23de:	82 95       	swap	r24
    23e0:	92 95       	swap	r25
    23e2:	90 7f       	andi	r25, 0xF0	; 240
    23e4:	98 27       	eor	r25, r24
    23e6:	80 7f       	andi	r24, 0xF0	; 240
    23e8:	98 27       	eor	r25, r24
    23ea:	82 2b       	or	r24, r18
    23ec:	8c 93       	st	X, r24
    23ee:	37 c0       	rjmp	.+110    	; 0x245e <DIO_u8SetHighNibbleValue+0x12e>
			case DIO_PORTC:PORTC &= DIO_HIGHNIBBLE_MASK;PORTC |= (Copy_u8Value<<4);break;
    23f0:	a5 e3       	ldi	r26, 0x35	; 53
    23f2:	b0 e0       	ldi	r27, 0x00	; 0
    23f4:	e5 e3       	ldi	r30, 0x35	; 53
    23f6:	f0 e0       	ldi	r31, 0x00	; 0
    23f8:	80 81       	ld	r24, Z
    23fa:	8f 70       	andi	r24, 0x0F	; 15
    23fc:	8c 93       	st	X, r24
    23fe:	a5 e3       	ldi	r26, 0x35	; 53
    2400:	b0 e0       	ldi	r27, 0x00	; 0
    2402:	e5 e3       	ldi	r30, 0x35	; 53
    2404:	f0 e0       	ldi	r31, 0x00	; 0
    2406:	80 81       	ld	r24, Z
    2408:	28 2f       	mov	r18, r24
    240a:	8b 81       	ldd	r24, Y+3	; 0x03
    240c:	88 2f       	mov	r24, r24
    240e:	90 e0       	ldi	r25, 0x00	; 0
    2410:	82 95       	swap	r24
    2412:	92 95       	swap	r25
    2414:	90 7f       	andi	r25, 0xF0	; 240
    2416:	98 27       	eor	r25, r24
    2418:	80 7f       	andi	r24, 0xF0	; 240
    241a:	98 27       	eor	r25, r24
    241c:	82 2b       	or	r24, r18
    241e:	8c 93       	st	X, r24
    2420:	1e c0       	rjmp	.+60     	; 0x245e <DIO_u8SetHighNibbleValue+0x12e>
			case DIO_PORTD:PORTD &= DIO_HIGHNIBBLE_MASK;PORTD |= (Copy_u8Value<<4);break;
    2422:	a2 e3       	ldi	r26, 0x32	; 50
    2424:	b0 e0       	ldi	r27, 0x00	; 0
    2426:	e2 e3       	ldi	r30, 0x32	; 50
    2428:	f0 e0       	ldi	r31, 0x00	; 0
    242a:	80 81       	ld	r24, Z
    242c:	8f 70       	andi	r24, 0x0F	; 15
    242e:	8c 93       	st	X, r24
    2430:	a2 e3       	ldi	r26, 0x32	; 50
    2432:	b0 e0       	ldi	r27, 0x00	; 0
    2434:	e2 e3       	ldi	r30, 0x32	; 50
    2436:	f0 e0       	ldi	r31, 0x00	; 0
    2438:	80 81       	ld	r24, Z
    243a:	28 2f       	mov	r18, r24
    243c:	8b 81       	ldd	r24, Y+3	; 0x03
    243e:	88 2f       	mov	r24, r24
    2440:	90 e0       	ldi	r25, 0x00	; 0
    2442:	82 95       	swap	r24
    2444:	92 95       	swap	r25
    2446:	90 7f       	andi	r25, 0xF0	; 240
    2448:	98 27       	eor	r25, r24
    244a:	80 7f       	andi	r24, 0xF0	; 240
    244c:	98 27       	eor	r25, r24
    244e:	82 2b       	or	r24, r18
    2450:	8c 93       	st	X, r24
    2452:	05 c0       	rjmp	.+10     	; 0x245e <DIO_u8SetHighNibbleValue+0x12e>
			default: Local_u8ErrorState=1;
    2454:	81 e0       	ldi	r24, 0x01	; 1
    2456:	89 83       	std	Y+1, r24	; 0x01
    2458:	02 c0       	rjmp	.+4      	; 0x245e <DIO_u8SetHighNibbleValue+0x12e>
		}
	}
	else
		Local_u8ErrorState=1;
    245a:	81 e0       	ldi	r24, 0x01	; 1
    245c:	89 83       	std	Y+1, r24	; 0x01
	return Local_u8ErrorState;
    245e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2460:	0f 90       	pop	r0
    2462:	0f 90       	pop	r0
    2464:	0f 90       	pop	r0
    2466:	0f 90       	pop	r0
    2468:	0f 90       	pop	r0
    246a:	cf 91       	pop	r28
    246c:	df 91       	pop	r29
    246e:	08 95       	ret

00002470 <PORT_voidInit>:
#include "../MCAL/PORT_config.h"
#include "../MCAL/PORT_register.h"
#include "../MCAL/PORT_interface.h"

void PORT_voidInit()
{
    2470:	df 93       	push	r29
    2472:	cf 93       	push	r28
    2474:	cd b7       	in	r28, 0x3d	; 61
    2476:	de b7       	in	r29, 0x3e	; 62
	DDRA = PORTA_DIR;	
    2478:	ea e3       	ldi	r30, 0x3A	; 58
    247a:	f0 e0       	ldi	r31, 0x00	; 0
    247c:	85 ee       	ldi	r24, 0xE5	; 229
    247e:	80 83       	st	Z, r24
	DDRB = PORTB_DIR;
    2480:	e7 e3       	ldi	r30, 0x37	; 55
    2482:	f0 e0       	ldi	r31, 0x00	; 0
    2484:	80 ef       	ldi	r24, 0xF0	; 240
    2486:	80 83       	st	Z, r24
	DDRC = PORTC_DIR;
    2488:	e4 e3       	ldi	r30, 0x34	; 52
    248a:	f0 e0       	ldi	r31, 0x00	; 0
    248c:	10 82       	st	Z, r1
	DDRD = PORTD_DIR;
    248e:	e1 e3       	ldi	r30, 0x31	; 49
    2490:	f0 e0       	ldi	r31, 0x00	; 0
    2492:	10 82       	st	Z, r1
	
	PORTA =PORTA_INIT_VALUE;
    2494:	eb e3       	ldi	r30, 0x3B	; 59
    2496:	f0 e0       	ldi	r31, 0x00	; 0
    2498:	10 82       	st	Z, r1
	PORTB =PORTB_INIT_VALUE;
    249a:	e8 e3       	ldi	r30, 0x38	; 56
    249c:	f0 e0       	ldi	r31, 0x00	; 0
    249e:	82 e0       	ldi	r24, 0x02	; 2
    24a0:	80 83       	st	Z, r24
	PORTC =PORTC_INIT_VALUE;
    24a2:	e5 e3       	ldi	r30, 0x35	; 53
    24a4:	f0 e0       	ldi	r31, 0x00	; 0
    24a6:	10 82       	st	Z, r1
	PORTD =PORTD_INIT_VALUE;
    24a8:	e2 e3       	ldi	r30, 0x32	; 50
    24aa:	f0 e0       	ldi	r31, 0x00	; 0
    24ac:	10 82       	st	Z, r1
	
}
    24ae:	cf 91       	pop	r28
    24b0:	df 91       	pop	r29
    24b2:	08 95       	ret

000024b4 <main>:
/*
xSemaphoreHandle ADCSem;

u16 ADCread=0;
 */
void main(){
    24b4:	af 92       	push	r10
    24b6:	bf 92       	push	r11
    24b8:	cf 92       	push	r12
    24ba:	df 92       	push	r13
    24bc:	ef 92       	push	r14
    24be:	ff 92       	push	r15
    24c0:	0f 93       	push	r16
    24c2:	df 93       	push	r29
    24c4:	cf 93       	push	r28
    24c6:	cd b7       	in	r28, 0x3d	; 61
    24c8:	de b7       	in	r29, 0x3e	; 62
	PORT_voidInit();
    24ca:	0e 94 38 12 	call	0x2470	; 0x2470 <PORT_voidInit>
	CLCD_voidInit();
    24ce:	0e 94 6d 0b 	call	0x16da	; 0x16da <CLCD_voidInit>

	xTaskCreate(&Led1Tog,NULL,100,NULL,0,NULL);
    24d2:	88 eb       	ldi	r24, 0xB8	; 184
    24d4:	92 e1       	ldi	r25, 0x12	; 18
    24d6:	60 e0       	ldi	r22, 0x00	; 0
    24d8:	70 e0       	ldi	r23, 0x00	; 0
    24da:	44 e6       	ldi	r20, 0x64	; 100
    24dc:	50 e0       	ldi	r21, 0x00	; 0
    24de:	20 e0       	ldi	r18, 0x00	; 0
    24e0:	30 e0       	ldi	r19, 0x00	; 0
    24e2:	00 e0       	ldi	r16, 0x00	; 0
    24e4:	ee 24       	eor	r14, r14
    24e6:	ff 24       	eor	r15, r15
    24e8:	cc 24       	eor	r12, r12
    24ea:	dd 24       	eor	r13, r13
    24ec:	aa 24       	eor	r10, r10
    24ee:	bb 24       	eor	r11, r11
    24f0:	0e 94 a3 1f 	call	0x3f46	; 0x3f46 <xTaskGenericCreate>
	xTaskCreate(&Led2Tog,NULL,100,NULL,1,NULL);
    24f4:	81 ed       	ldi	r24, 0xD1	; 209
    24f6:	92 e1       	ldi	r25, 0x12	; 18
    24f8:	60 e0       	ldi	r22, 0x00	; 0
    24fa:	70 e0       	ldi	r23, 0x00	; 0
    24fc:	44 e6       	ldi	r20, 0x64	; 100
    24fe:	50 e0       	ldi	r21, 0x00	; 0
    2500:	20 e0       	ldi	r18, 0x00	; 0
    2502:	30 e0       	ldi	r19, 0x00	; 0
    2504:	01 e0       	ldi	r16, 0x01	; 1
    2506:	ee 24       	eor	r14, r14
    2508:	ff 24       	eor	r15, r15
    250a:	cc 24       	eor	r12, r12
    250c:	dd 24       	eor	r13, r13
    250e:	aa 24       	eor	r10, r10
    2510:	bb 24       	eor	r11, r11
    2512:	0e 94 a3 1f 	call	0x3f46	; 0x3f46 <xTaskGenericCreate>

	LCDSem=xSemaphoreCreateCounting(1,1);
    2516:	81 e0       	ldi	r24, 0x01	; 1
    2518:	61 e0       	ldi	r22, 0x01	; 1
    251a:	0e 94 ac 1b 	call	0x3758	; 0x3758 <xQueueCreateCountingSemaphore>
    251e:	90 93 20 05 	sts	0x0520, r25
    2522:	80 93 1f 05 	sts	0x051F, r24
	xTaskCreate(&lcd1,NULL,250,NULL,2,NULL);
    2526:	83 e0       	ldi	r24, 0x03	; 3
    2528:	93 e1       	ldi	r25, 0x13	; 19
    252a:	60 e0       	ldi	r22, 0x00	; 0
    252c:	70 e0       	ldi	r23, 0x00	; 0
    252e:	4a ef       	ldi	r20, 0xFA	; 250
    2530:	50 e0       	ldi	r21, 0x00	; 0
    2532:	20 e0       	ldi	r18, 0x00	; 0
    2534:	30 e0       	ldi	r19, 0x00	; 0
    2536:	02 e0       	ldi	r16, 0x02	; 2
    2538:	ee 24       	eor	r14, r14
    253a:	ff 24       	eor	r15, r15
    253c:	cc 24       	eor	r12, r12
    253e:	dd 24       	eor	r13, r13
    2540:	aa 24       	eor	r10, r10
    2542:	bb 24       	eor	r11, r11
    2544:	0e 94 a3 1f 	call	0x3f46	; 0x3f46 <xTaskGenericCreate>
	xTaskCreate(&lcd2,NULL,250,NULL,2,NULL);
    2548:	8b e2       	ldi	r24, 0x2B	; 43
    254a:	93 e1       	ldi	r25, 0x13	; 19
    254c:	60 e0       	ldi	r22, 0x00	; 0
    254e:	70 e0       	ldi	r23, 0x00	; 0
    2550:	4a ef       	ldi	r20, 0xFA	; 250
    2552:	50 e0       	ldi	r21, 0x00	; 0
    2554:	20 e0       	ldi	r18, 0x00	; 0
    2556:	30 e0       	ldi	r19, 0x00	; 0
    2558:	02 e0       	ldi	r16, 0x02	; 2
    255a:	ee 24       	eor	r14, r14
    255c:	ff 24       	eor	r15, r15
    255e:	cc 24       	eor	r12, r12
    2560:	dd 24       	eor	r13, r13
    2562:	aa 24       	eor	r10, r10
    2564:	bb 24       	eor	r11, r11
    2566:	0e 94 a3 1f 	call	0x3f46	; 0x3f46 <xTaskGenericCreate>
	//ADCSem=xSemaphoreCreateCounting(1,0);
	//SWSem = xSemaphoreCreateCounting(1,0);
	//xTaskCreate(&SW1,NULL,100,NULL,0,NULL);
	//xTaskCreate(&Led4Tog,NULL,100,NULL,0,NULL);
	//xTaskCreate(&Led3Tog,NULL,100,NULL,2,NULL);
	vTaskStartScheduler();
    256a:	0e 94 fb 22 	call	0x45f6	; 0x45f6 <vTaskStartScheduler>
    256e:	ff cf       	rjmp	.-2      	; 0x256e <main+0xba>

00002570 <Led1Tog>:

	while(1);
}
void Led1Tog(void *Copy_pvSt)
{
    2570:	df 93       	push	r29
    2572:	cf 93       	push	r28
    2574:	00 d0       	rcall	.+0      	; 0x2576 <Led1Tog+0x6>
    2576:	cd b7       	in	r28, 0x3d	; 61
    2578:	de b7       	in	r29, 0x3e	; 62
    257a:	9a 83       	std	Y+2, r25	; 0x02
    257c:	89 83       	std	Y+1, r24	; 0x01
	//LED_u8TogLed(&led[0]);

	static u8 Local_u8State = 0;
	while(1)
	{
		TOG_BIT(Local_u8State,0);
    257e:	90 91 94 00 	lds	r25, 0x0094
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	89 27       	eor	r24, r25
    2586:	80 93 94 00 	sts	0x0094, r24
		DIO_u8SetPinValue(DIO_PORTA,DIO_PIN5,Local_u8State);
    258a:	90 91 94 00 	lds	r25, 0x0094
    258e:	80 e0       	ldi	r24, 0x00	; 0
    2590:	65 e0       	ldi	r22, 0x05	; 5
    2592:	49 2f       	mov	r20, r25
    2594:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
		vTaskDelay(200);
    2598:	88 ec       	ldi	r24, 0xC8	; 200
    259a:	90 e0       	ldi	r25, 0x00	; 0
    259c:	0e 94 67 21 	call	0x42ce	; 0x42ce <vTaskDelay>
    25a0:	ee cf       	rjmp	.-36     	; 0x257e <Led1Tog+0xe>

000025a2 <Led2Tog>:
	}
}

void Led2Tog(void *Copy_pvSt)
{
    25a2:	df 93       	push	r29
    25a4:	cf 93       	push	r28
    25a6:	00 d0       	rcall	.+0      	; 0x25a8 <Led2Tog+0x6>
    25a8:	cd b7       	in	r28, 0x3d	; 61
    25aa:	de b7       	in	r29, 0x3e	; 62
    25ac:	9a 83       	std	Y+2, r25	; 0x02
    25ae:	89 83       	std	Y+1, r24	; 0x01
	//LED_u8TogLed(&led[1]);
	static u8 Local_u8State = 0;
	while(1)
	{
		TOG_BIT(Local_u8State,0);
    25b0:	90 91 95 00 	lds	r25, 0x0095
    25b4:	81 e0       	ldi	r24, 0x01	; 1
    25b6:	89 27       	eor	r24, r25
    25b8:	80 93 95 00 	sts	0x0095, r24
		DIO_u8SetPinValue(DIO_PORTA,DIO_PIN6,Local_u8State);
    25bc:	90 91 95 00 	lds	r25, 0x0095
    25c0:	80 e0       	ldi	r24, 0x00	; 0
    25c2:	66 e0       	ldi	r22, 0x06	; 6
    25c4:	49 2f       	mov	r20, r25
    25c6:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
		vTaskDelay(1000);
    25ca:	88 ee       	ldi	r24, 0xE8	; 232
    25cc:	93 e0       	ldi	r25, 0x03	; 3
    25ce:	0e 94 67 21 	call	0x42ce	; 0x42ce <vTaskDelay>
    25d2:	ee cf       	rjmp	.-36     	; 0x25b0 <Led2Tog+0xe>

000025d4 <Led3Tog>:
	}
}
void Led3Tog(void *Copy_pvSt)
{
    25d4:	df 93       	push	r29
    25d6:	cf 93       	push	r28
    25d8:	00 d0       	rcall	.+0      	; 0x25da <Led3Tog+0x6>
    25da:	cd b7       	in	r28, 0x3d	; 61
    25dc:	de b7       	in	r29, 0x3e	; 62
    25de:	9a 83       	std	Y+2, r25	; 0x02
    25e0:	89 83       	std	Y+1, r24	; 0x01
	//LED_u8TogLed(&led[2]);
	static u8 Local_u8State = 0;
	while(1)
	{
		TOG_BIT(Local_u8State,0);
    25e2:	90 91 96 00 	lds	r25, 0x0096
    25e6:	81 e0       	ldi	r24, 0x01	; 1
    25e8:	89 27       	eor	r24, r25
    25ea:	80 93 96 00 	sts	0x0096, r24
		DIO_u8SetPinValue(DIO_PORTA,DIO_PIN7,Local_u8State);
    25ee:	90 91 96 00 	lds	r25, 0x0096
    25f2:	80 e0       	ldi	r24, 0x00	; 0
    25f4:	67 e0       	ldi	r22, 0x07	; 7
    25f6:	49 2f       	mov	r20, r25
    25f8:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
		vTaskDelay(3000);
    25fc:	88 eb       	ldi	r24, 0xB8	; 184
    25fe:	9b e0       	ldi	r25, 0x0B	; 11
    2600:	0e 94 67 21 	call	0x42ce	; 0x42ce <vTaskDelay>
    2604:	ee cf       	rjmp	.-36     	; 0x25e2 <Led3Tog+0xe>

00002606 <lcd1>:

}


void lcd1(void *Copy_pvSt)
{
    2606:	df 93       	push	r29
    2608:	cf 93       	push	r28
    260a:	00 d0       	rcall	.+0      	; 0x260c <lcd1+0x6>
    260c:	cd b7       	in	r28, 0x3d	; 61
    260e:	de b7       	in	r29, 0x3e	; 62
    2610:	9a 83       	std	Y+2, r25	; 0x02
    2612:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(LCDSem,0)==pdPASS)
    2614:	80 91 1f 05 	lds	r24, 0x051F
    2618:	90 91 20 05 	lds	r25, 0x0520
    261c:	60 e0       	ldi	r22, 0x00	; 0
    261e:	70 e0       	ldi	r23, 0x00	; 0
    2620:	40 e0       	ldi	r20, 0x00	; 0
    2622:	50 e0       	ldi	r21, 0x00	; 0
    2624:	20 e0       	ldi	r18, 0x00	; 0
    2626:	0e 94 b6 1c 	call	0x396c	; 0x396c <xQueueGenericReceive>
    262a:	81 30       	cpi	r24, 0x01	; 1
    262c:	79 f4       	brne	.+30     	; 0x264c <lcd1+0x46>
		{
			CLCD_voidSendString("I'm task1");
    262e:	80 e6       	ldi	r24, 0x60	; 96
    2630:	90 e0       	ldi	r25, 0x00	; 0
    2632:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <CLCD_voidSendString>
			xSemaphoreGive(LCDSem);
    2636:	80 91 1f 05 	lds	r24, 0x051F
    263a:	90 91 20 05 	lds	r25, 0x0520
    263e:	60 e0       	ldi	r22, 0x00	; 0
    2640:	70 e0       	ldi	r23, 0x00	; 0
    2642:	40 e0       	ldi	r20, 0x00	; 0
    2644:	50 e0       	ldi	r21, 0x00	; 0
    2646:	20 e0       	ldi	r18, 0x00	; 0
    2648:	0e 94 cb 1b 	call	0x3796	; 0x3796 <xQueueGenericSend>
		}
		vTaskDelay(1000);
    264c:	88 ee       	ldi	r24, 0xE8	; 232
    264e:	93 e0       	ldi	r25, 0x03	; 3
    2650:	0e 94 67 21 	call	0x42ce	; 0x42ce <vTaskDelay>
    2654:	df cf       	rjmp	.-66     	; 0x2614 <lcd1+0xe>

00002656 <lcd2>:
	}
}
void lcd2(void *Copy_pvSt)
{
    2656:	df 93       	push	r29
    2658:	cf 93       	push	r28
    265a:	00 d0       	rcall	.+0      	; 0x265c <lcd2+0x6>
    265c:	cd b7       	in	r28, 0x3d	; 61
    265e:	de b7       	in	r29, 0x3e	; 62
    2660:	9a 83       	std	Y+2, r25	; 0x02
    2662:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(LCDSem,0)==pdPASS)
    2664:	80 91 1f 05 	lds	r24, 0x051F
    2668:	90 91 20 05 	lds	r25, 0x0520
    266c:	60 e0       	ldi	r22, 0x00	; 0
    266e:	70 e0       	ldi	r23, 0x00	; 0
    2670:	40 e0       	ldi	r20, 0x00	; 0
    2672:	50 e0       	ldi	r21, 0x00	; 0
    2674:	20 e0       	ldi	r18, 0x00	; 0
    2676:	0e 94 b6 1c 	call	0x396c	; 0x396c <xQueueGenericReceive>
    267a:	81 30       	cpi	r24, 0x01	; 1
    267c:	79 f4       	brne	.+30     	; 0x269c <lcd2+0x46>
		{
			CLCD_voidSendString("I'm task2");
    267e:	8a e6       	ldi	r24, 0x6A	; 106
    2680:	90 e0       	ldi	r25, 0x00	; 0
    2682:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <CLCD_voidSendString>
			xSemaphoreGive(LCDSem);
    2686:	80 91 1f 05 	lds	r24, 0x051F
    268a:	90 91 20 05 	lds	r25, 0x0520
    268e:	60 e0       	ldi	r22, 0x00	; 0
    2690:	70 e0       	ldi	r23, 0x00	; 0
    2692:	40 e0       	ldi	r20, 0x00	; 0
    2694:	50 e0       	ldi	r21, 0x00	; 0
    2696:	20 e0       	ldi	r18, 0x00	; 0
    2698:	0e 94 cb 1b 	call	0x3796	; 0x3796 <xQueueGenericSend>
		}
		vTaskDelay(1000);
    269c:	88 ee       	ldi	r24, 0xE8	; 232
    269e:	93 e0       	ldi	r25, 0x03	; 3
    26a0:	0e 94 67 21 	call	0x42ce	; 0x42ce <vTaskDelay>
    26a4:	df cf       	rjmp	.-66     	; 0x2664 <lcd2+0xe>

000026a6 <SW1>:
	}
}


void SW1(void *Copy_pvSt)
{
    26a6:	df 93       	push	r29
    26a8:	cf 93       	push	r28
    26aa:	00 d0       	rcall	.+0      	; 0x26ac <SW1+0x6>
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
    26b0:	9a 83       	std	Y+2, r25	; 0x02
    26b2:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		DIO_u8GetPinValue(DIO_PORTB,DIO_PIN1,&SWState);
    26b4:	23 e9       	ldi	r18, 0x93	; 147
    26b6:	30 e0       	ldi	r19, 0x00	; 0
    26b8:	81 e0       	ldi	r24, 0x01	; 1
    26ba:	61 e0       	ldi	r22, 0x01	; 1
    26bc:	a9 01       	movw	r20, r18
    26be:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <DIO_u8GetPinValue>
		if(SWState == 0)
    26c2:	80 91 93 00 	lds	r24, 0x0093
    26c6:	88 23       	and	r24, r24
    26c8:	61 f4       	brne	.+24     	; 0x26e2 <SW1+0x3c>
		{
			xSemaphoreGive(SWSem);
    26ca:	80 91 21 05 	lds	r24, 0x0521
    26ce:	90 91 22 05 	lds	r25, 0x0522
    26d2:	60 e0       	ldi	r22, 0x00	; 0
    26d4:	70 e0       	ldi	r23, 0x00	; 0
    26d6:	40 e0       	ldi	r20, 0x00	; 0
    26d8:	50 e0       	ldi	r21, 0x00	; 0
    26da:	20 e0       	ldi	r18, 0x00	; 0
    26dc:	0e 94 cb 1b 	call	0x3796	; 0x3796 <xQueueGenericSend>
    26e0:	0b c0       	rjmp	.+22     	; 0x26f8 <SW1+0x52>
		}
		else
		{
			xSemaphoreTake(SWSem,0);
    26e2:	80 91 21 05 	lds	r24, 0x0521
    26e6:	90 91 22 05 	lds	r25, 0x0522
    26ea:	60 e0       	ldi	r22, 0x00	; 0
    26ec:	70 e0       	ldi	r23, 0x00	; 0
    26ee:	40 e0       	ldi	r20, 0x00	; 0
    26f0:	50 e0       	ldi	r21, 0x00	; 0
    26f2:	20 e0       	ldi	r18, 0x00	; 0
    26f4:	0e 94 b6 1c 	call	0x396c	; 0x396c <xQueueGenericReceive>
		}
		vTaskDelay(200);
    26f8:	88 ec       	ldi	r24, 0xC8	; 200
    26fa:	90 e0       	ldi	r25, 0x00	; 0
    26fc:	0e 94 67 21 	call	0x42ce	; 0x42ce <vTaskDelay>
    2700:	d9 cf       	rjmp	.-78     	; 0x26b4 <SW1+0xe>

00002702 <Led4Tog>:
	}

}
void Led4Tog(void *Copy_pvSt)
{
    2702:	df 93       	push	r29
    2704:	cf 93       	push	r28
    2706:	00 d0       	rcall	.+0      	; 0x2708 <Led4Tog+0x6>
    2708:	cd b7       	in	r28, 0x3d	; 61
    270a:	de b7       	in	r29, 0x3e	; 62
    270c:	9a 83       	std	Y+2, r25	; 0x02
    270e:	89 83       	std	Y+1, r24	; 0x01
	//LED_u8TogLed(&led[2]);
	static u8 Local_u8State = 0;
	while(1)
	{
		if(xSemaphoreTake(SWSem,0)==pdPASS)
    2710:	80 91 21 05 	lds	r24, 0x0521
    2714:	90 91 22 05 	lds	r25, 0x0522
    2718:	60 e0       	ldi	r22, 0x00	; 0
    271a:	70 e0       	ldi	r23, 0x00	; 0
    271c:	40 e0       	ldi	r20, 0x00	; 0
    271e:	50 e0       	ldi	r21, 0x00	; 0
    2720:	20 e0       	ldi	r18, 0x00	; 0
    2722:	0e 94 b6 1c 	call	0x396c	; 0x396c <xQueueGenericReceive>
    2726:	81 30       	cpi	r24, 0x01	; 1
    2728:	c1 f4       	brne	.+48     	; 0x275a <Led4Tog+0x58>
		{
			TOG_BIT(Local_u8State,0);
    272a:	90 91 97 00 	lds	r25, 0x0097
    272e:	81 e0       	ldi	r24, 0x01	; 1
    2730:	89 27       	eor	r24, r25
    2732:	80 93 97 00 	sts	0x0097, r24
			DIO_u8SetPinValue(DIO_PORTA,DIO_PIN7,Local_u8State);
    2736:	90 91 97 00 	lds	r25, 0x0097
    273a:	80 e0       	ldi	r24, 0x00	; 0
    273c:	67 e0       	ldi	r22, 0x07	; 7
    273e:	49 2f       	mov	r20, r25
    2740:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <DIO_u8SetPinValue>
			xSemaphoreGive(SWSem);
    2744:	80 91 21 05 	lds	r24, 0x0521
    2748:	90 91 22 05 	lds	r25, 0x0522
    274c:	60 e0       	ldi	r22, 0x00	; 0
    274e:	70 e0       	ldi	r23, 0x00	; 0
    2750:	40 e0       	ldi	r20, 0x00	; 0
    2752:	50 e0       	ldi	r21, 0x00	; 0
    2754:	20 e0       	ldi	r18, 0x00	; 0
    2756:	0e 94 cb 1b 	call	0x3796	; 0x3796 <xQueueGenericSend>
		}
		vTaskDelay(200);
    275a:	88 ec       	ldi	r24, 0xC8	; 200
    275c:	90 e0       	ldi	r25, 0x00	; 0
    275e:	0e 94 67 21 	call	0x42ce	; 0x42ce <vTaskDelay>
    2762:	d6 cf       	rjmp	.-84     	; 0x2710 <Led4Tog+0xe>

00002764 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2764:	df 93       	push	r29
    2766:	cf 93       	push	r28
    2768:	cd b7       	in	r28, 0x3d	; 61
    276a:	de b7       	in	r29, 0x3e	; 62
    276c:	27 97       	sbiw	r28, 0x07	; 7
    276e:	0f b6       	in	r0, 0x3f	; 63
    2770:	f8 94       	cli
    2772:	de bf       	out	0x3e, r29	; 62
    2774:	0f be       	out	0x3f, r0	; 63
    2776:	cd bf       	out	0x3d, r28	; 61
    2778:	9d 83       	std	Y+5, r25	; 0x05
    277a:	8c 83       	std	Y+4, r24	; 0x04
    277c:	6e 83       	std	Y+6, r22	; 0x06
    277e:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2780:	8a e1       	ldi	r24, 0x1A	; 26
    2782:	90 e0       	ldi	r25, 0x00	; 0
    2784:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <pvPortMalloc>
    2788:	9a 83       	std	Y+2, r25	; 0x02
    278a:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    278c:	89 81       	ldd	r24, Y+1	; 0x01
    278e:	9a 81       	ldd	r25, Y+2	; 0x02
    2790:	00 97       	sbiw	r24, 0x00	; 0
    2792:	09 f4       	brne	.+2      	; 0x2796 <xCoRoutineCreate+0x32>
    2794:	6f c0       	rjmp	.+222    	; 0x2874 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2796:	80 91 98 00 	lds	r24, 0x0098
    279a:	90 91 99 00 	lds	r25, 0x0099
    279e:	00 97       	sbiw	r24, 0x00	; 0
    27a0:	41 f4       	brne	.+16     	; 0x27b2 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    27a2:	89 81       	ldd	r24, Y+1	; 0x01
    27a4:	9a 81       	ldd	r25, Y+2	; 0x02
    27a6:	90 93 99 00 	sts	0x0099, r25
    27aa:	80 93 98 00 	sts	0x0098, r24
			prvInitialiseCoRoutineLists();
    27ae:	0e 94 19 16 	call	0x2c32	; 0x2c32 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    27b2:	8e 81       	ldd	r24, Y+6	; 0x06
    27b4:	82 30       	cpi	r24, 0x02	; 2
    27b6:	10 f0       	brcs	.+4      	; 0x27bc <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    27bc:	e9 81       	ldd	r30, Y+1	; 0x01
    27be:	fa 81       	ldd	r31, Y+2	; 0x02
    27c0:	11 8e       	std	Z+25, r1	; 0x19
    27c2:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    27c4:	e9 81       	ldd	r30, Y+1	; 0x01
    27c6:	fa 81       	ldd	r31, Y+2	; 0x02
    27c8:	8e 81       	ldd	r24, Y+6	; 0x06
    27ca:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    27cc:	e9 81       	ldd	r30, Y+1	; 0x01
    27ce:	fa 81       	ldd	r31, Y+2	; 0x02
    27d0:	8f 81       	ldd	r24, Y+7	; 0x07
    27d2:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    27d4:	e9 81       	ldd	r30, Y+1	; 0x01
    27d6:	fa 81       	ldd	r31, Y+2	; 0x02
    27d8:	8c 81       	ldd	r24, Y+4	; 0x04
    27da:	9d 81       	ldd	r25, Y+5	; 0x05
    27dc:	91 83       	std	Z+1, r25	; 0x01
    27de:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    27e0:	89 81       	ldd	r24, Y+1	; 0x01
    27e2:	9a 81       	ldd	r25, Y+2	; 0x02
    27e4:	02 96       	adiw	r24, 0x02	; 2
    27e6:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    27ea:	89 81       	ldd	r24, Y+1	; 0x01
    27ec:	9a 81       	ldd	r25, Y+2	; 0x02
    27ee:	0c 96       	adiw	r24, 0x0c	; 12
    27f0:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    27f4:	e9 81       	ldd	r30, Y+1	; 0x01
    27f6:	fa 81       	ldd	r31, Y+2	; 0x02
    27f8:	89 81       	ldd	r24, Y+1	; 0x01
    27fa:	9a 81       	ldd	r25, Y+2	; 0x02
    27fc:	91 87       	std	Z+9, r25	; 0x09
    27fe:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2800:	e9 81       	ldd	r30, Y+1	; 0x01
    2802:	fa 81       	ldd	r31, Y+2	; 0x02
    2804:	89 81       	ldd	r24, Y+1	; 0x01
    2806:	9a 81       	ldd	r25, Y+2	; 0x02
    2808:	93 8b       	std	Z+19, r25	; 0x13
    280a:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    280c:	8e 81       	ldd	r24, Y+6	; 0x06
    280e:	28 2f       	mov	r18, r24
    2810:	30 e0       	ldi	r19, 0x00	; 0
    2812:	84 e0       	ldi	r24, 0x04	; 4
    2814:	90 e0       	ldi	r25, 0x00	; 0
    2816:	82 1b       	sub	r24, r18
    2818:	93 0b       	sbc	r25, r19
    281a:	e9 81       	ldd	r30, Y+1	; 0x01
    281c:	fa 81       	ldd	r31, Y+2	; 0x02
    281e:	95 87       	std	Z+13, r25	; 0x0d
    2820:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2822:	e9 81       	ldd	r30, Y+1	; 0x01
    2824:	fa 81       	ldd	r31, Y+2	; 0x02
    2826:	96 89       	ldd	r25, Z+22	; 0x16
    2828:	80 91 9a 00 	lds	r24, 0x009A
    282c:	89 17       	cp	r24, r25
    282e:	28 f4       	brcc	.+10     	; 0x283a <xCoRoutineCreate+0xd6>
    2830:	e9 81       	ldd	r30, Y+1	; 0x01
    2832:	fa 81       	ldd	r31, Y+2	; 0x02
    2834:	86 89       	ldd	r24, Z+22	; 0x16
    2836:	80 93 9a 00 	sts	0x009A, r24
    283a:	e9 81       	ldd	r30, Y+1	; 0x01
    283c:	fa 81       	ldd	r31, Y+2	; 0x02
    283e:	86 89       	ldd	r24, Z+22	; 0x16
    2840:	28 2f       	mov	r18, r24
    2842:	30 e0       	ldi	r19, 0x00	; 0
    2844:	c9 01       	movw	r24, r18
    2846:	88 0f       	add	r24, r24
    2848:	99 1f       	adc	r25, r25
    284a:	88 0f       	add	r24, r24
    284c:	99 1f       	adc	r25, r25
    284e:	88 0f       	add	r24, r24
    2850:	99 1f       	adc	r25, r25
    2852:	82 0f       	add	r24, r18
    2854:	93 1f       	adc	r25, r19
    2856:	ac 01       	movw	r20, r24
    2858:	4f 55       	subi	r20, 0x5F	; 95
    285a:	5f 4f       	sbci	r21, 0xFF	; 255
    285c:	89 81       	ldd	r24, Y+1	; 0x01
    285e:	9a 81       	ldd	r25, Y+2	; 0x02
    2860:	9c 01       	movw	r18, r24
    2862:	2e 5f       	subi	r18, 0xFE	; 254
    2864:	3f 4f       	sbci	r19, 0xFF	; 255
    2866:	ca 01       	movw	r24, r20
    2868:	b9 01       	movw	r22, r18
    286a:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>

		xReturn = pdPASS;
    286e:	81 e0       	ldi	r24, 0x01	; 1
    2870:	8b 83       	std	Y+3, r24	; 0x03
    2872:	02 c0       	rjmp	.+4      	; 0x2878 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2874:	8f ef       	ldi	r24, 0xFF	; 255
    2876:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    2878:	8b 81       	ldd	r24, Y+3	; 0x03
}
    287a:	27 96       	adiw	r28, 0x07	; 7
    287c:	0f b6       	in	r0, 0x3f	; 63
    287e:	f8 94       	cli
    2880:	de bf       	out	0x3e, r29	; 62
    2882:	0f be       	out	0x3f, r0	; 63
    2884:	cd bf       	out	0x3d, r28	; 61
    2886:	cf 91       	pop	r28
    2888:	df 91       	pop	r29
    288a:	08 95       	ret

0000288c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    288c:	df 93       	push	r29
    288e:	cf 93       	push	r28
    2890:	00 d0       	rcall	.+0      	; 0x2892 <vCoRoutineAddToDelayedList+0x6>
    2892:	00 d0       	rcall	.+0      	; 0x2894 <vCoRoutineAddToDelayedList+0x8>
    2894:	00 d0       	rcall	.+0      	; 0x2896 <vCoRoutineAddToDelayedList+0xa>
    2896:	cd b7       	in	r28, 0x3d	; 61
    2898:	de b7       	in	r29, 0x3e	; 62
    289a:	9c 83       	std	Y+4, r25	; 0x04
    289c:	8b 83       	std	Y+3, r24	; 0x03
    289e:	7e 83       	std	Y+6, r23	; 0x06
    28a0:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    28a2:	20 91 9b 00 	lds	r18, 0x009B
    28a6:	30 91 9c 00 	lds	r19, 0x009C
    28aa:	8b 81       	ldd	r24, Y+3	; 0x03
    28ac:	9c 81       	ldd	r25, Y+4	; 0x04
    28ae:	82 0f       	add	r24, r18
    28b0:	93 1f       	adc	r25, r19
    28b2:	9a 83       	std	Y+2, r25	; 0x02
    28b4:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28b6:	80 91 98 00 	lds	r24, 0x0098
    28ba:	90 91 99 00 	lds	r25, 0x0099
    28be:	02 96       	adiw	r24, 0x02	; 2
    28c0:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    28c4:	e0 91 98 00 	lds	r30, 0x0098
    28c8:	f0 91 99 00 	lds	r31, 0x0099
    28cc:	89 81       	ldd	r24, Y+1	; 0x01
    28ce:	9a 81       	ldd	r25, Y+2	; 0x02
    28d0:	93 83       	std	Z+3, r25	; 0x03
    28d2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    28d4:	20 91 9b 00 	lds	r18, 0x009B
    28d8:	30 91 9c 00 	lds	r19, 0x009C
    28dc:	89 81       	ldd	r24, Y+1	; 0x01
    28de:	9a 81       	ldd	r25, Y+2	; 0x02
    28e0:	82 17       	cp	r24, r18
    28e2:	93 07       	cpc	r25, r19
    28e4:	70 f4       	brcc	.+28     	; 0x2902 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28e6:	80 91 c7 00 	lds	r24, 0x00C7
    28ea:	90 91 c8 00 	lds	r25, 0x00C8
    28ee:	20 91 98 00 	lds	r18, 0x0098
    28f2:	30 91 99 00 	lds	r19, 0x0099
    28f6:	2e 5f       	subi	r18, 0xFE	; 254
    28f8:	3f 4f       	sbci	r19, 0xFF	; 255
    28fa:	b9 01       	movw	r22, r18
    28fc:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vListInsert>
    2900:	0d c0       	rjmp	.+26     	; 0x291c <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2902:	80 91 c5 00 	lds	r24, 0x00C5
    2906:	90 91 c6 00 	lds	r25, 0x00C6
    290a:	20 91 98 00 	lds	r18, 0x0098
    290e:	30 91 99 00 	lds	r19, 0x0099
    2912:	2e 5f       	subi	r18, 0xFE	; 254
    2914:	3f 4f       	sbci	r19, 0xFF	; 255
    2916:	b9 01       	movw	r22, r18
    2918:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vListInsert>
	}

	if( pxEventList )
    291c:	8d 81       	ldd	r24, Y+5	; 0x05
    291e:	9e 81       	ldd	r25, Y+6	; 0x06
    2920:	00 97       	sbiw	r24, 0x00	; 0
    2922:	61 f0       	breq	.+24     	; 0x293c <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2924:	80 91 98 00 	lds	r24, 0x0098
    2928:	90 91 99 00 	lds	r25, 0x0099
    292c:	9c 01       	movw	r18, r24
    292e:	24 5f       	subi	r18, 0xF4	; 244
    2930:	3f 4f       	sbci	r19, 0xFF	; 255
    2932:	8d 81       	ldd	r24, Y+5	; 0x05
    2934:	9e 81       	ldd	r25, Y+6	; 0x06
    2936:	b9 01       	movw	r22, r18
    2938:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vListInsert>
	}
}
    293c:	26 96       	adiw	r28, 0x06	; 6
    293e:	0f b6       	in	r0, 0x3f	; 63
    2940:	f8 94       	cli
    2942:	de bf       	out	0x3e, r29	; 62
    2944:	0f be       	out	0x3f, r0	; 63
    2946:	cd bf       	out	0x3d, r28	; 61
    2948:	cf 91       	pop	r28
    294a:	df 91       	pop	r29
    294c:	08 95       	ret

0000294e <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    294e:	df 93       	push	r29
    2950:	cf 93       	push	r28
    2952:	00 d0       	rcall	.+0      	; 0x2954 <prvCheckPendingReadyList+0x6>
    2954:	cd b7       	in	r28, 0x3d	; 61
    2956:	de b7       	in	r29, 0x3e	; 62
    2958:	3a c0       	rjmp	.+116    	; 0x29ce <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    295a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    295c:	e0 91 ce 00 	lds	r30, 0x00CE
    2960:	f0 91 cf 00 	lds	r31, 0x00CF
    2964:	86 81       	ldd	r24, Z+6	; 0x06
    2966:	97 81       	ldd	r25, Z+7	; 0x07
    2968:	9a 83       	std	Y+2, r25	; 0x02
    296a:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    296c:	89 81       	ldd	r24, Y+1	; 0x01
    296e:	9a 81       	ldd	r25, Y+2	; 0x02
    2970:	0c 96       	adiw	r24, 0x0c	; 12
    2972:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2976:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2978:	89 81       	ldd	r24, Y+1	; 0x01
    297a:	9a 81       	ldd	r25, Y+2	; 0x02
    297c:	02 96       	adiw	r24, 0x02	; 2
    297e:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2982:	e9 81       	ldd	r30, Y+1	; 0x01
    2984:	fa 81       	ldd	r31, Y+2	; 0x02
    2986:	96 89       	ldd	r25, Z+22	; 0x16
    2988:	80 91 9a 00 	lds	r24, 0x009A
    298c:	89 17       	cp	r24, r25
    298e:	28 f4       	brcc	.+10     	; 0x299a <prvCheckPendingReadyList+0x4c>
    2990:	e9 81       	ldd	r30, Y+1	; 0x01
    2992:	fa 81       	ldd	r31, Y+2	; 0x02
    2994:	86 89       	ldd	r24, Z+22	; 0x16
    2996:	80 93 9a 00 	sts	0x009A, r24
    299a:	e9 81       	ldd	r30, Y+1	; 0x01
    299c:	fa 81       	ldd	r31, Y+2	; 0x02
    299e:	86 89       	ldd	r24, Z+22	; 0x16
    29a0:	28 2f       	mov	r18, r24
    29a2:	30 e0       	ldi	r19, 0x00	; 0
    29a4:	c9 01       	movw	r24, r18
    29a6:	88 0f       	add	r24, r24
    29a8:	99 1f       	adc	r25, r25
    29aa:	88 0f       	add	r24, r24
    29ac:	99 1f       	adc	r25, r25
    29ae:	88 0f       	add	r24, r24
    29b0:	99 1f       	adc	r25, r25
    29b2:	82 0f       	add	r24, r18
    29b4:	93 1f       	adc	r25, r19
    29b6:	ac 01       	movw	r20, r24
    29b8:	4f 55       	subi	r20, 0x5F	; 95
    29ba:	5f 4f       	sbci	r21, 0xFF	; 255
    29bc:	89 81       	ldd	r24, Y+1	; 0x01
    29be:	9a 81       	ldd	r25, Y+2	; 0x02
    29c0:	9c 01       	movw	r18, r24
    29c2:	2e 5f       	subi	r18, 0xFE	; 254
    29c4:	3f 4f       	sbci	r19, 0xFF	; 255
    29c6:	ca 01       	movw	r24, r20
    29c8:	b9 01       	movw	r22, r18
    29ca:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    29ce:	80 91 c9 00 	lds	r24, 0x00C9
    29d2:	88 23       	and	r24, r24
    29d4:	09 f0       	breq	.+2      	; 0x29d8 <prvCheckPendingReadyList+0x8a>
    29d6:	c1 cf       	rjmp	.-126    	; 0x295a <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    29d8:	0f 90       	pop	r0
    29da:	0f 90       	pop	r0
    29dc:	cf 91       	pop	r28
    29de:	df 91       	pop	r29
    29e0:	08 95       	ret

000029e2 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    29e2:	df 93       	push	r29
    29e4:	cf 93       	push	r28
    29e6:	00 d0       	rcall	.+0      	; 0x29e8 <prvCheckDelayedList+0x6>
    29e8:	00 d0       	rcall	.+0      	; 0x29ea <prvCheckDelayedList+0x8>
    29ea:	cd b7       	in	r28, 0x3d	; 61
    29ec:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    29ee:	0e 94 d4 23 	call	0x47a8	; 0x47a8 <xTaskGetTickCount>
    29f2:	20 91 9d 00 	lds	r18, 0x009D
    29f6:	30 91 9e 00 	lds	r19, 0x009E
    29fa:	82 1b       	sub	r24, r18
    29fc:	93 0b       	sbc	r25, r19
    29fe:	90 93 a0 00 	sts	0x00A0, r25
    2a02:	80 93 9f 00 	sts	0x009F, r24
    2a06:	85 c0       	rjmp	.+266    	; 0x2b12 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2a08:	80 91 9b 00 	lds	r24, 0x009B
    2a0c:	90 91 9c 00 	lds	r25, 0x009C
    2a10:	01 96       	adiw	r24, 0x01	; 1
    2a12:	90 93 9c 00 	sts	0x009C, r25
    2a16:	80 93 9b 00 	sts	0x009B, r24
		xPassedTicks--;
    2a1a:	80 91 9f 00 	lds	r24, 0x009F
    2a1e:	90 91 a0 00 	lds	r25, 0x00A0
    2a22:	01 97       	sbiw	r24, 0x01	; 1
    2a24:	90 93 a0 00 	sts	0x00A0, r25
    2a28:	80 93 9f 00 	sts	0x009F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2a2c:	80 91 9b 00 	lds	r24, 0x009B
    2a30:	90 91 9c 00 	lds	r25, 0x009C
    2a34:	00 97       	sbiw	r24, 0x00	; 0
    2a36:	09 f0       	breq	.+2      	; 0x2a3a <prvCheckDelayedList+0x58>
    2a38:	64 c0       	rjmp	.+200    	; 0x2b02 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2a3a:	80 91 c5 00 	lds	r24, 0x00C5
    2a3e:	90 91 c6 00 	lds	r25, 0x00C6
    2a42:	9a 83       	std	Y+2, r25	; 0x02
    2a44:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2a46:	80 91 c7 00 	lds	r24, 0x00C7
    2a4a:	90 91 c8 00 	lds	r25, 0x00C8
    2a4e:	90 93 c6 00 	sts	0x00C6, r25
    2a52:	80 93 c5 00 	sts	0x00C5, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2a56:	89 81       	ldd	r24, Y+1	; 0x01
    2a58:	9a 81       	ldd	r25, Y+2	; 0x02
    2a5a:	90 93 c8 00 	sts	0x00C8, r25
    2a5e:	80 93 c7 00 	sts	0x00C7, r24
    2a62:	4f c0       	rjmp	.+158    	; 0x2b02 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2a64:	e0 91 c5 00 	lds	r30, 0x00C5
    2a68:	f0 91 c6 00 	lds	r31, 0x00C6
    2a6c:	05 80       	ldd	r0, Z+5	; 0x05
    2a6e:	f6 81       	ldd	r31, Z+6	; 0x06
    2a70:	e0 2d       	mov	r30, r0
    2a72:	86 81       	ldd	r24, Z+6	; 0x06
    2a74:	97 81       	ldd	r25, Z+7	; 0x07
    2a76:	9c 83       	std	Y+4, r25	; 0x04
    2a78:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2a7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a7e:	22 81       	ldd	r18, Z+2	; 0x02
    2a80:	33 81       	ldd	r19, Z+3	; 0x03
    2a82:	80 91 9b 00 	lds	r24, 0x009B
    2a86:	90 91 9c 00 	lds	r25, 0x009C
    2a8a:	82 17       	cp	r24, r18
    2a8c:	93 07       	cpc	r25, r19
    2a8e:	08 f4       	brcc	.+2      	; 0x2a92 <prvCheckDelayedList+0xb0>
    2a90:	40 c0       	rjmp	.+128    	; 0x2b12 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2a92:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2a94:	8b 81       	ldd	r24, Y+3	; 0x03
    2a96:	9c 81       	ldd	r25, Y+4	; 0x04
    2a98:	02 96       	adiw	r24, 0x02	; 2
    2a9a:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2a9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa0:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa2:	84 89       	ldd	r24, Z+20	; 0x14
    2aa4:	95 89       	ldd	r25, Z+21	; 0x15
    2aa6:	00 97       	sbiw	r24, 0x00	; 0
    2aa8:	29 f0       	breq	.+10     	; 0x2ab4 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    2aac:	9c 81       	ldd	r25, Y+4	; 0x04
    2aae:	0c 96       	adiw	r24, 0x0c	; 12
    2ab0:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2ab4:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2ab6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aba:	96 89       	ldd	r25, Z+22	; 0x16
    2abc:	80 91 9a 00 	lds	r24, 0x009A
    2ac0:	89 17       	cp	r24, r25
    2ac2:	28 f4       	brcc	.+10     	; 0x2ace <prvCheckDelayedList+0xec>
    2ac4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac8:	86 89       	ldd	r24, Z+22	; 0x16
    2aca:	80 93 9a 00 	sts	0x009A, r24
    2ace:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad2:	86 89       	ldd	r24, Z+22	; 0x16
    2ad4:	28 2f       	mov	r18, r24
    2ad6:	30 e0       	ldi	r19, 0x00	; 0
    2ad8:	c9 01       	movw	r24, r18
    2ada:	88 0f       	add	r24, r24
    2adc:	99 1f       	adc	r25, r25
    2ade:	88 0f       	add	r24, r24
    2ae0:	99 1f       	adc	r25, r25
    2ae2:	88 0f       	add	r24, r24
    2ae4:	99 1f       	adc	r25, r25
    2ae6:	82 0f       	add	r24, r18
    2ae8:	93 1f       	adc	r25, r19
    2aea:	ac 01       	movw	r20, r24
    2aec:	4f 55       	subi	r20, 0x5F	; 95
    2aee:	5f 4f       	sbci	r21, 0xFF	; 255
    2af0:	8b 81       	ldd	r24, Y+3	; 0x03
    2af2:	9c 81       	ldd	r25, Y+4	; 0x04
    2af4:	9c 01       	movw	r18, r24
    2af6:	2e 5f       	subi	r18, 0xFE	; 254
    2af8:	3f 4f       	sbci	r19, 0xFF	; 255
    2afa:	ca 01       	movw	r24, r20
    2afc:	b9 01       	movw	r22, r18
    2afe:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2b02:	e0 91 c5 00 	lds	r30, 0x00C5
    2b06:	f0 91 c6 00 	lds	r31, 0x00C6
    2b0a:	80 81       	ld	r24, Z
    2b0c:	88 23       	and	r24, r24
    2b0e:	09 f0       	breq	.+2      	; 0x2b12 <prvCheckDelayedList+0x130>
    2b10:	a9 cf       	rjmp	.-174    	; 0x2a64 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2b12:	80 91 9f 00 	lds	r24, 0x009F
    2b16:	90 91 a0 00 	lds	r25, 0x00A0
    2b1a:	00 97       	sbiw	r24, 0x00	; 0
    2b1c:	09 f0       	breq	.+2      	; 0x2b20 <prvCheckDelayedList+0x13e>
    2b1e:	74 cf       	rjmp	.-280    	; 0x2a08 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2b20:	80 91 9b 00 	lds	r24, 0x009B
    2b24:	90 91 9c 00 	lds	r25, 0x009C
    2b28:	90 93 9e 00 	sts	0x009E, r25
    2b2c:	80 93 9d 00 	sts	0x009D, r24
}
    2b30:	0f 90       	pop	r0
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	0f 90       	pop	r0
    2b38:	cf 91       	pop	r28
    2b3a:	df 91       	pop	r29
    2b3c:	08 95       	ret

00002b3e <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2b3e:	df 93       	push	r29
    2b40:	cf 93       	push	r28
    2b42:	00 d0       	rcall	.+0      	; 0x2b44 <vCoRoutineSchedule+0x6>
    2b44:	cd b7       	in	r28, 0x3d	; 61
    2b46:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2b48:	0e 94 a7 14 	call	0x294e	; 0x294e <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2b4c:	0e 94 f1 14 	call	0x29e2	; 0x29e2 <prvCheckDelayedList>
    2b50:	0a c0       	rjmp	.+20     	; 0x2b66 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2b52:	80 91 9a 00 	lds	r24, 0x009A
    2b56:	88 23       	and	r24, r24
    2b58:	09 f4       	brne	.+2      	; 0x2b5c <vCoRoutineSchedule+0x1e>
    2b5a:	66 c0       	rjmp	.+204    	; 0x2c28 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2b5c:	80 91 9a 00 	lds	r24, 0x009A
    2b60:	81 50       	subi	r24, 0x01	; 1
    2b62:	80 93 9a 00 	sts	0x009A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b66:	80 91 9a 00 	lds	r24, 0x009A
    2b6a:	28 2f       	mov	r18, r24
    2b6c:	30 e0       	ldi	r19, 0x00	; 0
    2b6e:	c9 01       	movw	r24, r18
    2b70:	88 0f       	add	r24, r24
    2b72:	99 1f       	adc	r25, r25
    2b74:	88 0f       	add	r24, r24
    2b76:	99 1f       	adc	r25, r25
    2b78:	88 0f       	add	r24, r24
    2b7a:	99 1f       	adc	r25, r25
    2b7c:	82 0f       	add	r24, r18
    2b7e:	93 1f       	adc	r25, r19
    2b80:	fc 01       	movw	r30, r24
    2b82:	ef 55       	subi	r30, 0x5F	; 95
    2b84:	ff 4f       	sbci	r31, 0xFF	; 255
    2b86:	80 81       	ld	r24, Z
    2b88:	88 23       	and	r24, r24
    2b8a:	19 f3       	breq	.-58     	; 0x2b52 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2b8c:	80 91 9a 00 	lds	r24, 0x009A
    2b90:	28 2f       	mov	r18, r24
    2b92:	30 e0       	ldi	r19, 0x00	; 0
    2b94:	c9 01       	movw	r24, r18
    2b96:	88 0f       	add	r24, r24
    2b98:	99 1f       	adc	r25, r25
    2b9a:	88 0f       	add	r24, r24
    2b9c:	99 1f       	adc	r25, r25
    2b9e:	88 0f       	add	r24, r24
    2ba0:	99 1f       	adc	r25, r25
    2ba2:	82 0f       	add	r24, r18
    2ba4:	93 1f       	adc	r25, r19
    2ba6:	8f 55       	subi	r24, 0x5F	; 95
    2ba8:	9f 4f       	sbci	r25, 0xFF	; 255
    2baa:	9a 83       	std	Y+2, r25	; 0x02
    2bac:	89 83       	std	Y+1, r24	; 0x01
    2bae:	e9 81       	ldd	r30, Y+1	; 0x01
    2bb0:	fa 81       	ldd	r31, Y+2	; 0x02
    2bb2:	01 80       	ldd	r0, Z+1	; 0x01
    2bb4:	f2 81       	ldd	r31, Z+2	; 0x02
    2bb6:	e0 2d       	mov	r30, r0
    2bb8:	82 81       	ldd	r24, Z+2	; 0x02
    2bba:	93 81       	ldd	r25, Z+3	; 0x03
    2bbc:	e9 81       	ldd	r30, Y+1	; 0x01
    2bbe:	fa 81       	ldd	r31, Y+2	; 0x02
    2bc0:	92 83       	std	Z+2, r25	; 0x02
    2bc2:	81 83       	std	Z+1, r24	; 0x01
    2bc4:	e9 81       	ldd	r30, Y+1	; 0x01
    2bc6:	fa 81       	ldd	r31, Y+2	; 0x02
    2bc8:	21 81       	ldd	r18, Z+1	; 0x01
    2bca:	32 81       	ldd	r19, Z+2	; 0x02
    2bcc:	89 81       	ldd	r24, Y+1	; 0x01
    2bce:	9a 81       	ldd	r25, Y+2	; 0x02
    2bd0:	03 96       	adiw	r24, 0x03	; 3
    2bd2:	28 17       	cp	r18, r24
    2bd4:	39 07       	cpc	r19, r25
    2bd6:	59 f4       	brne	.+22     	; 0x2bee <vCoRoutineSchedule+0xb0>
    2bd8:	e9 81       	ldd	r30, Y+1	; 0x01
    2bda:	fa 81       	ldd	r31, Y+2	; 0x02
    2bdc:	01 80       	ldd	r0, Z+1	; 0x01
    2bde:	f2 81       	ldd	r31, Z+2	; 0x02
    2be0:	e0 2d       	mov	r30, r0
    2be2:	82 81       	ldd	r24, Z+2	; 0x02
    2be4:	93 81       	ldd	r25, Z+3	; 0x03
    2be6:	e9 81       	ldd	r30, Y+1	; 0x01
    2be8:	fa 81       	ldd	r31, Y+2	; 0x02
    2bea:	92 83       	std	Z+2, r25	; 0x02
    2bec:	81 83       	std	Z+1, r24	; 0x01
    2bee:	e9 81       	ldd	r30, Y+1	; 0x01
    2bf0:	fa 81       	ldd	r31, Y+2	; 0x02
    2bf2:	01 80       	ldd	r0, Z+1	; 0x01
    2bf4:	f2 81       	ldd	r31, Z+2	; 0x02
    2bf6:	e0 2d       	mov	r30, r0
    2bf8:	86 81       	ldd	r24, Z+6	; 0x06
    2bfa:	97 81       	ldd	r25, Z+7	; 0x07
    2bfc:	90 93 99 00 	sts	0x0099, r25
    2c00:	80 93 98 00 	sts	0x0098, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2c04:	e0 91 98 00 	lds	r30, 0x0098
    2c08:	f0 91 99 00 	lds	r31, 0x0099
    2c0c:	40 81       	ld	r20, Z
    2c0e:	51 81       	ldd	r21, Z+1	; 0x01
    2c10:	80 91 98 00 	lds	r24, 0x0098
    2c14:	90 91 99 00 	lds	r25, 0x0099
    2c18:	e0 91 98 00 	lds	r30, 0x0098
    2c1c:	f0 91 99 00 	lds	r31, 0x0099
    2c20:	27 89       	ldd	r18, Z+23	; 0x17
    2c22:	62 2f       	mov	r22, r18
    2c24:	fa 01       	movw	r30, r20
    2c26:	09 95       	icall

	return;
}
    2c28:	0f 90       	pop	r0
    2c2a:	0f 90       	pop	r0
    2c2c:	cf 91       	pop	r28
    2c2e:	df 91       	pop	r29
    2c30:	08 95       	ret

00002c32 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2c32:	df 93       	push	r29
    2c34:	cf 93       	push	r28
    2c36:	0f 92       	push	r0
    2c38:	cd b7       	in	r28, 0x3d	; 61
    2c3a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c3c:	19 82       	std	Y+1, r1	; 0x01
    2c3e:	13 c0       	rjmp	.+38     	; 0x2c66 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2c40:	89 81       	ldd	r24, Y+1	; 0x01
    2c42:	28 2f       	mov	r18, r24
    2c44:	30 e0       	ldi	r19, 0x00	; 0
    2c46:	c9 01       	movw	r24, r18
    2c48:	88 0f       	add	r24, r24
    2c4a:	99 1f       	adc	r25, r25
    2c4c:	88 0f       	add	r24, r24
    2c4e:	99 1f       	adc	r25, r25
    2c50:	88 0f       	add	r24, r24
    2c52:	99 1f       	adc	r25, r25
    2c54:	82 0f       	add	r24, r18
    2c56:	93 1f       	adc	r25, r19
    2c58:	8f 55       	subi	r24, 0x5F	; 95
    2c5a:	9f 4f       	sbci	r25, 0xFF	; 255
    2c5c:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c60:	89 81       	ldd	r24, Y+1	; 0x01
    2c62:	8f 5f       	subi	r24, 0xFF	; 255
    2c64:	89 83       	std	Y+1, r24	; 0x01
    2c66:	89 81       	ldd	r24, Y+1	; 0x01
    2c68:	82 30       	cpi	r24, 0x02	; 2
    2c6a:	50 f3       	brcs	.-44     	; 0x2c40 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2c6c:	83 eb       	ldi	r24, 0xB3	; 179
    2c6e:	90 e0       	ldi	r25, 0x00	; 0
    2c70:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2c74:	8c eb       	ldi	r24, 0xBC	; 188
    2c76:	90 e0       	ldi	r25, 0x00	; 0
    2c78:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2c7c:	89 ec       	ldi	r24, 0xC9	; 201
    2c7e:	90 e0       	ldi	r25, 0x00	; 0
    2c80:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2c84:	83 eb       	ldi	r24, 0xB3	; 179
    2c86:	90 e0       	ldi	r25, 0x00	; 0
    2c88:	90 93 c6 00 	sts	0x00C6, r25
    2c8c:	80 93 c5 00 	sts	0x00C5, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2c90:	8c eb       	ldi	r24, 0xBC	; 188
    2c92:	90 e0       	ldi	r25, 0x00	; 0
    2c94:	90 93 c8 00 	sts	0x00C8, r25
    2c98:	80 93 c7 00 	sts	0x00C7, r24
}
    2c9c:	0f 90       	pop	r0
    2c9e:	cf 91       	pop	r28
    2ca0:	df 91       	pop	r29
    2ca2:	08 95       	ret

00002ca4 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2ca4:	df 93       	push	r29
    2ca6:	cf 93       	push	r28
    2ca8:	00 d0       	rcall	.+0      	; 0x2caa <xCoRoutineRemoveFromEventList+0x6>
    2caa:	00 d0       	rcall	.+0      	; 0x2cac <xCoRoutineRemoveFromEventList+0x8>
    2cac:	0f 92       	push	r0
    2cae:	cd b7       	in	r28, 0x3d	; 61
    2cb0:	de b7       	in	r29, 0x3e	; 62
    2cb2:	9d 83       	std	Y+5, r25	; 0x05
    2cb4:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2cb6:	ec 81       	ldd	r30, Y+4	; 0x04
    2cb8:	fd 81       	ldd	r31, Y+5	; 0x05
    2cba:	05 80       	ldd	r0, Z+5	; 0x05
    2cbc:	f6 81       	ldd	r31, Z+6	; 0x06
    2cbe:	e0 2d       	mov	r30, r0
    2cc0:	86 81       	ldd	r24, Z+6	; 0x06
    2cc2:	97 81       	ldd	r25, Z+7	; 0x07
    2cc4:	9b 83       	std	Y+3, r25	; 0x03
    2cc6:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2cc8:	8a 81       	ldd	r24, Y+2	; 0x02
    2cca:	9b 81       	ldd	r25, Y+3	; 0x03
    2ccc:	0c 96       	adiw	r24, 0x0c	; 12
    2cce:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2cd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd4:	9b 81       	ldd	r25, Y+3	; 0x03
    2cd6:	9c 01       	movw	r18, r24
    2cd8:	24 5f       	subi	r18, 0xF4	; 244
    2cda:	3f 4f       	sbci	r19, 0xFF	; 255
    2cdc:	89 ec       	ldi	r24, 0xC9	; 201
    2cde:	90 e0       	ldi	r25, 0x00	; 0
    2ce0:	b9 01       	movw	r22, r18
    2ce2:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2ce6:	ea 81       	ldd	r30, Y+2	; 0x02
    2ce8:	fb 81       	ldd	r31, Y+3	; 0x03
    2cea:	96 89       	ldd	r25, Z+22	; 0x16
    2cec:	e0 91 98 00 	lds	r30, 0x0098
    2cf0:	f0 91 99 00 	lds	r31, 0x0099
    2cf4:	86 89       	ldd	r24, Z+22	; 0x16
    2cf6:	98 17       	cp	r25, r24
    2cf8:	18 f0       	brcs	.+6      	; 0x2d00 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2cfa:	81 e0       	ldi	r24, 0x01	; 1
    2cfc:	89 83       	std	Y+1, r24	; 0x01
    2cfe:	01 c0       	rjmp	.+2      	; 0x2d02 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2d00:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2d02:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d04:	0f 90       	pop	r0
    2d06:	0f 90       	pop	r0
    2d08:	0f 90       	pop	r0
    2d0a:	0f 90       	pop	r0
    2d0c:	0f 90       	pop	r0
    2d0e:	cf 91       	pop	r28
    2d10:	df 91       	pop	r29
    2d12:	08 95       	ret

00002d14 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2d14:	df 93       	push	r29
    2d16:	cf 93       	push	r28
    2d18:	00 d0       	rcall	.+0      	; 0x2d1a <pvPortMalloc+0x6>
    2d1a:	00 d0       	rcall	.+0      	; 0x2d1c <pvPortMalloc+0x8>
    2d1c:	cd b7       	in	r28, 0x3d	; 61
    2d1e:	de b7       	in	r29, 0x3e	; 62
    2d20:	9c 83       	std	Y+4, r25	; 0x04
    2d22:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2d24:	1a 82       	std	Y+2, r1	; 0x02
    2d26:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2d28:	0e 94 3e 23 	call	0x467c	; 0x467c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2d2c:	80 91 d2 00 	lds	r24, 0x00D2
    2d30:	90 91 d3 00 	lds	r25, 0x00D3
    2d34:	2b 81       	ldd	r18, Y+3	; 0x03
    2d36:	3c 81       	ldd	r19, Y+4	; 0x04
    2d38:	82 0f       	add	r24, r18
    2d3a:	93 1f       	adc	r25, r19
    2d3c:	23 e0       	ldi	r18, 0x03	; 3
    2d3e:	88 3e       	cpi	r24, 0xE8	; 232
    2d40:	92 07       	cpc	r25, r18
    2d42:	18 f5       	brcc	.+70     	; 0x2d8a <pvPortMalloc+0x76>
    2d44:	20 91 d2 00 	lds	r18, 0x00D2
    2d48:	30 91 d3 00 	lds	r19, 0x00D3
    2d4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d50:	28 0f       	add	r18, r24
    2d52:	39 1f       	adc	r19, r25
    2d54:	80 91 d2 00 	lds	r24, 0x00D2
    2d58:	90 91 d3 00 	lds	r25, 0x00D3
    2d5c:	82 17       	cp	r24, r18
    2d5e:	93 07       	cpc	r25, r19
    2d60:	a0 f4       	brcc	.+40     	; 0x2d8a <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2d62:	80 91 d2 00 	lds	r24, 0x00D2
    2d66:	90 91 d3 00 	lds	r25, 0x00D3
    2d6a:	8c 52       	subi	r24, 0x2C	; 44
    2d6c:	9f 4f       	sbci	r25, 0xFF	; 255
    2d6e:	9a 83       	std	Y+2, r25	; 0x02
    2d70:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    2d72:	20 91 d2 00 	lds	r18, 0x00D2
    2d76:	30 91 d3 00 	lds	r19, 0x00D3
    2d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d7e:	82 0f       	add	r24, r18
    2d80:	93 1f       	adc	r25, r19
    2d82:	90 93 d3 00 	sts	0x00D3, r25
    2d86:	80 93 d2 00 	sts	0x00D2, r24
		}	
	}
	xTaskResumeAll();
    2d8a:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    2d8e:	89 81       	ldd	r24, Y+1	; 0x01
    2d90:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d92:	0f 90       	pop	r0
    2d94:	0f 90       	pop	r0
    2d96:	0f 90       	pop	r0
    2d98:	0f 90       	pop	r0
    2d9a:	cf 91       	pop	r28
    2d9c:	df 91       	pop	r29
    2d9e:	08 95       	ret

00002da0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2da0:	df 93       	push	r29
    2da2:	cf 93       	push	r28
    2da4:	00 d0       	rcall	.+0      	; 0x2da6 <vPortFree+0x6>
    2da6:	cd b7       	in	r28, 0x3d	; 61
    2da8:	de b7       	in	r29, 0x3e	; 62
    2daa:	9a 83       	std	Y+2, r25	; 0x02
    2dac:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2dae:	0f 90       	pop	r0
    2db0:	0f 90       	pop	r0
    2db2:	cf 91       	pop	r28
    2db4:	df 91       	pop	r29
    2db6:	08 95       	ret

00002db8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2db8:	df 93       	push	r29
    2dba:	cf 93       	push	r28
    2dbc:	cd b7       	in	r28, 0x3d	; 61
    2dbe:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2dc0:	10 92 d3 00 	sts	0x00D3, r1
    2dc4:	10 92 d2 00 	sts	0x00D2, r1
}
    2dc8:	cf 91       	pop	r28
    2dca:	df 91       	pop	r29
    2dcc:	08 95       	ret

00002dce <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2dce:	df 93       	push	r29
    2dd0:	cf 93       	push	r28
    2dd2:	cd b7       	in	r28, 0x3d	; 61
    2dd4:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2dd6:	20 91 d2 00 	lds	r18, 0x00D2
    2dda:	30 91 d3 00 	lds	r19, 0x00D3
    2dde:	88 ee       	ldi	r24, 0xE8	; 232
    2de0:	93 e0       	ldi	r25, 0x03	; 3
    2de2:	82 1b       	sub	r24, r18
    2de4:	93 0b       	sbc	r25, r19
}
    2de6:	cf 91       	pop	r28
    2de8:	df 91       	pop	r29
    2dea:	08 95       	ret

00002dec <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2dec:	df 93       	push	r29
    2dee:	cf 93       	push	r28
    2df0:	00 d0       	rcall	.+0      	; 0x2df2 <vListInitialise+0x6>
    2df2:	cd b7       	in	r28, 0x3d	; 61
    2df4:	de b7       	in	r29, 0x3e	; 62
    2df6:	9a 83       	std	Y+2, r25	; 0x02
    2df8:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2dfa:	89 81       	ldd	r24, Y+1	; 0x01
    2dfc:	9a 81       	ldd	r25, Y+2	; 0x02
    2dfe:	03 96       	adiw	r24, 0x03	; 3
    2e00:	e9 81       	ldd	r30, Y+1	; 0x01
    2e02:	fa 81       	ldd	r31, Y+2	; 0x02
    2e04:	92 83       	std	Z+2, r25	; 0x02
    2e06:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2e08:	e9 81       	ldd	r30, Y+1	; 0x01
    2e0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e0c:	8f ef       	ldi	r24, 0xFF	; 255
    2e0e:	9f ef       	ldi	r25, 0xFF	; 255
    2e10:	94 83       	std	Z+4, r25	; 0x04
    2e12:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2e14:	89 81       	ldd	r24, Y+1	; 0x01
    2e16:	9a 81       	ldd	r25, Y+2	; 0x02
    2e18:	03 96       	adiw	r24, 0x03	; 3
    2e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e1e:	96 83       	std	Z+6, r25	; 0x06
    2e20:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2e22:	89 81       	ldd	r24, Y+1	; 0x01
    2e24:	9a 81       	ldd	r25, Y+2	; 0x02
    2e26:	03 96       	adiw	r24, 0x03	; 3
    2e28:	e9 81       	ldd	r30, Y+1	; 0x01
    2e2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e2c:	90 87       	std	Z+8, r25	; 0x08
    2e2e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2e30:	e9 81       	ldd	r30, Y+1	; 0x01
    2e32:	fa 81       	ldd	r31, Y+2	; 0x02
    2e34:	10 82       	st	Z, r1
}
    2e36:	0f 90       	pop	r0
    2e38:	0f 90       	pop	r0
    2e3a:	cf 91       	pop	r28
    2e3c:	df 91       	pop	r29
    2e3e:	08 95       	ret

00002e40 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2e40:	df 93       	push	r29
    2e42:	cf 93       	push	r28
    2e44:	00 d0       	rcall	.+0      	; 0x2e46 <vListInitialiseItem+0x6>
    2e46:	cd b7       	in	r28, 0x3d	; 61
    2e48:	de b7       	in	r29, 0x3e	; 62
    2e4a:	9a 83       	std	Y+2, r25	; 0x02
    2e4c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2e4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e50:	fa 81       	ldd	r31, Y+2	; 0x02
    2e52:	11 86       	std	Z+9, r1	; 0x09
    2e54:	10 86       	std	Z+8, r1	; 0x08
}
    2e56:	0f 90       	pop	r0
    2e58:	0f 90       	pop	r0
    2e5a:	cf 91       	pop	r28
    2e5c:	df 91       	pop	r29
    2e5e:	08 95       	ret

00002e60 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2e60:	df 93       	push	r29
    2e62:	cf 93       	push	r28
    2e64:	00 d0       	rcall	.+0      	; 0x2e66 <vListInsertEnd+0x6>
    2e66:	00 d0       	rcall	.+0      	; 0x2e68 <vListInsertEnd+0x8>
    2e68:	00 d0       	rcall	.+0      	; 0x2e6a <vListInsertEnd+0xa>
    2e6a:	cd b7       	in	r28, 0x3d	; 61
    2e6c:	de b7       	in	r29, 0x3e	; 62
    2e6e:	9c 83       	std	Y+4, r25	; 0x04
    2e70:	8b 83       	std	Y+3, r24	; 0x03
    2e72:	7e 83       	std	Y+6, r23	; 0x06
    2e74:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2e76:	eb 81       	ldd	r30, Y+3	; 0x03
    2e78:	fc 81       	ldd	r31, Y+4	; 0x04
    2e7a:	81 81       	ldd	r24, Z+1	; 0x01
    2e7c:	92 81       	ldd	r25, Z+2	; 0x02
    2e7e:	9a 83       	std	Y+2, r25	; 0x02
    2e80:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2e82:	e9 81       	ldd	r30, Y+1	; 0x01
    2e84:	fa 81       	ldd	r31, Y+2	; 0x02
    2e86:	82 81       	ldd	r24, Z+2	; 0x02
    2e88:	93 81       	ldd	r25, Z+3	; 0x03
    2e8a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e8c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e8e:	93 83       	std	Z+3, r25	; 0x03
    2e90:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2e92:	eb 81       	ldd	r30, Y+3	; 0x03
    2e94:	fc 81       	ldd	r31, Y+4	; 0x04
    2e96:	81 81       	ldd	r24, Z+1	; 0x01
    2e98:	92 81       	ldd	r25, Z+2	; 0x02
    2e9a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e9c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e9e:	95 83       	std	Z+5, r25	; 0x05
    2ea0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2ea2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea6:	02 80       	ldd	r0, Z+2	; 0x02
    2ea8:	f3 81       	ldd	r31, Z+3	; 0x03
    2eaa:	e0 2d       	mov	r30, r0
    2eac:	8d 81       	ldd	r24, Y+5	; 0x05
    2eae:	9e 81       	ldd	r25, Y+6	; 0x06
    2eb0:	95 83       	std	Z+5, r25	; 0x05
    2eb2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2eb4:	8d 81       	ldd	r24, Y+5	; 0x05
    2eb6:	9e 81       	ldd	r25, Y+6	; 0x06
    2eb8:	e9 81       	ldd	r30, Y+1	; 0x01
    2eba:	fa 81       	ldd	r31, Y+2	; 0x02
    2ebc:	93 83       	std	Z+3, r25	; 0x03
    2ebe:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2ec0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ec2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ec4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ec6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ec8:	92 83       	std	Z+2, r25	; 0x02
    2eca:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2ecc:	ed 81       	ldd	r30, Y+5	; 0x05
    2ece:	fe 81       	ldd	r31, Y+6	; 0x06
    2ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed4:	91 87       	std	Z+9, r25	; 0x09
    2ed6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2ed8:	eb 81       	ldd	r30, Y+3	; 0x03
    2eda:	fc 81       	ldd	r31, Y+4	; 0x04
    2edc:	80 81       	ld	r24, Z
    2ede:	8f 5f       	subi	r24, 0xFF	; 255
    2ee0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ee2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ee4:	80 83       	st	Z, r24
}
    2ee6:	26 96       	adiw	r28, 0x06	; 6
    2ee8:	0f b6       	in	r0, 0x3f	; 63
    2eea:	f8 94       	cli
    2eec:	de bf       	out	0x3e, r29	; 62
    2eee:	0f be       	out	0x3f, r0	; 63
    2ef0:	cd bf       	out	0x3d, r28	; 61
    2ef2:	cf 91       	pop	r28
    2ef4:	df 91       	pop	r29
    2ef6:	08 95       	ret

00002ef8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2ef8:	df 93       	push	r29
    2efa:	cf 93       	push	r28
    2efc:	cd b7       	in	r28, 0x3d	; 61
    2efe:	de b7       	in	r29, 0x3e	; 62
    2f00:	28 97       	sbiw	r28, 0x08	; 8
    2f02:	0f b6       	in	r0, 0x3f	; 63
    2f04:	f8 94       	cli
    2f06:	de bf       	out	0x3e, r29	; 62
    2f08:	0f be       	out	0x3f, r0	; 63
    2f0a:	cd bf       	out	0x3d, r28	; 61
    2f0c:	9e 83       	std	Y+6, r25	; 0x06
    2f0e:	8d 83       	std	Y+5, r24	; 0x05
    2f10:	78 87       	std	Y+8, r23	; 0x08
    2f12:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2f14:	ef 81       	ldd	r30, Y+7	; 0x07
    2f16:	f8 85       	ldd	r31, Y+8	; 0x08
    2f18:	80 81       	ld	r24, Z
    2f1a:	91 81       	ldd	r25, Z+1	; 0x01
    2f1c:	9a 83       	std	Y+2, r25	; 0x02
    2f1e:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2f20:	89 81       	ldd	r24, Y+1	; 0x01
    2f22:	9a 81       	ldd	r25, Y+2	; 0x02
    2f24:	2f ef       	ldi	r18, 0xFF	; 255
    2f26:	8f 3f       	cpi	r24, 0xFF	; 255
    2f28:	92 07       	cpc	r25, r18
    2f2a:	39 f4       	brne	.+14     	; 0x2f3a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2f2c:	ed 81       	ldd	r30, Y+5	; 0x05
    2f2e:	fe 81       	ldd	r31, Y+6	; 0x06
    2f30:	87 81       	ldd	r24, Z+7	; 0x07
    2f32:	90 85       	ldd	r25, Z+8	; 0x08
    2f34:	9c 83       	std	Y+4, r25	; 0x04
    2f36:	8b 83       	std	Y+3, r24	; 0x03
    2f38:	18 c0       	rjmp	.+48     	; 0x2f6a <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2f3a:	8d 81       	ldd	r24, Y+5	; 0x05
    2f3c:	9e 81       	ldd	r25, Y+6	; 0x06
    2f3e:	03 96       	adiw	r24, 0x03	; 3
    2f40:	9c 83       	std	Y+4, r25	; 0x04
    2f42:	8b 83       	std	Y+3, r24	; 0x03
    2f44:	06 c0       	rjmp	.+12     	; 0x2f52 <vListInsert+0x5a>
    2f46:	eb 81       	ldd	r30, Y+3	; 0x03
    2f48:	fc 81       	ldd	r31, Y+4	; 0x04
    2f4a:	82 81       	ldd	r24, Z+2	; 0x02
    2f4c:	93 81       	ldd	r25, Z+3	; 0x03
    2f4e:	9c 83       	std	Y+4, r25	; 0x04
    2f50:	8b 83       	std	Y+3, r24	; 0x03
    2f52:	eb 81       	ldd	r30, Y+3	; 0x03
    2f54:	fc 81       	ldd	r31, Y+4	; 0x04
    2f56:	02 80       	ldd	r0, Z+2	; 0x02
    2f58:	f3 81       	ldd	r31, Z+3	; 0x03
    2f5a:	e0 2d       	mov	r30, r0
    2f5c:	20 81       	ld	r18, Z
    2f5e:	31 81       	ldd	r19, Z+1	; 0x01
    2f60:	89 81       	ldd	r24, Y+1	; 0x01
    2f62:	9a 81       	ldd	r25, Y+2	; 0x02
    2f64:	82 17       	cp	r24, r18
    2f66:	93 07       	cpc	r25, r19
    2f68:	70 f7       	brcc	.-36     	; 0x2f46 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2f6a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f6c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f6e:	82 81       	ldd	r24, Z+2	; 0x02
    2f70:	93 81       	ldd	r25, Z+3	; 0x03
    2f72:	ef 81       	ldd	r30, Y+7	; 0x07
    2f74:	f8 85       	ldd	r31, Y+8	; 0x08
    2f76:	93 83       	std	Z+3, r25	; 0x03
    2f78:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2f7a:	ef 81       	ldd	r30, Y+7	; 0x07
    2f7c:	f8 85       	ldd	r31, Y+8	; 0x08
    2f7e:	02 80       	ldd	r0, Z+2	; 0x02
    2f80:	f3 81       	ldd	r31, Z+3	; 0x03
    2f82:	e0 2d       	mov	r30, r0
    2f84:	8f 81       	ldd	r24, Y+7	; 0x07
    2f86:	98 85       	ldd	r25, Y+8	; 0x08
    2f88:	95 83       	std	Z+5, r25	; 0x05
    2f8a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2f8c:	ef 81       	ldd	r30, Y+7	; 0x07
    2f8e:	f8 85       	ldd	r31, Y+8	; 0x08
    2f90:	8b 81       	ldd	r24, Y+3	; 0x03
    2f92:	9c 81       	ldd	r25, Y+4	; 0x04
    2f94:	95 83       	std	Z+5, r25	; 0x05
    2f96:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2f98:	8f 81       	ldd	r24, Y+7	; 0x07
    2f9a:	98 85       	ldd	r25, Y+8	; 0x08
    2f9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2fa0:	93 83       	std	Z+3, r25	; 0x03
    2fa2:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2fa4:	ef 81       	ldd	r30, Y+7	; 0x07
    2fa6:	f8 85       	ldd	r31, Y+8	; 0x08
    2fa8:	8d 81       	ldd	r24, Y+5	; 0x05
    2faa:	9e 81       	ldd	r25, Y+6	; 0x06
    2fac:	91 87       	std	Z+9, r25	; 0x09
    2fae:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2fb0:	ed 81       	ldd	r30, Y+5	; 0x05
    2fb2:	fe 81       	ldd	r31, Y+6	; 0x06
    2fb4:	80 81       	ld	r24, Z
    2fb6:	8f 5f       	subi	r24, 0xFF	; 255
    2fb8:	ed 81       	ldd	r30, Y+5	; 0x05
    2fba:	fe 81       	ldd	r31, Y+6	; 0x06
    2fbc:	80 83       	st	Z, r24
}
    2fbe:	28 96       	adiw	r28, 0x08	; 8
    2fc0:	0f b6       	in	r0, 0x3f	; 63
    2fc2:	f8 94       	cli
    2fc4:	de bf       	out	0x3e, r29	; 62
    2fc6:	0f be       	out	0x3f, r0	; 63
    2fc8:	cd bf       	out	0x3d, r28	; 61
    2fca:	cf 91       	pop	r28
    2fcc:	df 91       	pop	r29
    2fce:	08 95       	ret

00002fd0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2fd0:	df 93       	push	r29
    2fd2:	cf 93       	push	r28
    2fd4:	00 d0       	rcall	.+0      	; 0x2fd6 <vListRemove+0x6>
    2fd6:	00 d0       	rcall	.+0      	; 0x2fd8 <vListRemove+0x8>
    2fd8:	cd b7       	in	r28, 0x3d	; 61
    2fda:	de b7       	in	r29, 0x3e	; 62
    2fdc:	9c 83       	std	Y+4, r25	; 0x04
    2fde:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2fe0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fe4:	a2 81       	ldd	r26, Z+2	; 0x02
    2fe6:	b3 81       	ldd	r27, Z+3	; 0x03
    2fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    2fea:	fc 81       	ldd	r31, Y+4	; 0x04
    2fec:	84 81       	ldd	r24, Z+4	; 0x04
    2fee:	95 81       	ldd	r25, Z+5	; 0x05
    2ff0:	15 96       	adiw	r26, 0x05	; 5
    2ff2:	9c 93       	st	X, r25
    2ff4:	8e 93       	st	-X, r24
    2ff6:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2ff8:	eb 81       	ldd	r30, Y+3	; 0x03
    2ffa:	fc 81       	ldd	r31, Y+4	; 0x04
    2ffc:	a4 81       	ldd	r26, Z+4	; 0x04
    2ffe:	b5 81       	ldd	r27, Z+5	; 0x05
    3000:	eb 81       	ldd	r30, Y+3	; 0x03
    3002:	fc 81       	ldd	r31, Y+4	; 0x04
    3004:	82 81       	ldd	r24, Z+2	; 0x02
    3006:	93 81       	ldd	r25, Z+3	; 0x03
    3008:	13 96       	adiw	r26, 0x03	; 3
    300a:	9c 93       	st	X, r25
    300c:	8e 93       	st	-X, r24
    300e:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    3010:	eb 81       	ldd	r30, Y+3	; 0x03
    3012:	fc 81       	ldd	r31, Y+4	; 0x04
    3014:	80 85       	ldd	r24, Z+8	; 0x08
    3016:	91 85       	ldd	r25, Z+9	; 0x09
    3018:	9a 83       	std	Y+2, r25	; 0x02
    301a:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    301c:	e9 81       	ldd	r30, Y+1	; 0x01
    301e:	fa 81       	ldd	r31, Y+2	; 0x02
    3020:	21 81       	ldd	r18, Z+1	; 0x01
    3022:	32 81       	ldd	r19, Z+2	; 0x02
    3024:	8b 81       	ldd	r24, Y+3	; 0x03
    3026:	9c 81       	ldd	r25, Y+4	; 0x04
    3028:	28 17       	cp	r18, r24
    302a:	39 07       	cpc	r19, r25
    302c:	41 f4       	brne	.+16     	; 0x303e <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    302e:	eb 81       	ldd	r30, Y+3	; 0x03
    3030:	fc 81       	ldd	r31, Y+4	; 0x04
    3032:	84 81       	ldd	r24, Z+4	; 0x04
    3034:	95 81       	ldd	r25, Z+5	; 0x05
    3036:	e9 81       	ldd	r30, Y+1	; 0x01
    3038:	fa 81       	ldd	r31, Y+2	; 0x02
    303a:	92 83       	std	Z+2, r25	; 0x02
    303c:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    303e:	eb 81       	ldd	r30, Y+3	; 0x03
    3040:	fc 81       	ldd	r31, Y+4	; 0x04
    3042:	11 86       	std	Z+9, r1	; 0x09
    3044:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3046:	e9 81       	ldd	r30, Y+1	; 0x01
    3048:	fa 81       	ldd	r31, Y+2	; 0x02
    304a:	80 81       	ld	r24, Z
    304c:	81 50       	subi	r24, 0x01	; 1
    304e:	e9 81       	ldd	r30, Y+1	; 0x01
    3050:	fa 81       	ldd	r31, Y+2	; 0x02
    3052:	80 83       	st	Z, r24
}
    3054:	0f 90       	pop	r0
    3056:	0f 90       	pop	r0
    3058:	0f 90       	pop	r0
    305a:	0f 90       	pop	r0
    305c:	cf 91       	pop	r28
    305e:	df 91       	pop	r29
    3060:	08 95       	ret

00003062 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    3062:	df 93       	push	r29
    3064:	cf 93       	push	r28
    3066:	cd b7       	in	r28, 0x3d	; 61
    3068:	de b7       	in	r29, 0x3e	; 62
    306a:	28 97       	sbiw	r28, 0x08	; 8
    306c:	0f b6       	in	r0, 0x3f	; 63
    306e:	f8 94       	cli
    3070:	de bf       	out	0x3e, r29	; 62
    3072:	0f be       	out	0x3f, r0	; 63
    3074:	cd bf       	out	0x3d, r28	; 61
    3076:	9c 83       	std	Y+4, r25	; 0x04
    3078:	8b 83       	std	Y+3, r24	; 0x03
    307a:	7e 83       	std	Y+6, r23	; 0x06
    307c:	6d 83       	std	Y+5, r22	; 0x05
    307e:	58 87       	std	Y+8, r21	; 0x08
    3080:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3082:	eb 81       	ldd	r30, Y+3	; 0x03
    3084:	fc 81       	ldd	r31, Y+4	; 0x04
    3086:	81 e1       	ldi	r24, 0x11	; 17
    3088:	80 83       	st	Z, r24
	pxTopOfStack--;
    308a:	8b 81       	ldd	r24, Y+3	; 0x03
    308c:	9c 81       	ldd	r25, Y+4	; 0x04
    308e:	01 97       	sbiw	r24, 0x01	; 1
    3090:	9c 83       	std	Y+4, r25	; 0x04
    3092:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3094:	eb 81       	ldd	r30, Y+3	; 0x03
    3096:	fc 81       	ldd	r31, Y+4	; 0x04
    3098:	82 e2       	ldi	r24, 0x22	; 34
    309a:	80 83       	st	Z, r24
	pxTopOfStack--;
    309c:	8b 81       	ldd	r24, Y+3	; 0x03
    309e:	9c 81       	ldd	r25, Y+4	; 0x04
    30a0:	01 97       	sbiw	r24, 0x01	; 1
    30a2:	9c 83       	std	Y+4, r25	; 0x04
    30a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    30a6:	eb 81       	ldd	r30, Y+3	; 0x03
    30a8:	fc 81       	ldd	r31, Y+4	; 0x04
    30aa:	83 e3       	ldi	r24, 0x33	; 51
    30ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    30ae:	8b 81       	ldd	r24, Y+3	; 0x03
    30b0:	9c 81       	ldd	r25, Y+4	; 0x04
    30b2:	01 97       	sbiw	r24, 0x01	; 1
    30b4:	9c 83       	std	Y+4, r25	; 0x04
    30b6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    30b8:	8d 81       	ldd	r24, Y+5	; 0x05
    30ba:	9e 81       	ldd	r25, Y+6	; 0x06
    30bc:	9a 83       	std	Y+2, r25	; 0x02
    30be:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    30c0:	89 81       	ldd	r24, Y+1	; 0x01
    30c2:	eb 81       	ldd	r30, Y+3	; 0x03
    30c4:	fc 81       	ldd	r31, Y+4	; 0x04
    30c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    30c8:	8b 81       	ldd	r24, Y+3	; 0x03
    30ca:	9c 81       	ldd	r25, Y+4	; 0x04
    30cc:	01 97       	sbiw	r24, 0x01	; 1
    30ce:	9c 83       	std	Y+4, r25	; 0x04
    30d0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    30d2:	89 81       	ldd	r24, Y+1	; 0x01
    30d4:	9a 81       	ldd	r25, Y+2	; 0x02
    30d6:	89 2f       	mov	r24, r25
    30d8:	99 27       	eor	r25, r25
    30da:	9a 83       	std	Y+2, r25	; 0x02
    30dc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    30de:	89 81       	ldd	r24, Y+1	; 0x01
    30e0:	eb 81       	ldd	r30, Y+3	; 0x03
    30e2:	fc 81       	ldd	r31, Y+4	; 0x04
    30e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    30e6:	8b 81       	ldd	r24, Y+3	; 0x03
    30e8:	9c 81       	ldd	r25, Y+4	; 0x04
    30ea:	01 97       	sbiw	r24, 0x01	; 1
    30ec:	9c 83       	std	Y+4, r25	; 0x04
    30ee:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    30f0:	eb 81       	ldd	r30, Y+3	; 0x03
    30f2:	fc 81       	ldd	r31, Y+4	; 0x04
    30f4:	10 82       	st	Z, r1
	pxTopOfStack--;
    30f6:	8b 81       	ldd	r24, Y+3	; 0x03
    30f8:	9c 81       	ldd	r25, Y+4	; 0x04
    30fa:	01 97       	sbiw	r24, 0x01	; 1
    30fc:	9c 83       	std	Y+4, r25	; 0x04
    30fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3100:	eb 81       	ldd	r30, Y+3	; 0x03
    3102:	fc 81       	ldd	r31, Y+4	; 0x04
    3104:	80 e8       	ldi	r24, 0x80	; 128
    3106:	80 83       	st	Z, r24
	pxTopOfStack--;
    3108:	8b 81       	ldd	r24, Y+3	; 0x03
    310a:	9c 81       	ldd	r25, Y+4	; 0x04
    310c:	01 97       	sbiw	r24, 0x01	; 1
    310e:	9c 83       	std	Y+4, r25	; 0x04
    3110:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3112:	eb 81       	ldd	r30, Y+3	; 0x03
    3114:	fc 81       	ldd	r31, Y+4	; 0x04
    3116:	10 82       	st	Z, r1
	pxTopOfStack--;
    3118:	8b 81       	ldd	r24, Y+3	; 0x03
    311a:	9c 81       	ldd	r25, Y+4	; 0x04
    311c:	01 97       	sbiw	r24, 0x01	; 1
    311e:	9c 83       	std	Y+4, r25	; 0x04
    3120:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3122:	eb 81       	ldd	r30, Y+3	; 0x03
    3124:	fc 81       	ldd	r31, Y+4	; 0x04
    3126:	82 e0       	ldi	r24, 0x02	; 2
    3128:	80 83       	st	Z, r24
	pxTopOfStack--;
    312a:	8b 81       	ldd	r24, Y+3	; 0x03
    312c:	9c 81       	ldd	r25, Y+4	; 0x04
    312e:	01 97       	sbiw	r24, 0x01	; 1
    3130:	9c 83       	std	Y+4, r25	; 0x04
    3132:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3134:	eb 81       	ldd	r30, Y+3	; 0x03
    3136:	fc 81       	ldd	r31, Y+4	; 0x04
    3138:	83 e0       	ldi	r24, 0x03	; 3
    313a:	80 83       	st	Z, r24
	pxTopOfStack--;
    313c:	8b 81       	ldd	r24, Y+3	; 0x03
    313e:	9c 81       	ldd	r25, Y+4	; 0x04
    3140:	01 97       	sbiw	r24, 0x01	; 1
    3142:	9c 83       	std	Y+4, r25	; 0x04
    3144:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    3146:	eb 81       	ldd	r30, Y+3	; 0x03
    3148:	fc 81       	ldd	r31, Y+4	; 0x04
    314a:	84 e0       	ldi	r24, 0x04	; 4
    314c:	80 83       	st	Z, r24
	pxTopOfStack--;
    314e:	8b 81       	ldd	r24, Y+3	; 0x03
    3150:	9c 81       	ldd	r25, Y+4	; 0x04
    3152:	01 97       	sbiw	r24, 0x01	; 1
    3154:	9c 83       	std	Y+4, r25	; 0x04
    3156:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    3158:	eb 81       	ldd	r30, Y+3	; 0x03
    315a:	fc 81       	ldd	r31, Y+4	; 0x04
    315c:	85 e0       	ldi	r24, 0x05	; 5
    315e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3160:	8b 81       	ldd	r24, Y+3	; 0x03
    3162:	9c 81       	ldd	r25, Y+4	; 0x04
    3164:	01 97       	sbiw	r24, 0x01	; 1
    3166:	9c 83       	std	Y+4, r25	; 0x04
    3168:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    316a:	eb 81       	ldd	r30, Y+3	; 0x03
    316c:	fc 81       	ldd	r31, Y+4	; 0x04
    316e:	86 e0       	ldi	r24, 0x06	; 6
    3170:	80 83       	st	Z, r24
	pxTopOfStack--;
    3172:	8b 81       	ldd	r24, Y+3	; 0x03
    3174:	9c 81       	ldd	r25, Y+4	; 0x04
    3176:	01 97       	sbiw	r24, 0x01	; 1
    3178:	9c 83       	std	Y+4, r25	; 0x04
    317a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    317c:	eb 81       	ldd	r30, Y+3	; 0x03
    317e:	fc 81       	ldd	r31, Y+4	; 0x04
    3180:	87 e0       	ldi	r24, 0x07	; 7
    3182:	80 83       	st	Z, r24
	pxTopOfStack--;
    3184:	8b 81       	ldd	r24, Y+3	; 0x03
    3186:	9c 81       	ldd	r25, Y+4	; 0x04
    3188:	01 97       	sbiw	r24, 0x01	; 1
    318a:	9c 83       	std	Y+4, r25	; 0x04
    318c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    318e:	eb 81       	ldd	r30, Y+3	; 0x03
    3190:	fc 81       	ldd	r31, Y+4	; 0x04
    3192:	88 e0       	ldi	r24, 0x08	; 8
    3194:	80 83       	st	Z, r24
	pxTopOfStack--;
    3196:	8b 81       	ldd	r24, Y+3	; 0x03
    3198:	9c 81       	ldd	r25, Y+4	; 0x04
    319a:	01 97       	sbiw	r24, 0x01	; 1
    319c:	9c 83       	std	Y+4, r25	; 0x04
    319e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    31a0:	eb 81       	ldd	r30, Y+3	; 0x03
    31a2:	fc 81       	ldd	r31, Y+4	; 0x04
    31a4:	89 e0       	ldi	r24, 0x09	; 9
    31a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    31a8:	8b 81       	ldd	r24, Y+3	; 0x03
    31aa:	9c 81       	ldd	r25, Y+4	; 0x04
    31ac:	01 97       	sbiw	r24, 0x01	; 1
    31ae:	9c 83       	std	Y+4, r25	; 0x04
    31b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    31b2:	eb 81       	ldd	r30, Y+3	; 0x03
    31b4:	fc 81       	ldd	r31, Y+4	; 0x04
    31b6:	80 e1       	ldi	r24, 0x10	; 16
    31b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    31ba:	8b 81       	ldd	r24, Y+3	; 0x03
    31bc:	9c 81       	ldd	r25, Y+4	; 0x04
    31be:	01 97       	sbiw	r24, 0x01	; 1
    31c0:	9c 83       	std	Y+4, r25	; 0x04
    31c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    31c4:	eb 81       	ldd	r30, Y+3	; 0x03
    31c6:	fc 81       	ldd	r31, Y+4	; 0x04
    31c8:	81 e1       	ldi	r24, 0x11	; 17
    31ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    31cc:	8b 81       	ldd	r24, Y+3	; 0x03
    31ce:	9c 81       	ldd	r25, Y+4	; 0x04
    31d0:	01 97       	sbiw	r24, 0x01	; 1
    31d2:	9c 83       	std	Y+4, r25	; 0x04
    31d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    31d6:	eb 81       	ldd	r30, Y+3	; 0x03
    31d8:	fc 81       	ldd	r31, Y+4	; 0x04
    31da:	82 e1       	ldi	r24, 0x12	; 18
    31dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    31de:	8b 81       	ldd	r24, Y+3	; 0x03
    31e0:	9c 81       	ldd	r25, Y+4	; 0x04
    31e2:	01 97       	sbiw	r24, 0x01	; 1
    31e4:	9c 83       	std	Y+4, r25	; 0x04
    31e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    31e8:	eb 81       	ldd	r30, Y+3	; 0x03
    31ea:	fc 81       	ldd	r31, Y+4	; 0x04
    31ec:	83 e1       	ldi	r24, 0x13	; 19
    31ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    31f0:	8b 81       	ldd	r24, Y+3	; 0x03
    31f2:	9c 81       	ldd	r25, Y+4	; 0x04
    31f4:	01 97       	sbiw	r24, 0x01	; 1
    31f6:	9c 83       	std	Y+4, r25	; 0x04
    31f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    31fa:	eb 81       	ldd	r30, Y+3	; 0x03
    31fc:	fc 81       	ldd	r31, Y+4	; 0x04
    31fe:	84 e1       	ldi	r24, 0x14	; 20
    3200:	80 83       	st	Z, r24
	pxTopOfStack--;
    3202:	8b 81       	ldd	r24, Y+3	; 0x03
    3204:	9c 81       	ldd	r25, Y+4	; 0x04
    3206:	01 97       	sbiw	r24, 0x01	; 1
    3208:	9c 83       	std	Y+4, r25	; 0x04
    320a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    320c:	eb 81       	ldd	r30, Y+3	; 0x03
    320e:	fc 81       	ldd	r31, Y+4	; 0x04
    3210:	85 e1       	ldi	r24, 0x15	; 21
    3212:	80 83       	st	Z, r24
	pxTopOfStack--;
    3214:	8b 81       	ldd	r24, Y+3	; 0x03
    3216:	9c 81       	ldd	r25, Y+4	; 0x04
    3218:	01 97       	sbiw	r24, 0x01	; 1
    321a:	9c 83       	std	Y+4, r25	; 0x04
    321c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    321e:	eb 81       	ldd	r30, Y+3	; 0x03
    3220:	fc 81       	ldd	r31, Y+4	; 0x04
    3222:	86 e1       	ldi	r24, 0x16	; 22
    3224:	80 83       	st	Z, r24
	pxTopOfStack--;
    3226:	8b 81       	ldd	r24, Y+3	; 0x03
    3228:	9c 81       	ldd	r25, Y+4	; 0x04
    322a:	01 97       	sbiw	r24, 0x01	; 1
    322c:	9c 83       	std	Y+4, r25	; 0x04
    322e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    3230:	eb 81       	ldd	r30, Y+3	; 0x03
    3232:	fc 81       	ldd	r31, Y+4	; 0x04
    3234:	87 e1       	ldi	r24, 0x17	; 23
    3236:	80 83       	st	Z, r24
	pxTopOfStack--;
    3238:	8b 81       	ldd	r24, Y+3	; 0x03
    323a:	9c 81       	ldd	r25, Y+4	; 0x04
    323c:	01 97       	sbiw	r24, 0x01	; 1
    323e:	9c 83       	std	Y+4, r25	; 0x04
    3240:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3242:	eb 81       	ldd	r30, Y+3	; 0x03
    3244:	fc 81       	ldd	r31, Y+4	; 0x04
    3246:	88 e1       	ldi	r24, 0x18	; 24
    3248:	80 83       	st	Z, r24
	pxTopOfStack--;
    324a:	8b 81       	ldd	r24, Y+3	; 0x03
    324c:	9c 81       	ldd	r25, Y+4	; 0x04
    324e:	01 97       	sbiw	r24, 0x01	; 1
    3250:	9c 83       	std	Y+4, r25	; 0x04
    3252:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3254:	eb 81       	ldd	r30, Y+3	; 0x03
    3256:	fc 81       	ldd	r31, Y+4	; 0x04
    3258:	89 e1       	ldi	r24, 0x19	; 25
    325a:	80 83       	st	Z, r24
	pxTopOfStack--;
    325c:	8b 81       	ldd	r24, Y+3	; 0x03
    325e:	9c 81       	ldd	r25, Y+4	; 0x04
    3260:	01 97       	sbiw	r24, 0x01	; 1
    3262:	9c 83       	std	Y+4, r25	; 0x04
    3264:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    3266:	eb 81       	ldd	r30, Y+3	; 0x03
    3268:	fc 81       	ldd	r31, Y+4	; 0x04
    326a:	80 e2       	ldi	r24, 0x20	; 32
    326c:	80 83       	st	Z, r24
	pxTopOfStack--;
    326e:	8b 81       	ldd	r24, Y+3	; 0x03
    3270:	9c 81       	ldd	r25, Y+4	; 0x04
    3272:	01 97       	sbiw	r24, 0x01	; 1
    3274:	9c 83       	std	Y+4, r25	; 0x04
    3276:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    3278:	eb 81       	ldd	r30, Y+3	; 0x03
    327a:	fc 81       	ldd	r31, Y+4	; 0x04
    327c:	81 e2       	ldi	r24, 0x21	; 33
    327e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3280:	8b 81       	ldd	r24, Y+3	; 0x03
    3282:	9c 81       	ldd	r25, Y+4	; 0x04
    3284:	01 97       	sbiw	r24, 0x01	; 1
    3286:	9c 83       	std	Y+4, r25	; 0x04
    3288:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    328a:	eb 81       	ldd	r30, Y+3	; 0x03
    328c:	fc 81       	ldd	r31, Y+4	; 0x04
    328e:	82 e2       	ldi	r24, 0x22	; 34
    3290:	80 83       	st	Z, r24
	pxTopOfStack--;
    3292:	8b 81       	ldd	r24, Y+3	; 0x03
    3294:	9c 81       	ldd	r25, Y+4	; 0x04
    3296:	01 97       	sbiw	r24, 0x01	; 1
    3298:	9c 83       	std	Y+4, r25	; 0x04
    329a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    329c:	eb 81       	ldd	r30, Y+3	; 0x03
    329e:	fc 81       	ldd	r31, Y+4	; 0x04
    32a0:	83 e2       	ldi	r24, 0x23	; 35
    32a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    32a4:	8b 81       	ldd	r24, Y+3	; 0x03
    32a6:	9c 81       	ldd	r25, Y+4	; 0x04
    32a8:	01 97       	sbiw	r24, 0x01	; 1
    32aa:	9c 83       	std	Y+4, r25	; 0x04
    32ac:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    32ae:	8f 81       	ldd	r24, Y+7	; 0x07
    32b0:	98 85       	ldd	r25, Y+8	; 0x08
    32b2:	9a 83       	std	Y+2, r25	; 0x02
    32b4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    32b6:	89 81       	ldd	r24, Y+1	; 0x01
    32b8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ba:	fc 81       	ldd	r31, Y+4	; 0x04
    32bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    32be:	8b 81       	ldd	r24, Y+3	; 0x03
    32c0:	9c 81       	ldd	r25, Y+4	; 0x04
    32c2:	01 97       	sbiw	r24, 0x01	; 1
    32c4:	9c 83       	std	Y+4, r25	; 0x04
    32c6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    32c8:	89 81       	ldd	r24, Y+1	; 0x01
    32ca:	9a 81       	ldd	r25, Y+2	; 0x02
    32cc:	89 2f       	mov	r24, r25
    32ce:	99 27       	eor	r25, r25
    32d0:	9a 83       	std	Y+2, r25	; 0x02
    32d2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    32d4:	89 81       	ldd	r24, Y+1	; 0x01
    32d6:	eb 81       	ldd	r30, Y+3	; 0x03
    32d8:	fc 81       	ldd	r31, Y+4	; 0x04
    32da:	80 83       	st	Z, r24
	pxTopOfStack--;
    32dc:	8b 81       	ldd	r24, Y+3	; 0x03
    32de:	9c 81       	ldd	r25, Y+4	; 0x04
    32e0:	01 97       	sbiw	r24, 0x01	; 1
    32e2:	9c 83       	std	Y+4, r25	; 0x04
    32e4:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    32e6:	eb 81       	ldd	r30, Y+3	; 0x03
    32e8:	fc 81       	ldd	r31, Y+4	; 0x04
    32ea:	86 e2       	ldi	r24, 0x26	; 38
    32ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    32ee:	8b 81       	ldd	r24, Y+3	; 0x03
    32f0:	9c 81       	ldd	r25, Y+4	; 0x04
    32f2:	01 97       	sbiw	r24, 0x01	; 1
    32f4:	9c 83       	std	Y+4, r25	; 0x04
    32f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    32f8:	eb 81       	ldd	r30, Y+3	; 0x03
    32fa:	fc 81       	ldd	r31, Y+4	; 0x04
    32fc:	87 e2       	ldi	r24, 0x27	; 39
    32fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    3300:	8b 81       	ldd	r24, Y+3	; 0x03
    3302:	9c 81       	ldd	r25, Y+4	; 0x04
    3304:	01 97       	sbiw	r24, 0x01	; 1
    3306:	9c 83       	std	Y+4, r25	; 0x04
    3308:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    330a:	eb 81       	ldd	r30, Y+3	; 0x03
    330c:	fc 81       	ldd	r31, Y+4	; 0x04
    330e:	88 e2       	ldi	r24, 0x28	; 40
    3310:	80 83       	st	Z, r24
	pxTopOfStack--;
    3312:	8b 81       	ldd	r24, Y+3	; 0x03
    3314:	9c 81       	ldd	r25, Y+4	; 0x04
    3316:	01 97       	sbiw	r24, 0x01	; 1
    3318:	9c 83       	std	Y+4, r25	; 0x04
    331a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    331c:	eb 81       	ldd	r30, Y+3	; 0x03
    331e:	fc 81       	ldd	r31, Y+4	; 0x04
    3320:	89 e2       	ldi	r24, 0x29	; 41
    3322:	80 83       	st	Z, r24
	pxTopOfStack--;
    3324:	8b 81       	ldd	r24, Y+3	; 0x03
    3326:	9c 81       	ldd	r25, Y+4	; 0x04
    3328:	01 97       	sbiw	r24, 0x01	; 1
    332a:	9c 83       	std	Y+4, r25	; 0x04
    332c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    332e:	eb 81       	ldd	r30, Y+3	; 0x03
    3330:	fc 81       	ldd	r31, Y+4	; 0x04
    3332:	80 e3       	ldi	r24, 0x30	; 48
    3334:	80 83       	st	Z, r24
	pxTopOfStack--;
    3336:	8b 81       	ldd	r24, Y+3	; 0x03
    3338:	9c 81       	ldd	r25, Y+4	; 0x04
    333a:	01 97       	sbiw	r24, 0x01	; 1
    333c:	9c 83       	std	Y+4, r25	; 0x04
    333e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3340:	eb 81       	ldd	r30, Y+3	; 0x03
    3342:	fc 81       	ldd	r31, Y+4	; 0x04
    3344:	81 e3       	ldi	r24, 0x31	; 49
    3346:	80 83       	st	Z, r24
	pxTopOfStack--;
    3348:	8b 81       	ldd	r24, Y+3	; 0x03
    334a:	9c 81       	ldd	r25, Y+4	; 0x04
    334c:	01 97       	sbiw	r24, 0x01	; 1
    334e:	9c 83       	std	Y+4, r25	; 0x04
    3350:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3352:	8b 81       	ldd	r24, Y+3	; 0x03
    3354:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3356:	28 96       	adiw	r28, 0x08	; 8
    3358:	0f b6       	in	r0, 0x3f	; 63
    335a:	f8 94       	cli
    335c:	de bf       	out	0x3e, r29	; 62
    335e:	0f be       	out	0x3f, r0	; 63
    3360:	cd bf       	out	0x3d, r28	; 61
    3362:	cf 91       	pop	r28
    3364:	df 91       	pop	r29
    3366:	08 95       	ret

00003368 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    3368:	df 93       	push	r29
    336a:	cf 93       	push	r28
    336c:	cd b7       	in	r28, 0x3d	; 61
    336e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3370:	0e 94 a4 1a 	call	0x3548	; 0x3548 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3374:	a0 91 bc 04 	lds	r26, 0x04BC
    3378:	b0 91 bd 04 	lds	r27, 0x04BD
    337c:	cd 91       	ld	r28, X+
    337e:	cd bf       	out	0x3d, r28	; 61
    3380:	dd 91       	ld	r29, X+
    3382:	de bf       	out	0x3e, r29	; 62
    3384:	ff 91       	pop	r31
    3386:	ef 91       	pop	r30
    3388:	df 91       	pop	r29
    338a:	cf 91       	pop	r28
    338c:	bf 91       	pop	r27
    338e:	af 91       	pop	r26
    3390:	9f 91       	pop	r25
    3392:	8f 91       	pop	r24
    3394:	7f 91       	pop	r23
    3396:	6f 91       	pop	r22
    3398:	5f 91       	pop	r21
    339a:	4f 91       	pop	r20
    339c:	3f 91       	pop	r19
    339e:	2f 91       	pop	r18
    33a0:	1f 91       	pop	r17
    33a2:	0f 91       	pop	r16
    33a4:	ff 90       	pop	r15
    33a6:	ef 90       	pop	r14
    33a8:	df 90       	pop	r13
    33aa:	cf 90       	pop	r12
    33ac:	bf 90       	pop	r11
    33ae:	af 90       	pop	r10
    33b0:	9f 90       	pop	r9
    33b2:	8f 90       	pop	r8
    33b4:	7f 90       	pop	r7
    33b6:	6f 90       	pop	r6
    33b8:	5f 90       	pop	r5
    33ba:	4f 90       	pop	r4
    33bc:	3f 90       	pop	r3
    33be:	2f 90       	pop	r2
    33c0:	1f 90       	pop	r1
    33c2:	0f 90       	pop	r0
    33c4:	0f be       	out	0x3f, r0	; 63
    33c6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    33c8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    33ca:	81 e0       	ldi	r24, 0x01	; 1
}
    33cc:	cf 91       	pop	r28
    33ce:	df 91       	pop	r29
    33d0:	08 95       	ret

000033d2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    33d2:	df 93       	push	r29
    33d4:	cf 93       	push	r28
    33d6:	cd b7       	in	r28, 0x3d	; 61
    33d8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    33da:	cf 91       	pop	r28
    33dc:	df 91       	pop	r29
    33de:	08 95       	ret

000033e0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    33e0:	0f 92       	push	r0
    33e2:	0f b6       	in	r0, 0x3f	; 63
    33e4:	f8 94       	cli
    33e6:	0f 92       	push	r0
    33e8:	1f 92       	push	r1
    33ea:	11 24       	eor	r1, r1
    33ec:	2f 92       	push	r2
    33ee:	3f 92       	push	r3
    33f0:	4f 92       	push	r4
    33f2:	5f 92       	push	r5
    33f4:	6f 92       	push	r6
    33f6:	7f 92       	push	r7
    33f8:	8f 92       	push	r8
    33fa:	9f 92       	push	r9
    33fc:	af 92       	push	r10
    33fe:	bf 92       	push	r11
    3400:	cf 92       	push	r12
    3402:	df 92       	push	r13
    3404:	ef 92       	push	r14
    3406:	ff 92       	push	r15
    3408:	0f 93       	push	r16
    340a:	1f 93       	push	r17
    340c:	2f 93       	push	r18
    340e:	3f 93       	push	r19
    3410:	4f 93       	push	r20
    3412:	5f 93       	push	r21
    3414:	6f 93       	push	r22
    3416:	7f 93       	push	r23
    3418:	8f 93       	push	r24
    341a:	9f 93       	push	r25
    341c:	af 93       	push	r26
    341e:	bf 93       	push	r27
    3420:	cf 93       	push	r28
    3422:	df 93       	push	r29
    3424:	ef 93       	push	r30
    3426:	ff 93       	push	r31
    3428:	a0 91 bc 04 	lds	r26, 0x04BC
    342c:	b0 91 bd 04 	lds	r27, 0x04BD
    3430:	0d b6       	in	r0, 0x3d	; 61
    3432:	0d 92       	st	X+, r0
    3434:	0e b6       	in	r0, 0x3e	; 62
    3436:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3438:	0e 94 de 24 	call	0x49bc	; 0x49bc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    343c:	a0 91 bc 04 	lds	r26, 0x04BC
    3440:	b0 91 bd 04 	lds	r27, 0x04BD
    3444:	cd 91       	ld	r28, X+
    3446:	cd bf       	out	0x3d, r28	; 61
    3448:	dd 91       	ld	r29, X+
    344a:	de bf       	out	0x3e, r29	; 62
    344c:	ff 91       	pop	r31
    344e:	ef 91       	pop	r30
    3450:	df 91       	pop	r29
    3452:	cf 91       	pop	r28
    3454:	bf 91       	pop	r27
    3456:	af 91       	pop	r26
    3458:	9f 91       	pop	r25
    345a:	8f 91       	pop	r24
    345c:	7f 91       	pop	r23
    345e:	6f 91       	pop	r22
    3460:	5f 91       	pop	r21
    3462:	4f 91       	pop	r20
    3464:	3f 91       	pop	r19
    3466:	2f 91       	pop	r18
    3468:	1f 91       	pop	r17
    346a:	0f 91       	pop	r16
    346c:	ff 90       	pop	r15
    346e:	ef 90       	pop	r14
    3470:	df 90       	pop	r13
    3472:	cf 90       	pop	r12
    3474:	bf 90       	pop	r11
    3476:	af 90       	pop	r10
    3478:	9f 90       	pop	r9
    347a:	8f 90       	pop	r8
    347c:	7f 90       	pop	r7
    347e:	6f 90       	pop	r6
    3480:	5f 90       	pop	r5
    3482:	4f 90       	pop	r4
    3484:	3f 90       	pop	r3
    3486:	2f 90       	pop	r2
    3488:	1f 90       	pop	r1
    348a:	0f 90       	pop	r0
    348c:	0f be       	out	0x3f, r0	; 63
    348e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3490:	08 95       	ret

00003492 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3492:	0f 92       	push	r0
    3494:	0f b6       	in	r0, 0x3f	; 63
    3496:	f8 94       	cli
    3498:	0f 92       	push	r0
    349a:	1f 92       	push	r1
    349c:	11 24       	eor	r1, r1
    349e:	2f 92       	push	r2
    34a0:	3f 92       	push	r3
    34a2:	4f 92       	push	r4
    34a4:	5f 92       	push	r5
    34a6:	6f 92       	push	r6
    34a8:	7f 92       	push	r7
    34aa:	8f 92       	push	r8
    34ac:	9f 92       	push	r9
    34ae:	af 92       	push	r10
    34b0:	bf 92       	push	r11
    34b2:	cf 92       	push	r12
    34b4:	df 92       	push	r13
    34b6:	ef 92       	push	r14
    34b8:	ff 92       	push	r15
    34ba:	0f 93       	push	r16
    34bc:	1f 93       	push	r17
    34be:	2f 93       	push	r18
    34c0:	3f 93       	push	r19
    34c2:	4f 93       	push	r20
    34c4:	5f 93       	push	r21
    34c6:	6f 93       	push	r22
    34c8:	7f 93       	push	r23
    34ca:	8f 93       	push	r24
    34cc:	9f 93       	push	r25
    34ce:	af 93       	push	r26
    34d0:	bf 93       	push	r27
    34d2:	cf 93       	push	r28
    34d4:	df 93       	push	r29
    34d6:	ef 93       	push	r30
    34d8:	ff 93       	push	r31
    34da:	a0 91 bc 04 	lds	r26, 0x04BC
    34de:	b0 91 bd 04 	lds	r27, 0x04BD
    34e2:	0d b6       	in	r0, 0x3d	; 61
    34e4:	0d 92       	st	X+, r0
    34e6:	0e b6       	in	r0, 0x3e	; 62
    34e8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    34ea:	0e 94 09 24 	call	0x4812	; 0x4812 <vTaskIncrementTick>
	vTaskSwitchContext();
    34ee:	0e 94 de 24 	call	0x49bc	; 0x49bc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    34f2:	a0 91 bc 04 	lds	r26, 0x04BC
    34f6:	b0 91 bd 04 	lds	r27, 0x04BD
    34fa:	cd 91       	ld	r28, X+
    34fc:	cd bf       	out	0x3d, r28	; 61
    34fe:	dd 91       	ld	r29, X+
    3500:	de bf       	out	0x3e, r29	; 62
    3502:	ff 91       	pop	r31
    3504:	ef 91       	pop	r30
    3506:	df 91       	pop	r29
    3508:	cf 91       	pop	r28
    350a:	bf 91       	pop	r27
    350c:	af 91       	pop	r26
    350e:	9f 91       	pop	r25
    3510:	8f 91       	pop	r24
    3512:	7f 91       	pop	r23
    3514:	6f 91       	pop	r22
    3516:	5f 91       	pop	r21
    3518:	4f 91       	pop	r20
    351a:	3f 91       	pop	r19
    351c:	2f 91       	pop	r18
    351e:	1f 91       	pop	r17
    3520:	0f 91       	pop	r16
    3522:	ff 90       	pop	r15
    3524:	ef 90       	pop	r14
    3526:	df 90       	pop	r13
    3528:	cf 90       	pop	r12
    352a:	bf 90       	pop	r11
    352c:	af 90       	pop	r10
    352e:	9f 90       	pop	r9
    3530:	8f 90       	pop	r8
    3532:	7f 90       	pop	r7
    3534:	6f 90       	pop	r6
    3536:	5f 90       	pop	r5
    3538:	4f 90       	pop	r4
    353a:	3f 90       	pop	r3
    353c:	2f 90       	pop	r2
    353e:	1f 90       	pop	r1
    3540:	0f 90       	pop	r0
    3542:	0f be       	out	0x3f, r0	; 63
    3544:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3546:	08 95       	ret

00003548 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3548:	df 93       	push	r29
    354a:	cf 93       	push	r28
    354c:	00 d0       	rcall	.+0      	; 0x354e <prvSetupTimerInterrupt+0x6>
    354e:	00 d0       	rcall	.+0      	; 0x3550 <prvSetupTimerInterrupt+0x8>
    3550:	00 d0       	rcall	.+0      	; 0x3552 <prvSetupTimerInterrupt+0xa>
    3552:	cd b7       	in	r28, 0x3d	; 61
    3554:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3556:	80 e4       	ldi	r24, 0x40	; 64
    3558:	9f e1       	ldi	r25, 0x1F	; 31
    355a:	a0 e0       	ldi	r26, 0x00	; 0
    355c:	b0 e0       	ldi	r27, 0x00	; 0
    355e:	8b 83       	std	Y+3, r24	; 0x03
    3560:	9c 83       	std	Y+4, r25	; 0x04
    3562:	ad 83       	std	Y+5, r26	; 0x05
    3564:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3566:	8b 81       	ldd	r24, Y+3	; 0x03
    3568:	9c 81       	ldd	r25, Y+4	; 0x04
    356a:	ad 81       	ldd	r26, Y+5	; 0x05
    356c:	be 81       	ldd	r27, Y+6	; 0x06
    356e:	68 94       	set
    3570:	15 f8       	bld	r1, 5
    3572:	b6 95       	lsr	r27
    3574:	a7 95       	ror	r26
    3576:	97 95       	ror	r25
    3578:	87 95       	ror	r24
    357a:	16 94       	lsr	r1
    357c:	d1 f7       	brne	.-12     	; 0x3572 <prvSetupTimerInterrupt+0x2a>
    357e:	8b 83       	std	Y+3, r24	; 0x03
    3580:	9c 83       	std	Y+4, r25	; 0x04
    3582:	ad 83       	std	Y+5, r26	; 0x05
    3584:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    3586:	8b 81       	ldd	r24, Y+3	; 0x03
    3588:	9c 81       	ldd	r25, Y+4	; 0x04
    358a:	ad 81       	ldd	r26, Y+5	; 0x05
    358c:	be 81       	ldd	r27, Y+6	; 0x06
    358e:	01 97       	sbiw	r24, 0x01	; 1
    3590:	a1 09       	sbc	r26, r1
    3592:	b1 09       	sbc	r27, r1
    3594:	8b 83       	std	Y+3, r24	; 0x03
    3596:	9c 83       	std	Y+4, r25	; 0x04
    3598:	ad 83       	std	Y+5, r26	; 0x05
    359a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    359c:	8b 81       	ldd	r24, Y+3	; 0x03
    359e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    35a0:	8b 81       	ldd	r24, Y+3	; 0x03
    35a2:	9c 81       	ldd	r25, Y+4	; 0x04
    35a4:	ad 81       	ldd	r26, Y+5	; 0x05
    35a6:	be 81       	ldd	r27, Y+6	; 0x06
    35a8:	89 2f       	mov	r24, r25
    35aa:	9a 2f       	mov	r25, r26
    35ac:	ab 2f       	mov	r26, r27
    35ae:	bb 27       	eor	r27, r27
    35b0:	8b 83       	std	Y+3, r24	; 0x03
    35b2:	9c 83       	std	Y+4, r25	; 0x04
    35b4:	ad 83       	std	Y+5, r26	; 0x05
    35b6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    35b8:	8b 81       	ldd	r24, Y+3	; 0x03
    35ba:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    35bc:	eb e4       	ldi	r30, 0x4B	; 75
    35be:	f0 e0       	ldi	r31, 0x00	; 0
    35c0:	8a 81       	ldd	r24, Y+2	; 0x02
    35c2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    35c4:	ea e4       	ldi	r30, 0x4A	; 74
    35c6:	f0 e0       	ldi	r31, 0x00	; 0
    35c8:	89 81       	ldd	r24, Y+1	; 0x01
    35ca:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    35cc:	8b e0       	ldi	r24, 0x0B	; 11
    35ce:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    35d0:	ee e4       	ldi	r30, 0x4E	; 78
    35d2:	f0 e0       	ldi	r31, 0x00	; 0
    35d4:	89 81       	ldd	r24, Y+1	; 0x01
    35d6:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    35d8:	e9 e5       	ldi	r30, 0x59	; 89
    35da:	f0 e0       	ldi	r31, 0x00	; 0
    35dc:	80 81       	ld	r24, Z
    35de:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    35e0:	89 81       	ldd	r24, Y+1	; 0x01
    35e2:	80 61       	ori	r24, 0x10	; 16
    35e4:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    35e6:	e9 e5       	ldi	r30, 0x59	; 89
    35e8:	f0 e0       	ldi	r31, 0x00	; 0
    35ea:	89 81       	ldd	r24, Y+1	; 0x01
    35ec:	80 83       	st	Z, r24
}
    35ee:	26 96       	adiw	r28, 0x06	; 6
    35f0:	0f b6       	in	r0, 0x3f	; 63
    35f2:	f8 94       	cli
    35f4:	de bf       	out	0x3e, r29	; 62
    35f6:	0f be       	out	0x3f, r0	; 63
    35f8:	cd bf       	out	0x3d, r28	; 61
    35fa:	cf 91       	pop	r28
    35fc:	df 91       	pop	r29
    35fe:	08 95       	ret

00003600 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    3600:	0e 94 49 1a 	call	0x3492	; 0x3492 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3604:	18 95       	reti

00003606 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    3606:	df 93       	push	r29
    3608:	cf 93       	push	r28
    360a:	cd b7       	in	r28, 0x3d	; 61
    360c:	de b7       	in	r29, 0x3e	; 62
    360e:	28 97       	sbiw	r28, 0x08	; 8
    3610:	0f b6       	in	r0, 0x3f	; 63
    3612:	f8 94       	cli
    3614:	de bf       	out	0x3e, r29	; 62
    3616:	0f be       	out	0x3f, r0	; 63
    3618:	cd bf       	out	0x3d, r28	; 61
    361a:	8f 83       	std	Y+7, r24	; 0x07
    361c:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    361e:	1a 82       	std	Y+2, r1	; 0x02
    3620:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3622:	8f 81       	ldd	r24, Y+7	; 0x07
    3624:	88 23       	and	r24, r24
    3626:	09 f4       	brne	.+2      	; 0x362a <xQueueCreate+0x24>
    3628:	8c c0       	rjmp	.+280    	; 0x3742 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    362a:	8f e1       	ldi	r24, 0x1F	; 31
    362c:	90 e0       	ldi	r25, 0x00	; 0
    362e:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <pvPortMalloc>
    3632:	9e 83       	std	Y+6, r25	; 0x06
    3634:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3636:	8d 81       	ldd	r24, Y+5	; 0x05
    3638:	9e 81       	ldd	r25, Y+6	; 0x06
    363a:	00 97       	sbiw	r24, 0x00	; 0
    363c:	09 f4       	brne	.+2      	; 0x3640 <xQueueCreate+0x3a>
    363e:	81 c0       	rjmp	.+258    	; 0x3742 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    3640:	8f 81       	ldd	r24, Y+7	; 0x07
    3642:	28 2f       	mov	r18, r24
    3644:	30 e0       	ldi	r19, 0x00	; 0
    3646:	88 85       	ldd	r24, Y+8	; 0x08
    3648:	88 2f       	mov	r24, r24
    364a:	90 e0       	ldi	r25, 0x00	; 0
    364c:	ac 01       	movw	r20, r24
    364e:	24 9f       	mul	r18, r20
    3650:	c0 01       	movw	r24, r0
    3652:	25 9f       	mul	r18, r21
    3654:	90 0d       	add	r25, r0
    3656:	34 9f       	mul	r19, r20
    3658:	90 0d       	add	r25, r0
    365a:	11 24       	eor	r1, r1
    365c:	01 96       	adiw	r24, 0x01	; 1
    365e:	9c 83       	std	Y+4, r25	; 0x04
    3660:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    3662:	8b 81       	ldd	r24, Y+3	; 0x03
    3664:	9c 81       	ldd	r25, Y+4	; 0x04
    3666:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <pvPortMalloc>
    366a:	ed 81       	ldd	r30, Y+5	; 0x05
    366c:	fe 81       	ldd	r31, Y+6	; 0x06
    366e:	91 83       	std	Z+1, r25	; 0x01
    3670:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3672:	ed 81       	ldd	r30, Y+5	; 0x05
    3674:	fe 81       	ldd	r31, Y+6	; 0x06
    3676:	80 81       	ld	r24, Z
    3678:	91 81       	ldd	r25, Z+1	; 0x01
    367a:	00 97       	sbiw	r24, 0x00	; 0
    367c:	09 f4       	brne	.+2      	; 0x3680 <xQueueCreate+0x7a>
    367e:	5d c0       	rjmp	.+186    	; 0x373a <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    3680:	ed 81       	ldd	r30, Y+5	; 0x05
    3682:	fe 81       	ldd	r31, Y+6	; 0x06
    3684:	40 81       	ld	r20, Z
    3686:	51 81       	ldd	r21, Z+1	; 0x01
    3688:	8f 81       	ldd	r24, Y+7	; 0x07
    368a:	28 2f       	mov	r18, r24
    368c:	30 e0       	ldi	r19, 0x00	; 0
    368e:	88 85       	ldd	r24, Y+8	; 0x08
    3690:	88 2f       	mov	r24, r24
    3692:	90 e0       	ldi	r25, 0x00	; 0
    3694:	bc 01       	movw	r22, r24
    3696:	26 9f       	mul	r18, r22
    3698:	c0 01       	movw	r24, r0
    369a:	27 9f       	mul	r18, r23
    369c:	90 0d       	add	r25, r0
    369e:	36 9f       	mul	r19, r22
    36a0:	90 0d       	add	r25, r0
    36a2:	11 24       	eor	r1, r1
    36a4:	84 0f       	add	r24, r20
    36a6:	95 1f       	adc	r25, r21
    36a8:	ed 81       	ldd	r30, Y+5	; 0x05
    36aa:	fe 81       	ldd	r31, Y+6	; 0x06
    36ac:	93 83       	std	Z+3, r25	; 0x03
    36ae:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    36b0:	ed 81       	ldd	r30, Y+5	; 0x05
    36b2:	fe 81       	ldd	r31, Y+6	; 0x06
    36b4:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    36b6:	ed 81       	ldd	r30, Y+5	; 0x05
    36b8:	fe 81       	ldd	r31, Y+6	; 0x06
    36ba:	80 81       	ld	r24, Z
    36bc:	91 81       	ldd	r25, Z+1	; 0x01
    36be:	ed 81       	ldd	r30, Y+5	; 0x05
    36c0:	fe 81       	ldd	r31, Y+6	; 0x06
    36c2:	95 83       	std	Z+5, r25	; 0x05
    36c4:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    36c6:	ed 81       	ldd	r30, Y+5	; 0x05
    36c8:	fe 81       	ldd	r31, Y+6	; 0x06
    36ca:	40 81       	ld	r20, Z
    36cc:	51 81       	ldd	r21, Z+1	; 0x01
    36ce:	8f 81       	ldd	r24, Y+7	; 0x07
    36d0:	88 2f       	mov	r24, r24
    36d2:	90 e0       	ldi	r25, 0x00	; 0
    36d4:	9c 01       	movw	r18, r24
    36d6:	21 50       	subi	r18, 0x01	; 1
    36d8:	30 40       	sbci	r19, 0x00	; 0
    36da:	88 85       	ldd	r24, Y+8	; 0x08
    36dc:	88 2f       	mov	r24, r24
    36de:	90 e0       	ldi	r25, 0x00	; 0
    36e0:	bc 01       	movw	r22, r24
    36e2:	26 9f       	mul	r18, r22
    36e4:	c0 01       	movw	r24, r0
    36e6:	27 9f       	mul	r18, r23
    36e8:	90 0d       	add	r25, r0
    36ea:	36 9f       	mul	r19, r22
    36ec:	90 0d       	add	r25, r0
    36ee:	11 24       	eor	r1, r1
    36f0:	84 0f       	add	r24, r20
    36f2:	95 1f       	adc	r25, r21
    36f4:	ed 81       	ldd	r30, Y+5	; 0x05
    36f6:	fe 81       	ldd	r31, Y+6	; 0x06
    36f8:	97 83       	std	Z+7, r25	; 0x07
    36fa:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    36fc:	ed 81       	ldd	r30, Y+5	; 0x05
    36fe:	fe 81       	ldd	r31, Y+6	; 0x06
    3700:	8f 81       	ldd	r24, Y+7	; 0x07
    3702:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3704:	ed 81       	ldd	r30, Y+5	; 0x05
    3706:	fe 81       	ldd	r31, Y+6	; 0x06
    3708:	88 85       	ldd	r24, Y+8	; 0x08
    370a:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    370c:	ed 81       	ldd	r30, Y+5	; 0x05
    370e:	fe 81       	ldd	r31, Y+6	; 0x06
    3710:	8f ef       	ldi	r24, 0xFF	; 255
    3712:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3714:	ed 81       	ldd	r30, Y+5	; 0x05
    3716:	fe 81       	ldd	r31, Y+6	; 0x06
    3718:	8f ef       	ldi	r24, 0xFF	; 255
    371a:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    371c:	8d 81       	ldd	r24, Y+5	; 0x05
    371e:	9e 81       	ldd	r25, Y+6	; 0x06
    3720:	08 96       	adiw	r24, 0x08	; 8
    3722:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3726:	8d 81       	ldd	r24, Y+5	; 0x05
    3728:	9e 81       	ldd	r25, Y+6	; 0x06
    372a:	41 96       	adiw	r24, 0x11	; 17
    372c:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3730:	8d 81       	ldd	r24, Y+5	; 0x05
    3732:	9e 81       	ldd	r25, Y+6	; 0x06
    3734:	9a 83       	std	Y+2, r25	; 0x02
    3736:	89 83       	std	Y+1, r24	; 0x01
    3738:	04 c0       	rjmp	.+8      	; 0x3742 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    373a:	8d 81       	ldd	r24, Y+5	; 0x05
    373c:	9e 81       	ldd	r25, Y+6	; 0x06
    373e:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3742:	89 81       	ldd	r24, Y+1	; 0x01
    3744:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3746:	28 96       	adiw	r28, 0x08	; 8
    3748:	0f b6       	in	r0, 0x3f	; 63
    374a:	f8 94       	cli
    374c:	de bf       	out	0x3e, r29	; 62
    374e:	0f be       	out	0x3f, r0	; 63
    3750:	cd bf       	out	0x3d, r28	; 61
    3752:	cf 91       	pop	r28
    3754:	df 91       	pop	r29
    3756:	08 95       	ret

00003758 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    3758:	df 93       	push	r29
    375a:	cf 93       	push	r28
    375c:	00 d0       	rcall	.+0      	; 0x375e <xQueueCreateCountingSemaphore+0x6>
    375e:	00 d0       	rcall	.+0      	; 0x3760 <xQueueCreateCountingSemaphore+0x8>
    3760:	cd b7       	in	r28, 0x3d	; 61
    3762:	de b7       	in	r29, 0x3e	; 62
    3764:	8b 83       	std	Y+3, r24	; 0x03
    3766:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    3768:	8b 81       	ldd	r24, Y+3	; 0x03
    376a:	60 e0       	ldi	r22, 0x00	; 0
    376c:	0e 94 03 1b 	call	0x3606	; 0x3606 <xQueueCreate>
    3770:	9a 83       	std	Y+2, r25	; 0x02
    3772:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    3774:	89 81       	ldd	r24, Y+1	; 0x01
    3776:	9a 81       	ldd	r25, Y+2	; 0x02
    3778:	00 97       	sbiw	r24, 0x00	; 0
    377a:	21 f0       	breq	.+8      	; 0x3784 <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    377c:	e9 81       	ldd	r30, Y+1	; 0x01
    377e:	fa 81       	ldd	r31, Y+2	; 0x02
    3780:	8c 81       	ldd	r24, Y+4	; 0x04
    3782:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    3784:	89 81       	ldd	r24, Y+1	; 0x01
    3786:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3788:	0f 90       	pop	r0
    378a:	0f 90       	pop	r0
    378c:	0f 90       	pop	r0
    378e:	0f 90       	pop	r0
    3790:	cf 91       	pop	r28
    3792:	df 91       	pop	r29
    3794:	08 95       	ret

00003796 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    3796:	df 93       	push	r29
    3798:	cf 93       	push	r28
    379a:	cd b7       	in	r28, 0x3d	; 61
    379c:	de b7       	in	r29, 0x3e	; 62
    379e:	2c 97       	sbiw	r28, 0x0c	; 12
    37a0:	0f b6       	in	r0, 0x3f	; 63
    37a2:	f8 94       	cli
    37a4:	de bf       	out	0x3e, r29	; 62
    37a6:	0f be       	out	0x3f, r0	; 63
    37a8:	cd bf       	out	0x3d, r28	; 61
    37aa:	9e 83       	std	Y+6, r25	; 0x06
    37ac:	8d 83       	std	Y+5, r24	; 0x05
    37ae:	78 87       	std	Y+8, r23	; 0x08
    37b0:	6f 83       	std	Y+7, r22	; 0x07
    37b2:	5a 87       	std	Y+10, r21	; 0x0a
    37b4:	49 87       	std	Y+9, r20	; 0x09
    37b6:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    37b8:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    37ba:	0f b6       	in	r0, 0x3f	; 63
    37bc:	f8 94       	cli
    37be:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    37c0:	ed 81       	ldd	r30, Y+5	; 0x05
    37c2:	fe 81       	ldd	r31, Y+6	; 0x06
    37c4:	92 8d       	ldd	r25, Z+26	; 0x1a
    37c6:	ed 81       	ldd	r30, Y+5	; 0x05
    37c8:	fe 81       	ldd	r31, Y+6	; 0x06
    37ca:	83 8d       	ldd	r24, Z+27	; 0x1b
    37cc:	98 17       	cp	r25, r24
    37ce:	d8 f4       	brcc	.+54     	; 0x3806 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    37d0:	8d 81       	ldd	r24, Y+5	; 0x05
    37d2:	9e 81       	ldd	r25, Y+6	; 0x06
    37d4:	2f 81       	ldd	r18, Y+7	; 0x07
    37d6:	38 85       	ldd	r19, Y+8	; 0x08
    37d8:	b9 01       	movw	r22, r18
    37da:	4b 85       	ldd	r20, Y+11	; 0x0b
    37dc:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    37e0:	ed 81       	ldd	r30, Y+5	; 0x05
    37e2:	fe 81       	ldd	r31, Y+6	; 0x06
    37e4:	81 89       	ldd	r24, Z+17	; 0x11
    37e6:	88 23       	and	r24, r24
    37e8:	49 f0       	breq	.+18     	; 0x37fc <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    37ea:	8d 81       	ldd	r24, Y+5	; 0x05
    37ec:	9e 81       	ldd	r25, Y+6	; 0x06
    37ee:	41 96       	adiw	r24, 0x11	; 17
    37f0:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskRemoveFromEventList>
    37f4:	81 30       	cpi	r24, 0x01	; 1
    37f6:	11 f4       	brne	.+4      	; 0x37fc <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    37f8:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    37fc:	0f 90       	pop	r0
    37fe:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3800:	81 e0       	ldi	r24, 0x01	; 1
    3802:	8c 87       	std	Y+12, r24	; 0x0c
    3804:	5c c0       	rjmp	.+184    	; 0x38be <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3806:	89 85       	ldd	r24, Y+9	; 0x09
    3808:	9a 85       	ldd	r25, Y+10	; 0x0a
    380a:	00 97       	sbiw	r24, 0x00	; 0
    380c:	21 f4       	brne	.+8      	; 0x3816 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    380e:	0f 90       	pop	r0
    3810:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3812:	1c 86       	std	Y+12, r1	; 0x0c
    3814:	54 c0       	rjmp	.+168    	; 0x38be <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3816:	89 81       	ldd	r24, Y+1	; 0x01
    3818:	88 23       	and	r24, r24
    381a:	31 f4       	brne	.+12     	; 0x3828 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    381c:	ce 01       	movw	r24, r28
    381e:	02 96       	adiw	r24, 0x02	; 2
    3820:	0e 94 f5 25 	call	0x4bea	; 0x4bea <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3824:	81 e0       	ldi	r24, 0x01	; 1
    3826:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3828:	0f 90       	pop	r0
    382a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    382c:	0e 94 3e 23 	call	0x467c	; 0x467c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3830:	0f b6       	in	r0, 0x3f	; 63
    3832:	f8 94       	cli
    3834:	0f 92       	push	r0
    3836:	ed 81       	ldd	r30, Y+5	; 0x05
    3838:	fe 81       	ldd	r31, Y+6	; 0x06
    383a:	85 8d       	ldd	r24, Z+29	; 0x1d
    383c:	8f 3f       	cpi	r24, 0xFF	; 255
    383e:	19 f4       	brne	.+6      	; 0x3846 <xQueueGenericSend+0xb0>
    3840:	ed 81       	ldd	r30, Y+5	; 0x05
    3842:	fe 81       	ldd	r31, Y+6	; 0x06
    3844:	15 8e       	std	Z+29, r1	; 0x1d
    3846:	ed 81       	ldd	r30, Y+5	; 0x05
    3848:	fe 81       	ldd	r31, Y+6	; 0x06
    384a:	86 8d       	ldd	r24, Z+30	; 0x1e
    384c:	8f 3f       	cpi	r24, 0xFF	; 255
    384e:	19 f4       	brne	.+6      	; 0x3856 <xQueueGenericSend+0xc0>
    3850:	ed 81       	ldd	r30, Y+5	; 0x05
    3852:	fe 81       	ldd	r31, Y+6	; 0x06
    3854:	16 8e       	std	Z+30, r1	; 0x1e
    3856:	0f 90       	pop	r0
    3858:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    385a:	ce 01       	movw	r24, r28
    385c:	02 96       	adiw	r24, 0x02	; 2
    385e:	9e 01       	movw	r18, r28
    3860:	27 5f       	subi	r18, 0xF7	; 247
    3862:	3f 4f       	sbci	r19, 0xFF	; 255
    3864:	b9 01       	movw	r22, r18
    3866:	0e 94 0e 26 	call	0x4c1c	; 0x4c1c <xTaskCheckForTimeOut>
    386a:	88 23       	and	r24, r24
    386c:	09 f5       	brne	.+66     	; 0x38b0 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    386e:	8d 81       	ldd	r24, Y+5	; 0x05
    3870:	9e 81       	ldd	r25, Y+6	; 0x06
    3872:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <prvIsQueueFull>
    3876:	88 23       	and	r24, r24
    3878:	a1 f0       	breq	.+40     	; 0x38a2 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    387a:	8d 81       	ldd	r24, Y+5	; 0x05
    387c:	9e 81       	ldd	r25, Y+6	; 0x06
    387e:	08 96       	adiw	r24, 0x08	; 8
    3880:	29 85       	ldd	r18, Y+9	; 0x09
    3882:	3a 85       	ldd	r19, Y+10	; 0x0a
    3884:	b9 01       	movw	r22, r18
    3886:	0e 94 44 25 	call	0x4a88	; 0x4a88 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    388a:	8d 81       	ldd	r24, Y+5	; 0x05
    388c:	9e 81       	ldd	r25, Y+6	; 0x06
    388e:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3892:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>
    3896:	88 23       	and	r24, r24
    3898:	09 f0       	breq	.+2      	; 0x389c <xQueueGenericSend+0x106>
    389a:	8f cf       	rjmp	.-226    	; 0x37ba <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    389c:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
    38a0:	8c cf       	rjmp	.-232    	; 0x37ba <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    38a2:	8d 81       	ldd	r24, Y+5	; 0x05
    38a4:	9e 81       	ldd	r25, Y+6	; 0x06
    38a6:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    38aa:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>
    38ae:	85 cf       	rjmp	.-246    	; 0x37ba <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    38b0:	8d 81       	ldd	r24, Y+5	; 0x05
    38b2:	9e 81       	ldd	r25, Y+6	; 0x06
    38b4:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    38b8:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    38bc:	1c 86       	std	Y+12, r1	; 0x0c
    38be:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    38c0:	2c 96       	adiw	r28, 0x0c	; 12
    38c2:	0f b6       	in	r0, 0x3f	; 63
    38c4:	f8 94       	cli
    38c6:	de bf       	out	0x3e, r29	; 62
    38c8:	0f be       	out	0x3f, r0	; 63
    38ca:	cd bf       	out	0x3d, r28	; 61
    38cc:	cf 91       	pop	r28
    38ce:	df 91       	pop	r29
    38d0:	08 95       	ret

000038d2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    38d2:	df 93       	push	r29
    38d4:	cf 93       	push	r28
    38d6:	cd b7       	in	r28, 0x3d	; 61
    38d8:	de b7       	in	r29, 0x3e	; 62
    38da:	29 97       	sbiw	r28, 0x09	; 9
    38dc:	0f b6       	in	r0, 0x3f	; 63
    38de:	f8 94       	cli
    38e0:	de bf       	out	0x3e, r29	; 62
    38e2:	0f be       	out	0x3f, r0	; 63
    38e4:	cd bf       	out	0x3d, r28	; 61
    38e6:	9c 83       	std	Y+4, r25	; 0x04
    38e8:	8b 83       	std	Y+3, r24	; 0x03
    38ea:	7e 83       	std	Y+6, r23	; 0x06
    38ec:	6d 83       	std	Y+5, r22	; 0x05
    38ee:	58 87       	std	Y+8, r21	; 0x08
    38f0:	4f 83       	std	Y+7, r20	; 0x07
    38f2:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    38f4:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    38f6:	eb 81       	ldd	r30, Y+3	; 0x03
    38f8:	fc 81       	ldd	r31, Y+4	; 0x04
    38fa:	92 8d       	ldd	r25, Z+26	; 0x1a
    38fc:	eb 81       	ldd	r30, Y+3	; 0x03
    38fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3900:	83 8d       	ldd	r24, Z+27	; 0x1b
    3902:	98 17       	cp	r25, r24
    3904:	40 f5       	brcc	.+80     	; 0x3956 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3906:	8b 81       	ldd	r24, Y+3	; 0x03
    3908:	9c 81       	ldd	r25, Y+4	; 0x04
    390a:	2d 81       	ldd	r18, Y+5	; 0x05
    390c:	3e 81       	ldd	r19, Y+6	; 0x06
    390e:	b9 01       	movw	r22, r18
    3910:	49 85       	ldd	r20, Y+9	; 0x09
    3912:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3916:	eb 81       	ldd	r30, Y+3	; 0x03
    3918:	fc 81       	ldd	r31, Y+4	; 0x04
    391a:	86 8d       	ldd	r24, Z+30	; 0x1e
    391c:	8f 3f       	cpi	r24, 0xFF	; 255
    391e:	89 f4       	brne	.+34     	; 0x3942 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3920:	eb 81       	ldd	r30, Y+3	; 0x03
    3922:	fc 81       	ldd	r31, Y+4	; 0x04
    3924:	81 89       	ldd	r24, Z+17	; 0x11
    3926:	88 23       	and	r24, r24
    3928:	99 f0       	breq	.+38     	; 0x3950 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    392a:	8b 81       	ldd	r24, Y+3	; 0x03
    392c:	9c 81       	ldd	r25, Y+4	; 0x04
    392e:	41 96       	adiw	r24, 0x11	; 17
    3930:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskRemoveFromEventList>
    3934:	88 23       	and	r24, r24
    3936:	61 f0       	breq	.+24     	; 0x3950 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3938:	ef 81       	ldd	r30, Y+7	; 0x07
    393a:	f8 85       	ldd	r31, Y+8	; 0x08
    393c:	81 e0       	ldi	r24, 0x01	; 1
    393e:	80 83       	st	Z, r24
    3940:	07 c0       	rjmp	.+14     	; 0x3950 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3942:	eb 81       	ldd	r30, Y+3	; 0x03
    3944:	fc 81       	ldd	r31, Y+4	; 0x04
    3946:	86 8d       	ldd	r24, Z+30	; 0x1e
    3948:	8f 5f       	subi	r24, 0xFF	; 255
    394a:	eb 81       	ldd	r30, Y+3	; 0x03
    394c:	fc 81       	ldd	r31, Y+4	; 0x04
    394e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3950:	81 e0       	ldi	r24, 0x01	; 1
    3952:	8a 83       	std	Y+2, r24	; 0x02
    3954:	01 c0       	rjmp	.+2      	; 0x3958 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3956:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3958:	8a 81       	ldd	r24, Y+2	; 0x02
}
    395a:	29 96       	adiw	r28, 0x09	; 9
    395c:	0f b6       	in	r0, 0x3f	; 63
    395e:	f8 94       	cli
    3960:	de bf       	out	0x3e, r29	; 62
    3962:	0f be       	out	0x3f, r0	; 63
    3964:	cd bf       	out	0x3d, r28	; 61
    3966:	cf 91       	pop	r28
    3968:	df 91       	pop	r29
    396a:	08 95       	ret

0000396c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    396c:	df 93       	push	r29
    396e:	cf 93       	push	r28
    3970:	cd b7       	in	r28, 0x3d	; 61
    3972:	de b7       	in	r29, 0x3e	; 62
    3974:	2e 97       	sbiw	r28, 0x0e	; 14
    3976:	0f b6       	in	r0, 0x3f	; 63
    3978:	f8 94       	cli
    397a:	de bf       	out	0x3e, r29	; 62
    397c:	0f be       	out	0x3f, r0	; 63
    397e:	cd bf       	out	0x3d, r28	; 61
    3980:	98 87       	std	Y+8, r25	; 0x08
    3982:	8f 83       	std	Y+7, r24	; 0x07
    3984:	7a 87       	std	Y+10, r23	; 0x0a
    3986:	69 87       	std	Y+9, r22	; 0x09
    3988:	5c 87       	std	Y+12, r21	; 0x0c
    398a:	4b 87       	std	Y+11, r20	; 0x0b
    398c:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    398e:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3990:	0f b6       	in	r0, 0x3f	; 63
    3992:	f8 94       	cli
    3994:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3996:	ef 81       	ldd	r30, Y+7	; 0x07
    3998:	f8 85       	ldd	r31, Y+8	; 0x08
    399a:	82 8d       	ldd	r24, Z+26	; 0x1a
    399c:	88 23       	and	r24, r24
    399e:	09 f4       	brne	.+2      	; 0x39a2 <xQueueGenericReceive+0x36>
    39a0:	3f c0       	rjmp	.+126    	; 0x3a20 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    39a2:	ef 81       	ldd	r30, Y+7	; 0x07
    39a4:	f8 85       	ldd	r31, Y+8	; 0x08
    39a6:	86 81       	ldd	r24, Z+6	; 0x06
    39a8:	97 81       	ldd	r25, Z+7	; 0x07
    39aa:	9a 83       	std	Y+2, r25	; 0x02
    39ac:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    39ae:	8f 81       	ldd	r24, Y+7	; 0x07
    39b0:	98 85       	ldd	r25, Y+8	; 0x08
    39b2:	29 85       	ldd	r18, Y+9	; 0x09
    39b4:	3a 85       	ldd	r19, Y+10	; 0x0a
    39b6:	b9 01       	movw	r22, r18
    39b8:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    39bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    39be:	88 23       	and	r24, r24
    39c0:	b1 f4       	brne	.+44     	; 0x39ee <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    39c2:	ef 81       	ldd	r30, Y+7	; 0x07
    39c4:	f8 85       	ldd	r31, Y+8	; 0x08
    39c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    39c8:	81 50       	subi	r24, 0x01	; 1
    39ca:	ef 81       	ldd	r30, Y+7	; 0x07
    39cc:	f8 85       	ldd	r31, Y+8	; 0x08
    39ce:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    39d0:	ef 81       	ldd	r30, Y+7	; 0x07
    39d2:	f8 85       	ldd	r31, Y+8	; 0x08
    39d4:	80 85       	ldd	r24, Z+8	; 0x08
    39d6:	88 23       	and	r24, r24
    39d8:	f1 f0       	breq	.+60     	; 0x3a16 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    39da:	8f 81       	ldd	r24, Y+7	; 0x07
    39dc:	98 85       	ldd	r25, Y+8	; 0x08
    39de:	08 96       	adiw	r24, 0x08	; 8
    39e0:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskRemoveFromEventList>
    39e4:	81 30       	cpi	r24, 0x01	; 1
    39e6:	b9 f4       	brne	.+46     	; 0x3a16 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    39e8:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
    39ec:	14 c0       	rjmp	.+40     	; 0x3a16 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    39ee:	ef 81       	ldd	r30, Y+7	; 0x07
    39f0:	f8 85       	ldd	r31, Y+8	; 0x08
    39f2:	89 81       	ldd	r24, Y+1	; 0x01
    39f4:	9a 81       	ldd	r25, Y+2	; 0x02
    39f6:	97 83       	std	Z+7, r25	; 0x07
    39f8:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    39fa:	ef 81       	ldd	r30, Y+7	; 0x07
    39fc:	f8 85       	ldd	r31, Y+8	; 0x08
    39fe:	81 89       	ldd	r24, Z+17	; 0x11
    3a00:	88 23       	and	r24, r24
    3a02:	49 f0       	breq	.+18     	; 0x3a16 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3a04:	8f 81       	ldd	r24, Y+7	; 0x07
    3a06:	98 85       	ldd	r25, Y+8	; 0x08
    3a08:	41 96       	adiw	r24, 0x11	; 17
    3a0a:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskRemoveFromEventList>
    3a0e:	88 23       	and	r24, r24
    3a10:	11 f0       	breq	.+4      	; 0x3a16 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3a12:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3a16:	0f 90       	pop	r0
    3a18:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3a1a:	81 e0       	ldi	r24, 0x01	; 1
    3a1c:	8e 87       	std	Y+14, r24	; 0x0e
    3a1e:	5c c0       	rjmp	.+184    	; 0x3ad8 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3a20:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a22:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a24:	00 97       	sbiw	r24, 0x00	; 0
    3a26:	21 f4       	brne	.+8      	; 0x3a30 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3a28:	0f 90       	pop	r0
    3a2a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3a2c:	1e 86       	std	Y+14, r1	; 0x0e
    3a2e:	54 c0       	rjmp	.+168    	; 0x3ad8 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3a30:	8b 81       	ldd	r24, Y+3	; 0x03
    3a32:	88 23       	and	r24, r24
    3a34:	31 f4       	brne	.+12     	; 0x3a42 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3a36:	ce 01       	movw	r24, r28
    3a38:	04 96       	adiw	r24, 0x04	; 4
    3a3a:	0e 94 f5 25 	call	0x4bea	; 0x4bea <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3a3e:	81 e0       	ldi	r24, 0x01	; 1
    3a40:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3a42:	0f 90       	pop	r0
    3a44:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3a46:	0e 94 3e 23 	call	0x467c	; 0x467c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3a4a:	0f b6       	in	r0, 0x3f	; 63
    3a4c:	f8 94       	cli
    3a4e:	0f 92       	push	r0
    3a50:	ef 81       	ldd	r30, Y+7	; 0x07
    3a52:	f8 85       	ldd	r31, Y+8	; 0x08
    3a54:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a56:	8f 3f       	cpi	r24, 0xFF	; 255
    3a58:	19 f4       	brne	.+6      	; 0x3a60 <xQueueGenericReceive+0xf4>
    3a5a:	ef 81       	ldd	r30, Y+7	; 0x07
    3a5c:	f8 85       	ldd	r31, Y+8	; 0x08
    3a5e:	15 8e       	std	Z+29, r1	; 0x1d
    3a60:	ef 81       	ldd	r30, Y+7	; 0x07
    3a62:	f8 85       	ldd	r31, Y+8	; 0x08
    3a64:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a66:	8f 3f       	cpi	r24, 0xFF	; 255
    3a68:	19 f4       	brne	.+6      	; 0x3a70 <xQueueGenericReceive+0x104>
    3a6a:	ef 81       	ldd	r30, Y+7	; 0x07
    3a6c:	f8 85       	ldd	r31, Y+8	; 0x08
    3a6e:	16 8e       	std	Z+30, r1	; 0x1e
    3a70:	0f 90       	pop	r0
    3a72:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3a74:	ce 01       	movw	r24, r28
    3a76:	04 96       	adiw	r24, 0x04	; 4
    3a78:	9e 01       	movw	r18, r28
    3a7a:	25 5f       	subi	r18, 0xF5	; 245
    3a7c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a7e:	b9 01       	movw	r22, r18
    3a80:	0e 94 0e 26 	call	0x4c1c	; 0x4c1c <xTaskCheckForTimeOut>
    3a84:	88 23       	and	r24, r24
    3a86:	09 f5       	brne	.+66     	; 0x3aca <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3a88:	8f 81       	ldd	r24, Y+7	; 0x07
    3a8a:	98 85       	ldd	r25, Y+8	; 0x08
    3a8c:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <prvIsQueueEmpty>
    3a90:	88 23       	and	r24, r24
    3a92:	a1 f0       	breq	.+40     	; 0x3abc <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3a94:	8f 81       	ldd	r24, Y+7	; 0x07
    3a96:	98 85       	ldd	r25, Y+8	; 0x08
    3a98:	41 96       	adiw	r24, 0x11	; 17
    3a9a:	2b 85       	ldd	r18, Y+11	; 0x0b
    3a9c:	3c 85       	ldd	r19, Y+12	; 0x0c
    3a9e:	b9 01       	movw	r22, r18
    3aa0:	0e 94 44 25 	call	0x4a88	; 0x4a88 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3aa4:	8f 81       	ldd	r24, Y+7	; 0x07
    3aa6:	98 85       	ldd	r25, Y+8	; 0x08
    3aa8:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3aac:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>
    3ab0:	88 23       	and	r24, r24
    3ab2:	09 f0       	breq	.+2      	; 0x3ab6 <xQueueGenericReceive+0x14a>
    3ab4:	6d cf       	rjmp	.-294    	; 0x3990 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    3ab6:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
    3aba:	6a cf       	rjmp	.-300    	; 0x3990 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3abc:	8f 81       	ldd	r24, Y+7	; 0x07
    3abe:	98 85       	ldd	r25, Y+8	; 0x08
    3ac0:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3ac4:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>
    3ac8:	63 cf       	rjmp	.-314    	; 0x3990 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3aca:	8f 81       	ldd	r24, Y+7	; 0x07
    3acc:	98 85       	ldd	r25, Y+8	; 0x08
    3ace:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3ad2:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3ad6:	1e 86       	std	Y+14, r1	; 0x0e
    3ad8:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3ada:	2e 96       	adiw	r28, 0x0e	; 14
    3adc:	0f b6       	in	r0, 0x3f	; 63
    3ade:	f8 94       	cli
    3ae0:	de bf       	out	0x3e, r29	; 62
    3ae2:	0f be       	out	0x3f, r0	; 63
    3ae4:	cd bf       	out	0x3d, r28	; 61
    3ae6:	cf 91       	pop	r28
    3ae8:	df 91       	pop	r29
    3aea:	08 95       	ret

00003aec <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3aec:	df 93       	push	r29
    3aee:	cf 93       	push	r28
    3af0:	cd b7       	in	r28, 0x3d	; 61
    3af2:	de b7       	in	r29, 0x3e	; 62
    3af4:	28 97       	sbiw	r28, 0x08	; 8
    3af6:	0f b6       	in	r0, 0x3f	; 63
    3af8:	f8 94       	cli
    3afa:	de bf       	out	0x3e, r29	; 62
    3afc:	0f be       	out	0x3f, r0	; 63
    3afe:	cd bf       	out	0x3d, r28	; 61
    3b00:	9c 83       	std	Y+4, r25	; 0x04
    3b02:	8b 83       	std	Y+3, r24	; 0x03
    3b04:	7e 83       	std	Y+6, r23	; 0x06
    3b06:	6d 83       	std	Y+5, r22	; 0x05
    3b08:	58 87       	std	Y+8, r21	; 0x08
    3b0a:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3b0c:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3b0e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b10:	fc 81       	ldd	r31, Y+4	; 0x04
    3b12:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b14:	88 23       	and	r24, r24
    3b16:	71 f1       	breq	.+92     	; 0x3b74 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3b18:	8b 81       	ldd	r24, Y+3	; 0x03
    3b1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3b1c:	2d 81       	ldd	r18, Y+5	; 0x05
    3b1e:	3e 81       	ldd	r19, Y+6	; 0x06
    3b20:	b9 01       	movw	r22, r18
    3b22:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3b26:	eb 81       	ldd	r30, Y+3	; 0x03
    3b28:	fc 81       	ldd	r31, Y+4	; 0x04
    3b2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b2c:	81 50       	subi	r24, 0x01	; 1
    3b2e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b30:	fc 81       	ldd	r31, Y+4	; 0x04
    3b32:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3b34:	eb 81       	ldd	r30, Y+3	; 0x03
    3b36:	fc 81       	ldd	r31, Y+4	; 0x04
    3b38:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b3a:	8f 3f       	cpi	r24, 0xFF	; 255
    3b3c:	89 f4       	brne	.+34     	; 0x3b60 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3b3e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b40:	fc 81       	ldd	r31, Y+4	; 0x04
    3b42:	80 85       	ldd	r24, Z+8	; 0x08
    3b44:	88 23       	and	r24, r24
    3b46:	99 f0       	breq	.+38     	; 0x3b6e <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3b48:	8b 81       	ldd	r24, Y+3	; 0x03
    3b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3b4c:	08 96       	adiw	r24, 0x08	; 8
    3b4e:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskRemoveFromEventList>
    3b52:	88 23       	and	r24, r24
    3b54:	61 f0       	breq	.+24     	; 0x3b6e <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3b56:	ef 81       	ldd	r30, Y+7	; 0x07
    3b58:	f8 85       	ldd	r31, Y+8	; 0x08
    3b5a:	81 e0       	ldi	r24, 0x01	; 1
    3b5c:	80 83       	st	Z, r24
    3b5e:	07 c0       	rjmp	.+14     	; 0x3b6e <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3b60:	eb 81       	ldd	r30, Y+3	; 0x03
    3b62:	fc 81       	ldd	r31, Y+4	; 0x04
    3b64:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b66:	8f 5f       	subi	r24, 0xFF	; 255
    3b68:	eb 81       	ldd	r30, Y+3	; 0x03
    3b6a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b6c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3b6e:	81 e0       	ldi	r24, 0x01	; 1
    3b70:	8a 83       	std	Y+2, r24	; 0x02
    3b72:	01 c0       	rjmp	.+2      	; 0x3b76 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    3b74:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3b76:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3b78:	28 96       	adiw	r28, 0x08	; 8
    3b7a:	0f b6       	in	r0, 0x3f	; 63
    3b7c:	f8 94       	cli
    3b7e:	de bf       	out	0x3e, r29	; 62
    3b80:	0f be       	out	0x3f, r0	; 63
    3b82:	cd bf       	out	0x3d, r28	; 61
    3b84:	cf 91       	pop	r28
    3b86:	df 91       	pop	r29
    3b88:	08 95       	ret

00003b8a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3b8a:	df 93       	push	r29
    3b8c:	cf 93       	push	r28
    3b8e:	00 d0       	rcall	.+0      	; 0x3b90 <uxQueueMessagesWaiting+0x6>
    3b90:	0f 92       	push	r0
    3b92:	cd b7       	in	r28, 0x3d	; 61
    3b94:	de b7       	in	r29, 0x3e	; 62
    3b96:	9b 83       	std	Y+3, r25	; 0x03
    3b98:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3b9a:	0f b6       	in	r0, 0x3f	; 63
    3b9c:	f8 94       	cli
    3b9e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    3ba0:	ea 81       	ldd	r30, Y+2	; 0x02
    3ba2:	fb 81       	ldd	r31, Y+3	; 0x03
    3ba4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ba6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3ba8:	0f 90       	pop	r0
    3baa:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3bac:	89 81       	ldd	r24, Y+1	; 0x01
}
    3bae:	0f 90       	pop	r0
    3bb0:	0f 90       	pop	r0
    3bb2:	0f 90       	pop	r0
    3bb4:	cf 91       	pop	r28
    3bb6:	df 91       	pop	r29
    3bb8:	08 95       	ret

00003bba <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    3bba:	df 93       	push	r29
    3bbc:	cf 93       	push	r28
    3bbe:	00 d0       	rcall	.+0      	; 0x3bc0 <uxQueueMessagesWaitingFromISR+0x6>
    3bc0:	0f 92       	push	r0
    3bc2:	cd b7       	in	r28, 0x3d	; 61
    3bc4:	de b7       	in	r29, 0x3e	; 62
    3bc6:	9b 83       	std	Y+3, r25	; 0x03
    3bc8:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    3bca:	ea 81       	ldd	r30, Y+2	; 0x02
    3bcc:	fb 81       	ldd	r31, Y+3	; 0x03
    3bce:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bd0:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3bd2:	89 81       	ldd	r24, Y+1	; 0x01
}
    3bd4:	0f 90       	pop	r0
    3bd6:	0f 90       	pop	r0
    3bd8:	0f 90       	pop	r0
    3bda:	cf 91       	pop	r28
    3bdc:	df 91       	pop	r29
    3bde:	08 95       	ret

00003be0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3be0:	df 93       	push	r29
    3be2:	cf 93       	push	r28
    3be4:	00 d0       	rcall	.+0      	; 0x3be6 <vQueueDelete+0x6>
    3be6:	cd b7       	in	r28, 0x3d	; 61
    3be8:	de b7       	in	r29, 0x3e	; 62
    3bea:	9a 83       	std	Y+2, r25	; 0x02
    3bec:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3bee:	e9 81       	ldd	r30, Y+1	; 0x01
    3bf0:	fa 81       	ldd	r31, Y+2	; 0x02
    3bf2:	80 81       	ld	r24, Z
    3bf4:	91 81       	ldd	r25, Z+1	; 0x01
    3bf6:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <vPortFree>
	vPortFree( pxQueue );
    3bfa:	89 81       	ldd	r24, Y+1	; 0x01
    3bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    3bfe:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <vPortFree>
}
    3c02:	0f 90       	pop	r0
    3c04:	0f 90       	pop	r0
    3c06:	cf 91       	pop	r28
    3c08:	df 91       	pop	r29
    3c0a:	08 95       	ret

00003c0c <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3c0c:	df 93       	push	r29
    3c0e:	cf 93       	push	r28
    3c10:	00 d0       	rcall	.+0      	; 0x3c12 <prvCopyDataToQueue+0x6>
    3c12:	00 d0       	rcall	.+0      	; 0x3c14 <prvCopyDataToQueue+0x8>
    3c14:	0f 92       	push	r0
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
    3c1a:	9a 83       	std	Y+2, r25	; 0x02
    3c1c:	89 83       	std	Y+1, r24	; 0x01
    3c1e:	7c 83       	std	Y+4, r23	; 0x04
    3c20:	6b 83       	std	Y+3, r22	; 0x03
    3c22:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3c24:	e9 81       	ldd	r30, Y+1	; 0x01
    3c26:	fa 81       	ldd	r31, Y+2	; 0x02
    3c28:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c2a:	88 23       	and	r24, r24
    3c2c:	09 f4       	brne	.+2      	; 0x3c30 <prvCopyDataToQueue+0x24>
    3c2e:	74 c0       	rjmp	.+232    	; 0x3d18 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3c30:	8d 81       	ldd	r24, Y+5	; 0x05
    3c32:	88 23       	and	r24, r24
    3c34:	99 f5       	brne	.+102    	; 0x3c9c <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3c36:	e9 81       	ldd	r30, Y+1	; 0x01
    3c38:	fa 81       	ldd	r31, Y+2	; 0x02
    3c3a:	64 81       	ldd	r22, Z+4	; 0x04
    3c3c:	75 81       	ldd	r23, Z+5	; 0x05
    3c3e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c40:	fa 81       	ldd	r31, Y+2	; 0x02
    3c42:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c44:	48 2f       	mov	r20, r24
    3c46:	50 e0       	ldi	r21, 0x00	; 0
    3c48:	2b 81       	ldd	r18, Y+3	; 0x03
    3c4a:	3c 81       	ldd	r19, Y+4	; 0x04
    3c4c:	cb 01       	movw	r24, r22
    3c4e:	b9 01       	movw	r22, r18
    3c50:	0e 94 7b 28 	call	0x50f6	; 0x50f6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3c54:	e9 81       	ldd	r30, Y+1	; 0x01
    3c56:	fa 81       	ldd	r31, Y+2	; 0x02
    3c58:	24 81       	ldd	r18, Z+4	; 0x04
    3c5a:	35 81       	ldd	r19, Z+5	; 0x05
    3c5c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c5e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c60:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c62:	88 2f       	mov	r24, r24
    3c64:	90 e0       	ldi	r25, 0x00	; 0
    3c66:	82 0f       	add	r24, r18
    3c68:	93 1f       	adc	r25, r19
    3c6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c6e:	95 83       	std	Z+5, r25	; 0x05
    3c70:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3c72:	e9 81       	ldd	r30, Y+1	; 0x01
    3c74:	fa 81       	ldd	r31, Y+2	; 0x02
    3c76:	24 81       	ldd	r18, Z+4	; 0x04
    3c78:	35 81       	ldd	r19, Z+5	; 0x05
    3c7a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c7c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c7e:	82 81       	ldd	r24, Z+2	; 0x02
    3c80:	93 81       	ldd	r25, Z+3	; 0x03
    3c82:	28 17       	cp	r18, r24
    3c84:	39 07       	cpc	r19, r25
    3c86:	08 f4       	brcc	.+2      	; 0x3c8a <prvCopyDataToQueue+0x7e>
    3c88:	47 c0       	rjmp	.+142    	; 0x3d18 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c8e:	80 81       	ld	r24, Z
    3c90:	91 81       	ldd	r25, Z+1	; 0x01
    3c92:	e9 81       	ldd	r30, Y+1	; 0x01
    3c94:	fa 81       	ldd	r31, Y+2	; 0x02
    3c96:	95 83       	std	Z+5, r25	; 0x05
    3c98:	84 83       	std	Z+4, r24	; 0x04
    3c9a:	3e c0       	rjmp	.+124    	; 0x3d18 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3c9c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c9e:	fa 81       	ldd	r31, Y+2	; 0x02
    3ca0:	66 81       	ldd	r22, Z+6	; 0x06
    3ca2:	77 81       	ldd	r23, Z+7	; 0x07
    3ca4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ca6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ca8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3caa:	48 2f       	mov	r20, r24
    3cac:	50 e0       	ldi	r21, 0x00	; 0
    3cae:	2b 81       	ldd	r18, Y+3	; 0x03
    3cb0:	3c 81       	ldd	r19, Y+4	; 0x04
    3cb2:	cb 01       	movw	r24, r22
    3cb4:	b9 01       	movw	r22, r18
    3cb6:	0e 94 7b 28 	call	0x50f6	; 0x50f6 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    3cba:	e9 81       	ldd	r30, Y+1	; 0x01
    3cbc:	fa 81       	ldd	r31, Y+2	; 0x02
    3cbe:	26 81       	ldd	r18, Z+6	; 0x06
    3cc0:	37 81       	ldd	r19, Z+7	; 0x07
    3cc2:	e9 81       	ldd	r30, Y+1	; 0x01
    3cc4:	fa 81       	ldd	r31, Y+2	; 0x02
    3cc6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cc8:	88 2f       	mov	r24, r24
    3cca:	90 e0       	ldi	r25, 0x00	; 0
    3ccc:	90 95       	com	r25
    3cce:	81 95       	neg	r24
    3cd0:	9f 4f       	sbci	r25, 0xFF	; 255
    3cd2:	82 0f       	add	r24, r18
    3cd4:	93 1f       	adc	r25, r19
    3cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    3cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    3cda:	97 83       	std	Z+7, r25	; 0x07
    3cdc:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    3cde:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ce2:	26 81       	ldd	r18, Z+6	; 0x06
    3ce4:	37 81       	ldd	r19, Z+7	; 0x07
    3ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    3cea:	80 81       	ld	r24, Z
    3cec:	91 81       	ldd	r25, Z+1	; 0x01
    3cee:	28 17       	cp	r18, r24
    3cf0:	39 07       	cpc	r19, r25
    3cf2:	90 f4       	brcc	.+36     	; 0x3d18 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3cf4:	e9 81       	ldd	r30, Y+1	; 0x01
    3cf6:	fa 81       	ldd	r31, Y+2	; 0x02
    3cf8:	22 81       	ldd	r18, Z+2	; 0x02
    3cfa:	33 81       	ldd	r19, Z+3	; 0x03
    3cfc:	e9 81       	ldd	r30, Y+1	; 0x01
    3cfe:	fa 81       	ldd	r31, Y+2	; 0x02
    3d00:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d02:	88 2f       	mov	r24, r24
    3d04:	90 e0       	ldi	r25, 0x00	; 0
    3d06:	90 95       	com	r25
    3d08:	81 95       	neg	r24
    3d0a:	9f 4f       	sbci	r25, 0xFF	; 255
    3d0c:	82 0f       	add	r24, r18
    3d0e:	93 1f       	adc	r25, r19
    3d10:	e9 81       	ldd	r30, Y+1	; 0x01
    3d12:	fa 81       	ldd	r31, Y+2	; 0x02
    3d14:	97 83       	std	Z+7, r25	; 0x07
    3d16:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3d18:	e9 81       	ldd	r30, Y+1	; 0x01
    3d1a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d1e:	8f 5f       	subi	r24, 0xFF	; 255
    3d20:	e9 81       	ldd	r30, Y+1	; 0x01
    3d22:	fa 81       	ldd	r31, Y+2	; 0x02
    3d24:	82 8f       	std	Z+26, r24	; 0x1a
}
    3d26:	0f 90       	pop	r0
    3d28:	0f 90       	pop	r0
    3d2a:	0f 90       	pop	r0
    3d2c:	0f 90       	pop	r0
    3d2e:	0f 90       	pop	r0
    3d30:	cf 91       	pop	r28
    3d32:	df 91       	pop	r29
    3d34:	08 95       	ret

00003d36 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    3d36:	df 93       	push	r29
    3d38:	cf 93       	push	r28
    3d3a:	00 d0       	rcall	.+0      	; 0x3d3c <prvCopyDataFromQueue+0x6>
    3d3c:	00 d0       	rcall	.+0      	; 0x3d3e <prvCopyDataFromQueue+0x8>
    3d3e:	cd b7       	in	r28, 0x3d	; 61
    3d40:	de b7       	in	r29, 0x3e	; 62
    3d42:	9a 83       	std	Y+2, r25	; 0x02
    3d44:	89 83       	std	Y+1, r24	; 0x01
    3d46:	7c 83       	std	Y+4, r23	; 0x04
    3d48:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d4e:	80 81       	ld	r24, Z
    3d50:	91 81       	ldd	r25, Z+1	; 0x01
    3d52:	00 97       	sbiw	r24, 0x00	; 0
    3d54:	89 f1       	breq	.+98     	; 0x3db8 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    3d56:	e9 81       	ldd	r30, Y+1	; 0x01
    3d58:	fa 81       	ldd	r31, Y+2	; 0x02
    3d5a:	26 81       	ldd	r18, Z+6	; 0x06
    3d5c:	37 81       	ldd	r19, Z+7	; 0x07
    3d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    3d60:	fa 81       	ldd	r31, Y+2	; 0x02
    3d62:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d64:	88 2f       	mov	r24, r24
    3d66:	90 e0       	ldi	r25, 0x00	; 0
    3d68:	82 0f       	add	r24, r18
    3d6a:	93 1f       	adc	r25, r19
    3d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d70:	97 83       	std	Z+7, r25	; 0x07
    3d72:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    3d74:	e9 81       	ldd	r30, Y+1	; 0x01
    3d76:	fa 81       	ldd	r31, Y+2	; 0x02
    3d78:	26 81       	ldd	r18, Z+6	; 0x06
    3d7a:	37 81       	ldd	r19, Z+7	; 0x07
    3d7c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d7e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d80:	82 81       	ldd	r24, Z+2	; 0x02
    3d82:	93 81       	ldd	r25, Z+3	; 0x03
    3d84:	28 17       	cp	r18, r24
    3d86:	39 07       	cpc	r19, r25
    3d88:	40 f0       	brcs	.+16     	; 0x3d9a <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    3d8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d8e:	80 81       	ld	r24, Z
    3d90:	91 81       	ldd	r25, Z+1	; 0x01
    3d92:	e9 81       	ldd	r30, Y+1	; 0x01
    3d94:	fa 81       	ldd	r31, Y+2	; 0x02
    3d96:	97 83       	std	Z+7, r25	; 0x07
    3d98:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3d9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d9e:	46 81       	ldd	r20, Z+6	; 0x06
    3da0:	57 81       	ldd	r21, Z+7	; 0x07
    3da2:	e9 81       	ldd	r30, Y+1	; 0x01
    3da4:	fa 81       	ldd	r31, Y+2	; 0x02
    3da6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3da8:	28 2f       	mov	r18, r24
    3daa:	30 e0       	ldi	r19, 0x00	; 0
    3dac:	8b 81       	ldd	r24, Y+3	; 0x03
    3dae:	9c 81       	ldd	r25, Y+4	; 0x04
    3db0:	ba 01       	movw	r22, r20
    3db2:	a9 01       	movw	r20, r18
    3db4:	0e 94 7b 28 	call	0x50f6	; 0x50f6 <memcpy>
	}
}
    3db8:	0f 90       	pop	r0
    3dba:	0f 90       	pop	r0
    3dbc:	0f 90       	pop	r0
    3dbe:	0f 90       	pop	r0
    3dc0:	cf 91       	pop	r28
    3dc2:	df 91       	pop	r29
    3dc4:	08 95       	ret

00003dc6 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    3dc6:	df 93       	push	r29
    3dc8:	cf 93       	push	r28
    3dca:	00 d0       	rcall	.+0      	; 0x3dcc <prvUnlockQueue+0x6>
    3dcc:	cd b7       	in	r28, 0x3d	; 61
    3dce:	de b7       	in	r29, 0x3e	; 62
    3dd0:	9a 83       	std	Y+2, r25	; 0x02
    3dd2:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3dd4:	0f b6       	in	r0, 0x3f	; 63
    3dd6:	f8 94       	cli
    3dd8:	0f 92       	push	r0
    3dda:	15 c0       	rjmp	.+42     	; 0x3e06 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    3dde:	fa 81       	ldd	r31, Y+2	; 0x02
    3de0:	81 89       	ldd	r24, Z+17	; 0x11
    3de2:	88 23       	and	r24, r24
    3de4:	a9 f0       	breq	.+42     	; 0x3e10 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3de6:	89 81       	ldd	r24, Y+1	; 0x01
    3de8:	9a 81       	ldd	r25, Y+2	; 0x02
    3dea:	41 96       	adiw	r24, 0x11	; 17
    3dec:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskRemoveFromEventList>
    3df0:	88 23       	and	r24, r24
    3df2:	11 f0       	breq	.+4      	; 0x3df8 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    3df4:	0e 94 75 26 	call	0x4cea	; 0x4cea <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    3df8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dfa:	fa 81       	ldd	r31, Y+2	; 0x02
    3dfc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3dfe:	81 50       	subi	r24, 0x01	; 1
    3e00:	e9 81       	ldd	r30, Y+1	; 0x01
    3e02:	fa 81       	ldd	r31, Y+2	; 0x02
    3e04:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3e06:	e9 81       	ldd	r30, Y+1	; 0x01
    3e08:	fa 81       	ldd	r31, Y+2	; 0x02
    3e0a:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e0c:	18 16       	cp	r1, r24
    3e0e:	34 f3       	brlt	.-52     	; 0x3ddc <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3e10:	e9 81       	ldd	r30, Y+1	; 0x01
    3e12:	fa 81       	ldd	r31, Y+2	; 0x02
    3e14:	8f ef       	ldi	r24, 0xFF	; 255
    3e16:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3e18:	0f 90       	pop	r0
    3e1a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3e1c:	0f b6       	in	r0, 0x3f	; 63
    3e1e:	f8 94       	cli
    3e20:	0f 92       	push	r0
    3e22:	15 c0       	rjmp	.+42     	; 0x3e4e <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e24:	e9 81       	ldd	r30, Y+1	; 0x01
    3e26:	fa 81       	ldd	r31, Y+2	; 0x02
    3e28:	80 85       	ldd	r24, Z+8	; 0x08
    3e2a:	88 23       	and	r24, r24
    3e2c:	a9 f0       	breq	.+42     	; 0x3e58 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e2e:	89 81       	ldd	r24, Y+1	; 0x01
    3e30:	9a 81       	ldd	r25, Y+2	; 0x02
    3e32:	08 96       	adiw	r24, 0x08	; 8
    3e34:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <xTaskRemoveFromEventList>
    3e38:	88 23       	and	r24, r24
    3e3a:	11 f0       	breq	.+4      	; 0x3e40 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3e3c:	0e 94 75 26 	call	0x4cea	; 0x4cea <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    3e40:	e9 81       	ldd	r30, Y+1	; 0x01
    3e42:	fa 81       	ldd	r31, Y+2	; 0x02
    3e44:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e46:	81 50       	subi	r24, 0x01	; 1
    3e48:	e9 81       	ldd	r30, Y+1	; 0x01
    3e4a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e4c:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3e4e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e50:	fa 81       	ldd	r31, Y+2	; 0x02
    3e52:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e54:	18 16       	cp	r1, r24
    3e56:	34 f3       	brlt	.-52     	; 0x3e24 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3e58:	e9 81       	ldd	r30, Y+1	; 0x01
    3e5a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e5c:	8f ef       	ldi	r24, 0xFF	; 255
    3e5e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3e60:	0f 90       	pop	r0
    3e62:	0f be       	out	0x3f, r0	; 63
}
    3e64:	0f 90       	pop	r0
    3e66:	0f 90       	pop	r0
    3e68:	cf 91       	pop	r28
    3e6a:	df 91       	pop	r29
    3e6c:	08 95       	ret

00003e6e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    3e6e:	df 93       	push	r29
    3e70:	cf 93       	push	r28
    3e72:	00 d0       	rcall	.+0      	; 0x3e74 <prvIsQueueEmpty+0x6>
    3e74:	0f 92       	push	r0
    3e76:	cd b7       	in	r28, 0x3d	; 61
    3e78:	de b7       	in	r29, 0x3e	; 62
    3e7a:	9b 83       	std	Y+3, r25	; 0x03
    3e7c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3e7e:	0f b6       	in	r0, 0x3f	; 63
    3e80:	f8 94       	cli
    3e82:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3e84:	ea 81       	ldd	r30, Y+2	; 0x02
    3e86:	fb 81       	ldd	r31, Y+3	; 0x03
    3e88:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e8a:	19 82       	std	Y+1, r1	; 0x01
    3e8c:	88 23       	and	r24, r24
    3e8e:	11 f4       	brne	.+4      	; 0x3e94 <prvIsQueueEmpty+0x26>
    3e90:	81 e0       	ldi	r24, 0x01	; 1
    3e92:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3e94:	0f 90       	pop	r0
    3e96:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3e98:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e9a:	0f 90       	pop	r0
    3e9c:	0f 90       	pop	r0
    3e9e:	0f 90       	pop	r0
    3ea0:	cf 91       	pop	r28
    3ea2:	df 91       	pop	r29
    3ea4:	08 95       	ret

00003ea6 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    3ea6:	df 93       	push	r29
    3ea8:	cf 93       	push	r28
    3eaa:	00 d0       	rcall	.+0      	; 0x3eac <xQueueIsQueueEmptyFromISR+0x6>
    3eac:	0f 92       	push	r0
    3eae:	cd b7       	in	r28, 0x3d	; 61
    3eb0:	de b7       	in	r29, 0x3e	; 62
    3eb2:	9b 83       	std	Y+3, r25	; 0x03
    3eb4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3eb6:	ea 81       	ldd	r30, Y+2	; 0x02
    3eb8:	fb 81       	ldd	r31, Y+3	; 0x03
    3eba:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ebc:	19 82       	std	Y+1, r1	; 0x01
    3ebe:	88 23       	and	r24, r24
    3ec0:	11 f4       	brne	.+4      	; 0x3ec6 <xQueueIsQueueEmptyFromISR+0x20>
    3ec2:	81 e0       	ldi	r24, 0x01	; 1
    3ec4:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3ec6:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ec8:	0f 90       	pop	r0
    3eca:	0f 90       	pop	r0
    3ecc:	0f 90       	pop	r0
    3ece:	cf 91       	pop	r28
    3ed0:	df 91       	pop	r29
    3ed2:	08 95       	ret

00003ed4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    3ed4:	df 93       	push	r29
    3ed6:	cf 93       	push	r28
    3ed8:	00 d0       	rcall	.+0      	; 0x3eda <prvIsQueueFull+0x6>
    3eda:	0f 92       	push	r0
    3edc:	cd b7       	in	r28, 0x3d	; 61
    3ede:	de b7       	in	r29, 0x3e	; 62
    3ee0:	9b 83       	std	Y+3, r25	; 0x03
    3ee2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3ee4:	0f b6       	in	r0, 0x3f	; 63
    3ee6:	f8 94       	cli
    3ee8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3eea:	ea 81       	ldd	r30, Y+2	; 0x02
    3eec:	fb 81       	ldd	r31, Y+3	; 0x03
    3eee:	92 8d       	ldd	r25, Z+26	; 0x1a
    3ef0:	ea 81       	ldd	r30, Y+2	; 0x02
    3ef2:	fb 81       	ldd	r31, Y+3	; 0x03
    3ef4:	83 8d       	ldd	r24, Z+27	; 0x1b
    3ef6:	19 82       	std	Y+1, r1	; 0x01
    3ef8:	98 17       	cp	r25, r24
    3efa:	11 f4       	brne	.+4      	; 0x3f00 <prvIsQueueFull+0x2c>
    3efc:	81 e0       	ldi	r24, 0x01	; 1
    3efe:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3f00:	0f 90       	pop	r0
    3f02:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3f04:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f06:	0f 90       	pop	r0
    3f08:	0f 90       	pop	r0
    3f0a:	0f 90       	pop	r0
    3f0c:	cf 91       	pop	r28
    3f0e:	df 91       	pop	r29
    3f10:	08 95       	ret

00003f12 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    3f12:	df 93       	push	r29
    3f14:	cf 93       	push	r28
    3f16:	00 d0       	rcall	.+0      	; 0x3f18 <xQueueIsQueueFullFromISR+0x6>
    3f18:	0f 92       	push	r0
    3f1a:	cd b7       	in	r28, 0x3d	; 61
    3f1c:	de b7       	in	r29, 0x3e	; 62
    3f1e:	9b 83       	std	Y+3, r25	; 0x03
    3f20:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3f22:	ea 81       	ldd	r30, Y+2	; 0x02
    3f24:	fb 81       	ldd	r31, Y+3	; 0x03
    3f26:	92 8d       	ldd	r25, Z+26	; 0x1a
    3f28:	ea 81       	ldd	r30, Y+2	; 0x02
    3f2a:	fb 81       	ldd	r31, Y+3	; 0x03
    3f2c:	83 8d       	ldd	r24, Z+27	; 0x1b
    3f2e:	19 82       	std	Y+1, r1	; 0x01
    3f30:	98 17       	cp	r25, r24
    3f32:	11 f4       	brne	.+4      	; 0x3f38 <xQueueIsQueueFullFromISR+0x26>
    3f34:	81 e0       	ldi	r24, 0x01	; 1
    3f36:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3f38:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f3a:	0f 90       	pop	r0
    3f3c:	0f 90       	pop	r0
    3f3e:	0f 90       	pop	r0
    3f40:	cf 91       	pop	r28
    3f42:	df 91       	pop	r29
    3f44:	08 95       	ret

00003f46 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    3f46:	af 92       	push	r10
    3f48:	bf 92       	push	r11
    3f4a:	cf 92       	push	r12
    3f4c:	df 92       	push	r13
    3f4e:	ef 92       	push	r14
    3f50:	ff 92       	push	r15
    3f52:	0f 93       	push	r16
    3f54:	1f 93       	push	r17
    3f56:	df 93       	push	r29
    3f58:	cf 93       	push	r28
    3f5a:	cd b7       	in	r28, 0x3d	; 61
    3f5c:	de b7       	in	r29, 0x3e	; 62
    3f5e:	64 97       	sbiw	r28, 0x14	; 20
    3f60:	0f b6       	in	r0, 0x3f	; 63
    3f62:	f8 94       	cli
    3f64:	de bf       	out	0x3e, r29	; 62
    3f66:	0f be       	out	0x3f, r0	; 63
    3f68:	cd bf       	out	0x3d, r28	; 61
    3f6a:	9f 83       	std	Y+7, r25	; 0x07
    3f6c:	8e 83       	std	Y+6, r24	; 0x06
    3f6e:	79 87       	std	Y+9, r23	; 0x09
    3f70:	68 87       	std	Y+8, r22	; 0x08
    3f72:	5b 87       	std	Y+11, r21	; 0x0b
    3f74:	4a 87       	std	Y+10, r20	; 0x0a
    3f76:	3d 87       	std	Y+13, r19	; 0x0d
    3f78:	2c 87       	std	Y+12, r18	; 0x0c
    3f7a:	0e 87       	std	Y+14, r16	; 0x0e
    3f7c:	f8 8a       	std	Y+16, r15	; 0x10
    3f7e:	ef 86       	std	Y+15, r14	; 0x0f
    3f80:	da 8a       	std	Y+18, r13	; 0x12
    3f82:	c9 8a       	std	Y+17, r12	; 0x11
    3f84:	bc 8a       	std	Y+20, r11	; 0x14
    3f86:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    3f88:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f8a:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f8c:	29 89       	ldd	r18, Y+17	; 0x11
    3f8e:	3a 89       	ldd	r19, Y+18	; 0x12
    3f90:	b9 01       	movw	r22, r18
    3f92:	0e 94 a8 27 	call	0x4f50	; 0x4f50 <prvAllocateTCBAndStack>
    3f96:	9c 83       	std	Y+4, r25	; 0x04
    3f98:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    3f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f9e:	00 97       	sbiw	r24, 0x00	; 0
    3fa0:	09 f4       	brne	.+2      	; 0x3fa4 <xTaskGenericCreate+0x5e>
    3fa2:	99 c0       	rjmp	.+306    	; 0x40d6 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    3fa4:	eb 81       	ldd	r30, Y+3	; 0x03
    3fa6:	fc 81       	ldd	r31, Y+4	; 0x04
    3fa8:	27 89       	ldd	r18, Z+23	; 0x17
    3faa:	30 8d       	ldd	r19, Z+24	; 0x18
    3fac:	8a 85       	ldd	r24, Y+10	; 0x0a
    3fae:	9b 85       	ldd	r25, Y+11	; 0x0b
    3fb0:	01 97       	sbiw	r24, 0x01	; 1
    3fb2:	82 0f       	add	r24, r18
    3fb4:	93 1f       	adc	r25, r19
    3fb6:	9a 83       	std	Y+2, r25	; 0x02
    3fb8:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    3fba:	8b 81       	ldd	r24, Y+3	; 0x03
    3fbc:	9c 81       	ldd	r25, Y+4	; 0x04
    3fbe:	28 85       	ldd	r18, Y+8	; 0x08
    3fc0:	39 85       	ldd	r19, Y+9	; 0x09
    3fc2:	eb 89       	ldd	r30, Y+19	; 0x13
    3fc4:	fc 89       	ldd	r31, Y+20	; 0x14
    3fc6:	aa 85       	ldd	r26, Y+10	; 0x0a
    3fc8:	bb 85       	ldd	r27, Y+11	; 0x0b
    3fca:	b9 01       	movw	r22, r18
    3fcc:	4e 85       	ldd	r20, Y+14	; 0x0e
    3fce:	9f 01       	movw	r18, r30
    3fd0:	8d 01       	movw	r16, r26
    3fd2:	0e 94 89 26 	call	0x4d12	; 0x4d12 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3fd6:	89 81       	ldd	r24, Y+1	; 0x01
    3fd8:	9a 81       	ldd	r25, Y+2	; 0x02
    3fda:	2e 81       	ldd	r18, Y+6	; 0x06
    3fdc:	3f 81       	ldd	r19, Y+7	; 0x07
    3fde:	4c 85       	ldd	r20, Y+12	; 0x0c
    3fe0:	5d 85       	ldd	r21, Y+13	; 0x0d
    3fe2:	b9 01       	movw	r22, r18
    3fe4:	0e 94 31 18 	call	0x3062	; 0x3062 <pxPortInitialiseStack>
    3fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    3fea:	fc 81       	ldd	r31, Y+4	; 0x04
    3fec:	91 83       	std	Z+1, r25	; 0x01
    3fee:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    3ff0:	8f 85       	ldd	r24, Y+15	; 0x0f
    3ff2:	98 89       	ldd	r25, Y+16	; 0x10
    3ff4:	00 97       	sbiw	r24, 0x00	; 0
    3ff6:	31 f0       	breq	.+12     	; 0x4004 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    3ff8:	ef 85       	ldd	r30, Y+15	; 0x0f
    3ffa:	f8 89       	ldd	r31, Y+16	; 0x10
    3ffc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ffe:	9c 81       	ldd	r25, Y+4	; 0x04
    4000:	91 83       	std	Z+1, r25	; 0x01
    4002:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    4004:	0f b6       	in	r0, 0x3f	; 63
    4006:	f8 94       	cli
    4008:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    400a:	80 91 bf 04 	lds	r24, 0x04BF
    400e:	8f 5f       	subi	r24, 0xFF	; 255
    4010:	80 93 bf 04 	sts	0x04BF, r24
			if( pxCurrentTCB == NULL )
    4014:	80 91 bc 04 	lds	r24, 0x04BC
    4018:	90 91 bd 04 	lds	r25, 0x04BD
    401c:	00 97       	sbiw	r24, 0x00	; 0
    401e:	69 f4       	brne	.+26     	; 0x403a <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4020:	8b 81       	ldd	r24, Y+3	; 0x03
    4022:	9c 81       	ldd	r25, Y+4	; 0x04
    4024:	90 93 bd 04 	sts	0x04BD, r25
    4028:	80 93 bc 04 	sts	0x04BC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    402c:	80 91 bf 04 	lds	r24, 0x04BF
    4030:	81 30       	cpi	r24, 0x01	; 1
    4032:	a9 f4       	brne	.+42     	; 0x405e <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4034:	0e 94 e0 26 	call	0x4dc0	; 0x4dc0 <prvInitialiseTaskLists>
    4038:	12 c0       	rjmp	.+36     	; 0x405e <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    403a:	80 91 c4 04 	lds	r24, 0x04C4
    403e:	88 23       	and	r24, r24
    4040:	71 f4       	brne	.+28     	; 0x405e <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4042:	e0 91 bc 04 	lds	r30, 0x04BC
    4046:	f0 91 bd 04 	lds	r31, 0x04BD
    404a:	96 89       	ldd	r25, Z+22	; 0x16
    404c:	8e 85       	ldd	r24, Y+14	; 0x0e
    404e:	89 17       	cp	r24, r25
    4050:	30 f0       	brcs	.+12     	; 0x405e <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4052:	8b 81       	ldd	r24, Y+3	; 0x03
    4054:	9c 81       	ldd	r25, Y+4	; 0x04
    4056:	90 93 bd 04 	sts	0x04BD, r25
    405a:	80 93 bc 04 	sts	0x04BC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    405e:	eb 81       	ldd	r30, Y+3	; 0x03
    4060:	fc 81       	ldd	r31, Y+4	; 0x04
    4062:	96 89       	ldd	r25, Z+22	; 0x16
    4064:	80 91 c2 04 	lds	r24, 0x04C2
    4068:	89 17       	cp	r24, r25
    406a:	28 f4       	brcc	.+10     	; 0x4076 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    406c:	eb 81       	ldd	r30, Y+3	; 0x03
    406e:	fc 81       	ldd	r31, Y+4	; 0x04
    4070:	86 89       	ldd	r24, Z+22	; 0x16
    4072:	80 93 c2 04 	sts	0x04C2, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    4076:	80 91 c9 04 	lds	r24, 0x04C9
    407a:	8f 5f       	subi	r24, 0xFF	; 255
    407c:	80 93 c9 04 	sts	0x04C9, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    4080:	eb 81       	ldd	r30, Y+3	; 0x03
    4082:	fc 81       	ldd	r31, Y+4	; 0x04
    4084:	96 89       	ldd	r25, Z+22	; 0x16
    4086:	80 91 c3 04 	lds	r24, 0x04C3
    408a:	89 17       	cp	r24, r25
    408c:	28 f4       	brcc	.+10     	; 0x4098 <xTaskGenericCreate+0x152>
    408e:	eb 81       	ldd	r30, Y+3	; 0x03
    4090:	fc 81       	ldd	r31, Y+4	; 0x04
    4092:	86 89       	ldd	r24, Z+22	; 0x16
    4094:	80 93 c3 04 	sts	0x04C3, r24
    4098:	eb 81       	ldd	r30, Y+3	; 0x03
    409a:	fc 81       	ldd	r31, Y+4	; 0x04
    409c:	86 89       	ldd	r24, Z+22	; 0x16
    409e:	28 2f       	mov	r18, r24
    40a0:	30 e0       	ldi	r19, 0x00	; 0
    40a2:	c9 01       	movw	r24, r18
    40a4:	88 0f       	add	r24, r24
    40a6:	99 1f       	adc	r25, r25
    40a8:	88 0f       	add	r24, r24
    40aa:	99 1f       	adc	r25, r25
    40ac:	88 0f       	add	r24, r24
    40ae:	99 1f       	adc	r25, r25
    40b0:	82 0f       	add	r24, r18
    40b2:	93 1f       	adc	r25, r19
    40b4:	ac 01       	movw	r20, r24
    40b6:	46 53       	subi	r20, 0x36	; 54
    40b8:	5b 4f       	sbci	r21, 0xFB	; 251
    40ba:	8b 81       	ldd	r24, Y+3	; 0x03
    40bc:	9c 81       	ldd	r25, Y+4	; 0x04
    40be:	9c 01       	movw	r18, r24
    40c0:	2e 5f       	subi	r18, 0xFE	; 254
    40c2:	3f 4f       	sbci	r19, 0xFF	; 255
    40c4:	ca 01       	movw	r24, r20
    40c6:	b9 01       	movw	r22, r18
    40c8:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>

			xReturn = pdPASS;
    40cc:	81 e0       	ldi	r24, 0x01	; 1
    40ce:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    40d0:	0f 90       	pop	r0
    40d2:	0f be       	out	0x3f, r0	; 63
    40d4:	02 c0       	rjmp	.+4      	; 0x40da <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    40d6:	8f ef       	ldi	r24, 0xFF	; 255
    40d8:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    40da:	8d 81       	ldd	r24, Y+5	; 0x05
    40dc:	81 30       	cpi	r24, 0x01	; 1
    40de:	71 f4       	brne	.+28     	; 0x40fc <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    40e0:	80 91 c4 04 	lds	r24, 0x04C4
    40e4:	88 23       	and	r24, r24
    40e6:	51 f0       	breq	.+20     	; 0x40fc <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    40e8:	e0 91 bc 04 	lds	r30, 0x04BC
    40ec:	f0 91 bd 04 	lds	r31, 0x04BD
    40f0:	96 89       	ldd	r25, Z+22	; 0x16
    40f2:	8e 85       	ldd	r24, Y+14	; 0x0e
    40f4:	98 17       	cp	r25, r24
    40f6:	10 f4       	brcc	.+4      	; 0x40fc <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    40f8:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
			}
		}
	}

	return xReturn;
    40fc:	8d 81       	ldd	r24, Y+5	; 0x05
}
    40fe:	64 96       	adiw	r28, 0x14	; 20
    4100:	0f b6       	in	r0, 0x3f	; 63
    4102:	f8 94       	cli
    4104:	de bf       	out	0x3e, r29	; 62
    4106:	0f be       	out	0x3f, r0	; 63
    4108:	cd bf       	out	0x3d, r28	; 61
    410a:	cf 91       	pop	r28
    410c:	df 91       	pop	r29
    410e:	1f 91       	pop	r17
    4110:	0f 91       	pop	r16
    4112:	ff 90       	pop	r15
    4114:	ef 90       	pop	r14
    4116:	df 90       	pop	r13
    4118:	cf 90       	pop	r12
    411a:	bf 90       	pop	r11
    411c:	af 90       	pop	r10
    411e:	08 95       	ret

00004120 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    4120:	df 93       	push	r29
    4122:	cf 93       	push	r28
    4124:	00 d0       	rcall	.+0      	; 0x4126 <vTaskDelete+0x6>
    4126:	00 d0       	rcall	.+0      	; 0x4128 <vTaskDelete+0x8>
    4128:	00 d0       	rcall	.+0      	; 0x412a <vTaskDelete+0xa>
    412a:	cd b7       	in	r28, 0x3d	; 61
    412c:	de b7       	in	r29, 0x3e	; 62
    412e:	9c 83       	std	Y+4, r25	; 0x04
    4130:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    4132:	0f b6       	in	r0, 0x3f	; 63
    4134:	f8 94       	cli
    4136:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    4138:	20 91 bc 04 	lds	r18, 0x04BC
    413c:	30 91 bd 04 	lds	r19, 0x04BD
    4140:	8b 81       	ldd	r24, Y+3	; 0x03
    4142:	9c 81       	ldd	r25, Y+4	; 0x04
    4144:	82 17       	cp	r24, r18
    4146:	93 07       	cpc	r25, r19
    4148:	11 f4       	brne	.+4      	; 0x414e <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    414a:	1c 82       	std	Y+4, r1	; 0x04
    414c:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    414e:	8b 81       	ldd	r24, Y+3	; 0x03
    4150:	9c 81       	ldd	r25, Y+4	; 0x04
    4152:	00 97       	sbiw	r24, 0x00	; 0
    4154:	39 f4       	brne	.+14     	; 0x4164 <vTaskDelete+0x44>
    4156:	80 91 bc 04 	lds	r24, 0x04BC
    415a:	90 91 bd 04 	lds	r25, 0x04BD
    415e:	9e 83       	std	Y+6, r25	; 0x06
    4160:	8d 83       	std	Y+5, r24	; 0x05
    4162:	04 c0       	rjmp	.+8      	; 0x416c <vTaskDelete+0x4c>
    4164:	8b 81       	ldd	r24, Y+3	; 0x03
    4166:	9c 81       	ldd	r25, Y+4	; 0x04
    4168:	9e 83       	std	Y+6, r25	; 0x06
    416a:	8d 83       	std	Y+5, r24	; 0x05
    416c:	8d 81       	ldd	r24, Y+5	; 0x05
    416e:	9e 81       	ldd	r25, Y+6	; 0x06
    4170:	9a 83       	std	Y+2, r25	; 0x02
    4172:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    4174:	89 81       	ldd	r24, Y+1	; 0x01
    4176:	9a 81       	ldd	r25, Y+2	; 0x02
    4178:	02 96       	adiw	r24, 0x02	; 2
    417a:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    417e:	e9 81       	ldd	r30, Y+1	; 0x01
    4180:	fa 81       	ldd	r31, Y+2	; 0x02
    4182:	84 89       	ldd	r24, Z+20	; 0x14
    4184:	95 89       	ldd	r25, Z+21	; 0x15
    4186:	00 97       	sbiw	r24, 0x00	; 0
    4188:	29 f0       	breq	.+10     	; 0x4194 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    418a:	89 81       	ldd	r24, Y+1	; 0x01
    418c:	9a 81       	ldd	r25, Y+2	; 0x02
    418e:	0c 96       	adiw	r24, 0x0c	; 12
    4190:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4194:	89 81       	ldd	r24, Y+1	; 0x01
    4196:	9a 81       	ldd	r25, Y+2	; 0x02
    4198:	9c 01       	movw	r18, r24
    419a:	2e 5f       	subi	r18, 0xFE	; 254
    419c:	3f 4f       	sbci	r19, 0xFF	; 255
    419e:	8d e0       	ldi	r24, 0x0D	; 13
    41a0:	95 e0       	ldi	r25, 0x05	; 5
    41a2:	b9 01       	movw	r22, r18
    41a4:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    41a8:	80 91 be 04 	lds	r24, 0x04BE
    41ac:	8f 5f       	subi	r24, 0xFF	; 255
    41ae:	80 93 be 04 	sts	0x04BE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    41b2:	80 91 c9 04 	lds	r24, 0x04C9
    41b6:	8f 5f       	subi	r24, 0xFF	; 255
    41b8:	80 93 c9 04 	sts	0x04C9, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    41bc:	0f 90       	pop	r0
    41be:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    41c0:	80 91 c4 04 	lds	r24, 0x04C4
    41c4:	88 23       	and	r24, r24
    41c6:	31 f0       	breq	.+12     	; 0x41d4 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    41c8:	8b 81       	ldd	r24, Y+3	; 0x03
    41ca:	9c 81       	ldd	r25, Y+4	; 0x04
    41cc:	00 97       	sbiw	r24, 0x00	; 0
    41ce:	11 f4       	brne	.+4      	; 0x41d4 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    41d0:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
			}
		}
	}
    41d4:	26 96       	adiw	r28, 0x06	; 6
    41d6:	0f b6       	in	r0, 0x3f	; 63
    41d8:	f8 94       	cli
    41da:	de bf       	out	0x3e, r29	; 62
    41dc:	0f be       	out	0x3f, r0	; 63
    41de:	cd bf       	out	0x3d, r28	; 61
    41e0:	cf 91       	pop	r28
    41e2:	df 91       	pop	r29
    41e4:	08 95       	ret

000041e6 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    41e6:	df 93       	push	r29
    41e8:	cf 93       	push	r28
    41ea:	cd b7       	in	r28, 0x3d	; 61
    41ec:	de b7       	in	r29, 0x3e	; 62
    41ee:	28 97       	sbiw	r28, 0x08	; 8
    41f0:	0f b6       	in	r0, 0x3f	; 63
    41f2:	f8 94       	cli
    41f4:	de bf       	out	0x3e, r29	; 62
    41f6:	0f be       	out	0x3f, r0	; 63
    41f8:	cd bf       	out	0x3d, r28	; 61
    41fa:	9e 83       	std	Y+6, r25	; 0x06
    41fc:	8d 83       	std	Y+5, r24	; 0x05
    41fe:	78 87       	std	Y+8, r23	; 0x08
    4200:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    4202:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    4204:	0e 94 3e 23 	call	0x467c	; 0x467c <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4208:	ed 81       	ldd	r30, Y+5	; 0x05
    420a:	fe 81       	ldd	r31, Y+6	; 0x06
    420c:	20 81       	ld	r18, Z
    420e:	31 81       	ldd	r19, Z+1	; 0x01
    4210:	8f 81       	ldd	r24, Y+7	; 0x07
    4212:	98 85       	ldd	r25, Y+8	; 0x08
    4214:	82 0f       	add	r24, r18
    4216:	93 1f       	adc	r25, r19
    4218:	9c 83       	std	Y+4, r25	; 0x04
    421a:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    421c:	ed 81       	ldd	r30, Y+5	; 0x05
    421e:	fe 81       	ldd	r31, Y+6	; 0x06
    4220:	20 81       	ld	r18, Z
    4222:	31 81       	ldd	r19, Z+1	; 0x01
    4224:	80 91 c0 04 	lds	r24, 0x04C0
    4228:	90 91 c1 04 	lds	r25, 0x04C1
    422c:	82 17       	cp	r24, r18
    422e:	93 07       	cpc	r25, r19
    4230:	a8 f4       	brcc	.+42     	; 0x425c <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    4232:	ed 81       	ldd	r30, Y+5	; 0x05
    4234:	fe 81       	ldd	r31, Y+6	; 0x06
    4236:	20 81       	ld	r18, Z
    4238:	31 81       	ldd	r19, Z+1	; 0x01
    423a:	8b 81       	ldd	r24, Y+3	; 0x03
    423c:	9c 81       	ldd	r25, Y+4	; 0x04
    423e:	82 17       	cp	r24, r18
    4240:	93 07       	cpc	r25, r19
    4242:	00 f5       	brcc	.+64     	; 0x4284 <vTaskDelayUntil+0x9e>
    4244:	20 91 c0 04 	lds	r18, 0x04C0
    4248:	30 91 c1 04 	lds	r19, 0x04C1
    424c:	8b 81       	ldd	r24, Y+3	; 0x03
    424e:	9c 81       	ldd	r25, Y+4	; 0x04
    4250:	28 17       	cp	r18, r24
    4252:	39 07       	cpc	r19, r25
    4254:	b8 f4       	brcc	.+46     	; 0x4284 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4256:	81 e0       	ldi	r24, 0x01	; 1
    4258:	89 83       	std	Y+1, r24	; 0x01
    425a:	14 c0       	rjmp	.+40     	; 0x4284 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    425c:	ed 81       	ldd	r30, Y+5	; 0x05
    425e:	fe 81       	ldd	r31, Y+6	; 0x06
    4260:	20 81       	ld	r18, Z
    4262:	31 81       	ldd	r19, Z+1	; 0x01
    4264:	8b 81       	ldd	r24, Y+3	; 0x03
    4266:	9c 81       	ldd	r25, Y+4	; 0x04
    4268:	82 17       	cp	r24, r18
    426a:	93 07       	cpc	r25, r19
    426c:	48 f0       	brcs	.+18     	; 0x4280 <vTaskDelayUntil+0x9a>
    426e:	20 91 c0 04 	lds	r18, 0x04C0
    4272:	30 91 c1 04 	lds	r19, 0x04C1
    4276:	8b 81       	ldd	r24, Y+3	; 0x03
    4278:	9c 81       	ldd	r25, Y+4	; 0x04
    427a:	28 17       	cp	r18, r24
    427c:	39 07       	cpc	r19, r25
    427e:	10 f4       	brcc	.+4      	; 0x4284 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4280:	81 e0       	ldi	r24, 0x01	; 1
    4282:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4284:	ed 81       	ldd	r30, Y+5	; 0x05
    4286:	fe 81       	ldd	r31, Y+6	; 0x06
    4288:	8b 81       	ldd	r24, Y+3	; 0x03
    428a:	9c 81       	ldd	r25, Y+4	; 0x04
    428c:	91 83       	std	Z+1, r25	; 0x01
    428e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4290:	89 81       	ldd	r24, Y+1	; 0x01
    4292:	88 23       	and	r24, r24
    4294:	59 f0       	breq	.+22     	; 0x42ac <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4296:	80 91 bc 04 	lds	r24, 0x04BC
    429a:	90 91 bd 04 	lds	r25, 0x04BD
    429e:	02 96       	adiw	r24, 0x02	; 2
    42a0:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    42a4:	8b 81       	ldd	r24, Y+3	; 0x03
    42a6:	9c 81       	ldd	r25, Y+4	; 0x04
    42a8:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    42ac:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>
    42b0:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    42b2:	8a 81       	ldd	r24, Y+2	; 0x02
    42b4:	88 23       	and	r24, r24
    42b6:	11 f4       	brne	.+4      	; 0x42bc <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    42b8:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
		}
	}
    42bc:	28 96       	adiw	r28, 0x08	; 8
    42be:	0f b6       	in	r0, 0x3f	; 63
    42c0:	f8 94       	cli
    42c2:	de bf       	out	0x3e, r29	; 62
    42c4:	0f be       	out	0x3f, r0	; 63
    42c6:	cd bf       	out	0x3d, r28	; 61
    42c8:	cf 91       	pop	r28
    42ca:	df 91       	pop	r29
    42cc:	08 95       	ret

000042ce <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    42ce:	df 93       	push	r29
    42d0:	cf 93       	push	r28
    42d2:	00 d0       	rcall	.+0      	; 0x42d4 <vTaskDelay+0x6>
    42d4:	00 d0       	rcall	.+0      	; 0x42d6 <vTaskDelay+0x8>
    42d6:	0f 92       	push	r0
    42d8:	cd b7       	in	r28, 0x3d	; 61
    42da:	de b7       	in	r29, 0x3e	; 62
    42dc:	9d 83       	std	Y+5, r25	; 0x05
    42de:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    42e0:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    42e2:	8c 81       	ldd	r24, Y+4	; 0x04
    42e4:	9d 81       	ldd	r25, Y+5	; 0x05
    42e6:	00 97       	sbiw	r24, 0x00	; 0
    42e8:	d1 f0       	breq	.+52     	; 0x431e <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    42ea:	0e 94 3e 23 	call	0x467c	; 0x467c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    42ee:	20 91 c0 04 	lds	r18, 0x04C0
    42f2:	30 91 c1 04 	lds	r19, 0x04C1
    42f6:	8c 81       	ldd	r24, Y+4	; 0x04
    42f8:	9d 81       	ldd	r25, Y+5	; 0x05
    42fa:	82 0f       	add	r24, r18
    42fc:	93 1f       	adc	r25, r19
    42fe:	9b 83       	std	Y+3, r25	; 0x03
    4300:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4302:	80 91 bc 04 	lds	r24, 0x04BC
    4306:	90 91 bd 04 	lds	r25, 0x04BD
    430a:	02 96       	adiw	r24, 0x02	; 2
    430c:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4310:	8a 81       	ldd	r24, Y+2	; 0x02
    4312:	9b 81       	ldd	r25, Y+3	; 0x03
    4314:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4318:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>
    431c:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    431e:	89 81       	ldd	r24, Y+1	; 0x01
    4320:	88 23       	and	r24, r24
    4322:	11 f4       	brne	.+4      	; 0x4328 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4324:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
		}
	}
    4328:	0f 90       	pop	r0
    432a:	0f 90       	pop	r0
    432c:	0f 90       	pop	r0
    432e:	0f 90       	pop	r0
    4330:	0f 90       	pop	r0
    4332:	cf 91       	pop	r28
    4334:	df 91       	pop	r29
    4336:	08 95       	ret

00004338 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    4338:	df 93       	push	r29
    433a:	cf 93       	push	r28
    433c:	00 d0       	rcall	.+0      	; 0x433e <vTaskSuspend+0x6>
    433e:	00 d0       	rcall	.+0      	; 0x4340 <vTaskSuspend+0x8>
    4340:	00 d0       	rcall	.+0      	; 0x4342 <vTaskSuspend+0xa>
    4342:	cd b7       	in	r28, 0x3d	; 61
    4344:	de b7       	in	r29, 0x3e	; 62
    4346:	9c 83       	std	Y+4, r25	; 0x04
    4348:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    434a:	0f b6       	in	r0, 0x3f	; 63
    434c:	f8 94       	cli
    434e:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    4350:	20 91 bc 04 	lds	r18, 0x04BC
    4354:	30 91 bd 04 	lds	r19, 0x04BD
    4358:	8b 81       	ldd	r24, Y+3	; 0x03
    435a:	9c 81       	ldd	r25, Y+4	; 0x04
    435c:	82 17       	cp	r24, r18
    435e:	93 07       	cpc	r25, r19
    4360:	11 f4       	brne	.+4      	; 0x4366 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
    4362:	1c 82       	std	Y+4, r1	; 0x04
    4364:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    4366:	8b 81       	ldd	r24, Y+3	; 0x03
    4368:	9c 81       	ldd	r25, Y+4	; 0x04
    436a:	00 97       	sbiw	r24, 0x00	; 0
    436c:	39 f4       	brne	.+14     	; 0x437c <vTaskSuspend+0x44>
    436e:	80 91 bc 04 	lds	r24, 0x04BC
    4372:	90 91 bd 04 	lds	r25, 0x04BD
    4376:	9e 83       	std	Y+6, r25	; 0x06
    4378:	8d 83       	std	Y+5, r24	; 0x05
    437a:	04 c0       	rjmp	.+8      	; 0x4384 <vTaskSuspend+0x4c>
    437c:	8b 81       	ldd	r24, Y+3	; 0x03
    437e:	9c 81       	ldd	r25, Y+4	; 0x04
    4380:	9e 83       	std	Y+6, r25	; 0x06
    4382:	8d 83       	std	Y+5, r24	; 0x05
    4384:	8d 81       	ldd	r24, Y+5	; 0x05
    4386:	9e 81       	ldd	r25, Y+6	; 0x06
    4388:	9a 83       	std	Y+2, r25	; 0x02
    438a:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    438c:	89 81       	ldd	r24, Y+1	; 0x01
    438e:	9a 81       	ldd	r25, Y+2	; 0x02
    4390:	02 96       	adiw	r24, 0x02	; 2
    4392:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    4396:	e9 81       	ldd	r30, Y+1	; 0x01
    4398:	fa 81       	ldd	r31, Y+2	; 0x02
    439a:	84 89       	ldd	r24, Z+20	; 0x14
    439c:	95 89       	ldd	r25, Z+21	; 0x15
    439e:	00 97       	sbiw	r24, 0x00	; 0
    43a0:	29 f0       	breq	.+10     	; 0x43ac <vTaskSuspend+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    43a2:	89 81       	ldd	r24, Y+1	; 0x01
    43a4:	9a 81       	ldd	r25, Y+2	; 0x02
    43a6:	0c 96       	adiw	r24, 0x0c	; 12
    43a8:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    43ac:	89 81       	ldd	r24, Y+1	; 0x01
    43ae:	9a 81       	ldd	r25, Y+2	; 0x02
    43b0:	9c 01       	movw	r18, r24
    43b2:	2e 5f       	subi	r18, 0xFE	; 254
    43b4:	3f 4f       	sbci	r19, 0xFF	; 255
    43b6:	86 e1       	ldi	r24, 0x16	; 22
    43b8:	95 e0       	ldi	r25, 0x05	; 5
    43ba:	b9 01       	movw	r22, r18
    43bc:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    43c0:	0f 90       	pop	r0
    43c2:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    43c4:	8b 81       	ldd	r24, Y+3	; 0x03
    43c6:	9c 81       	ldd	r25, Y+4	; 0x04
    43c8:	00 97       	sbiw	r24, 0x00	; 0
    43ca:	a1 f4       	brne	.+40     	; 0x43f4 <vTaskSuspend+0xbc>
		{
			if( xSchedulerRunning != pdFALSE )
    43cc:	80 91 c4 04 	lds	r24, 0x04C4
    43d0:	88 23       	and	r24, r24
    43d2:	19 f0       	breq	.+6      	; 0x43da <vTaskSuspend+0xa2>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    43d4:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
    43d8:	0d c0       	rjmp	.+26     	; 0x43f4 <vTaskSuspend+0xbc>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    43da:	90 91 16 05 	lds	r25, 0x0516
    43de:	80 91 bf 04 	lds	r24, 0x04BF
    43e2:	98 17       	cp	r25, r24
    43e4:	29 f4       	brne	.+10     	; 0x43f0 <vTaskSuspend+0xb8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    43e6:	10 92 bd 04 	sts	0x04BD, r1
    43ea:	10 92 bc 04 	sts	0x04BC, r1
    43ee:	02 c0       	rjmp	.+4      	; 0x43f4 <vTaskSuspend+0xbc>
				}
				else
				{
					vTaskSwitchContext();
    43f0:	0e 94 de 24 	call	0x49bc	; 0x49bc <vTaskSwitchContext>
				}
			}
		}
	}
    43f4:	26 96       	adiw	r28, 0x06	; 6
    43f6:	0f b6       	in	r0, 0x3f	; 63
    43f8:	f8 94       	cli
    43fa:	de bf       	out	0x3e, r29	; 62
    43fc:	0f be       	out	0x3f, r0	; 63
    43fe:	cd bf       	out	0x3d, r28	; 61
    4400:	cf 91       	pop	r28
    4402:	df 91       	pop	r29
    4404:	08 95       	ret

00004406 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    4406:	df 93       	push	r29
    4408:	cf 93       	push	r28
    440a:	00 d0       	rcall	.+0      	; 0x440c <xTaskIsTaskSuspended+0x6>
    440c:	00 d0       	rcall	.+0      	; 0x440e <xTaskIsTaskSuspended+0x8>
    440e:	0f 92       	push	r0
    4410:	cd b7       	in	r28, 0x3d	; 61
    4412:	de b7       	in	r29, 0x3e	; 62
    4414:	9d 83       	std	Y+5, r25	; 0x05
    4416:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
    4418:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    441a:	8c 81       	ldd	r24, Y+4	; 0x04
    441c:	9d 81       	ldd	r25, Y+5	; 0x05
    441e:	9a 83       	std	Y+2, r25	; 0x02
    4420:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    4422:	e9 81       	ldd	r30, Y+1	; 0x01
    4424:	fa 81       	ldd	r31, Y+2	; 0x02
    4426:	82 85       	ldd	r24, Z+10	; 0x0a
    4428:	93 85       	ldd	r25, Z+11	; 0x0b
    442a:	25 e0       	ldi	r18, 0x05	; 5
    442c:	86 31       	cpi	r24, 0x16	; 22
    442e:	92 07       	cpc	r25, r18
    4430:	81 f4       	brne	.+32     	; 0x4452 <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    4432:	e9 81       	ldd	r30, Y+1	; 0x01
    4434:	fa 81       	ldd	r31, Y+2	; 0x02
    4436:	84 89       	ldd	r24, Z+20	; 0x14
    4438:	95 89       	ldd	r25, Z+21	; 0x15
    443a:	25 e0       	ldi	r18, 0x05	; 5
    443c:	84 30       	cpi	r24, 0x04	; 4
    443e:	92 07       	cpc	r25, r18
    4440:	41 f0       	breq	.+16     	; 0x4452 <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    4442:	e9 81       	ldd	r30, Y+1	; 0x01
    4444:	fa 81       	ldd	r31, Y+2	; 0x02
    4446:	84 89       	ldd	r24, Z+20	; 0x14
    4448:	95 89       	ldd	r25, Z+21	; 0x15
    444a:	00 97       	sbiw	r24, 0x00	; 0
    444c:	11 f4       	brne	.+4      	; 0x4452 <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    444e:	81 e0       	ldi	r24, 0x01	; 1
    4450:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
    4452:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4454:	0f 90       	pop	r0
    4456:	0f 90       	pop	r0
    4458:	0f 90       	pop	r0
    445a:	0f 90       	pop	r0
    445c:	0f 90       	pop	r0
    445e:	cf 91       	pop	r28
    4460:	df 91       	pop	r29
    4462:	08 95       	ret

00004464 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    4464:	df 93       	push	r29
    4466:	cf 93       	push	r28
    4468:	00 d0       	rcall	.+0      	; 0x446a <vTaskResume+0x6>
    446a:	00 d0       	rcall	.+0      	; 0x446c <vTaskResume+0x8>
    446c:	cd b7       	in	r28, 0x3d	; 61
    446e:	de b7       	in	r29, 0x3e	; 62
    4470:	9c 83       	std	Y+4, r25	; 0x04
    4472:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    4474:	8b 81       	ldd	r24, Y+3	; 0x03
    4476:	9c 81       	ldd	r25, Y+4	; 0x04
    4478:	9a 83       	std	Y+2, r25	; 0x02
    447a:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    447c:	89 81       	ldd	r24, Y+1	; 0x01
    447e:	9a 81       	ldd	r25, Y+2	; 0x02
    4480:	00 97       	sbiw	r24, 0x00	; 0
    4482:	09 f4       	brne	.+2      	; 0x4486 <vTaskResume+0x22>
    4484:	4c c0       	rjmp	.+152    	; 0x451e <vTaskResume+0xba>
    4486:	20 91 bc 04 	lds	r18, 0x04BC
    448a:	30 91 bd 04 	lds	r19, 0x04BD
    448e:	89 81       	ldd	r24, Y+1	; 0x01
    4490:	9a 81       	ldd	r25, Y+2	; 0x02
    4492:	82 17       	cp	r24, r18
    4494:	93 07       	cpc	r25, r19
    4496:	09 f4       	brne	.+2      	; 0x449a <vTaskResume+0x36>
    4498:	42 c0       	rjmp	.+132    	; 0x451e <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    449a:	0f b6       	in	r0, 0x3f	; 63
    449c:	f8 94       	cli
    449e:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    44a0:	89 81       	ldd	r24, Y+1	; 0x01
    44a2:	9a 81       	ldd	r25, Y+2	; 0x02
    44a4:	0e 94 03 22 	call	0x4406	; 0x4406 <xTaskIsTaskSuspended>
    44a8:	81 30       	cpi	r24, 0x01	; 1
    44aa:	b9 f5       	brne	.+110    	; 0x451a <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    44ac:	89 81       	ldd	r24, Y+1	; 0x01
    44ae:	9a 81       	ldd	r25, Y+2	; 0x02
    44b0:	02 96       	adiw	r24, 0x02	; 2
    44b2:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    44b6:	e9 81       	ldd	r30, Y+1	; 0x01
    44b8:	fa 81       	ldd	r31, Y+2	; 0x02
    44ba:	96 89       	ldd	r25, Z+22	; 0x16
    44bc:	80 91 c3 04 	lds	r24, 0x04C3
    44c0:	89 17       	cp	r24, r25
    44c2:	28 f4       	brcc	.+10     	; 0x44ce <vTaskResume+0x6a>
    44c4:	e9 81       	ldd	r30, Y+1	; 0x01
    44c6:	fa 81       	ldd	r31, Y+2	; 0x02
    44c8:	86 89       	ldd	r24, Z+22	; 0x16
    44ca:	80 93 c3 04 	sts	0x04C3, r24
    44ce:	e9 81       	ldd	r30, Y+1	; 0x01
    44d0:	fa 81       	ldd	r31, Y+2	; 0x02
    44d2:	86 89       	ldd	r24, Z+22	; 0x16
    44d4:	28 2f       	mov	r18, r24
    44d6:	30 e0       	ldi	r19, 0x00	; 0
    44d8:	c9 01       	movw	r24, r18
    44da:	88 0f       	add	r24, r24
    44dc:	99 1f       	adc	r25, r25
    44de:	88 0f       	add	r24, r24
    44e0:	99 1f       	adc	r25, r25
    44e2:	88 0f       	add	r24, r24
    44e4:	99 1f       	adc	r25, r25
    44e6:	82 0f       	add	r24, r18
    44e8:	93 1f       	adc	r25, r19
    44ea:	ac 01       	movw	r20, r24
    44ec:	46 53       	subi	r20, 0x36	; 54
    44ee:	5b 4f       	sbci	r21, 0xFB	; 251
    44f0:	89 81       	ldd	r24, Y+1	; 0x01
    44f2:	9a 81       	ldd	r25, Y+2	; 0x02
    44f4:	9c 01       	movw	r18, r24
    44f6:	2e 5f       	subi	r18, 0xFE	; 254
    44f8:	3f 4f       	sbci	r19, 0xFF	; 255
    44fa:	ca 01       	movw	r24, r20
    44fc:	b9 01       	movw	r22, r18
    44fe:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4502:	e9 81       	ldd	r30, Y+1	; 0x01
    4504:	fa 81       	ldd	r31, Y+2	; 0x02
    4506:	96 89       	ldd	r25, Z+22	; 0x16
    4508:	e0 91 bc 04 	lds	r30, 0x04BC
    450c:	f0 91 bd 04 	lds	r31, 0x04BD
    4510:	86 89       	ldd	r24, Z+22	; 0x16
    4512:	98 17       	cp	r25, r24
    4514:	10 f0       	brcs	.+4      	; 0x451a <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    4516:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    451a:	0f 90       	pop	r0
    451c:	0f be       	out	0x3f, r0	; 63
		}
	}
    451e:	0f 90       	pop	r0
    4520:	0f 90       	pop	r0
    4522:	0f 90       	pop	r0
    4524:	0f 90       	pop	r0
    4526:	cf 91       	pop	r28
    4528:	df 91       	pop	r29
    452a:	08 95       	ret

0000452c <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    452c:	df 93       	push	r29
    452e:	cf 93       	push	r28
    4530:	00 d0       	rcall	.+0      	; 0x4532 <xTaskResumeFromISR+0x6>
    4532:	00 d0       	rcall	.+0      	; 0x4534 <xTaskResumeFromISR+0x8>
    4534:	0f 92       	push	r0
    4536:	cd b7       	in	r28, 0x3d	; 61
    4538:	de b7       	in	r29, 0x3e	; 62
    453a:	9d 83       	std	Y+5, r25	; 0x05
    453c:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xYieldRequired = pdFALSE;
    453e:	1b 82       	std	Y+3, r1	; 0x03
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    4540:	8c 81       	ldd	r24, Y+4	; 0x04
    4542:	9d 81       	ldd	r25, Y+5	; 0x05
    4544:	9a 83       	std	Y+2, r25	; 0x02
    4546:	89 83       	std	Y+1, r24	; 0x01

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    4548:	89 81       	ldd	r24, Y+1	; 0x01
    454a:	9a 81       	ldd	r25, Y+2	; 0x02
    454c:	0e 94 03 22 	call	0x4406	; 0x4406 <xTaskIsTaskSuspended>
    4550:	81 30       	cpi	r24, 0x01	; 1
    4552:	09 f0       	breq	.+2      	; 0x4556 <xTaskResumeFromISR+0x2a>
    4554:	47 c0       	rjmp	.+142    	; 0x45e4 <xTaskResumeFromISR+0xb8>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4556:	80 91 c5 04 	lds	r24, 0x04C5
    455a:	88 23       	and	r24, r24
    455c:	c9 f5       	brne	.+114    	; 0x45d0 <xTaskResumeFromISR+0xa4>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    455e:	e9 81       	ldd	r30, Y+1	; 0x01
    4560:	fa 81       	ldd	r31, Y+2	; 0x02
    4562:	96 89       	ldd	r25, Z+22	; 0x16
    4564:	e0 91 bc 04 	lds	r30, 0x04BC
    4568:	f0 91 bd 04 	lds	r31, 0x04BD
    456c:	86 89       	ldd	r24, Z+22	; 0x16
    456e:	1b 82       	std	Y+3, r1	; 0x03
    4570:	98 17       	cp	r25, r24
    4572:	10 f0       	brcs	.+4      	; 0x4578 <xTaskResumeFromISR+0x4c>
    4574:	81 e0       	ldi	r24, 0x01	; 1
    4576:	8b 83       	std	Y+3, r24	; 0x03
				vListRemove(  &( pxTCB->xGenericListItem ) );
    4578:	89 81       	ldd	r24, Y+1	; 0x01
    457a:	9a 81       	ldd	r25, Y+2	; 0x02
    457c:	02 96       	adiw	r24, 0x02	; 2
    457e:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    4582:	e9 81       	ldd	r30, Y+1	; 0x01
    4584:	fa 81       	ldd	r31, Y+2	; 0x02
    4586:	96 89       	ldd	r25, Z+22	; 0x16
    4588:	80 91 c3 04 	lds	r24, 0x04C3
    458c:	89 17       	cp	r24, r25
    458e:	28 f4       	brcc	.+10     	; 0x459a <xTaskResumeFromISR+0x6e>
    4590:	e9 81       	ldd	r30, Y+1	; 0x01
    4592:	fa 81       	ldd	r31, Y+2	; 0x02
    4594:	86 89       	ldd	r24, Z+22	; 0x16
    4596:	80 93 c3 04 	sts	0x04C3, r24
    459a:	e9 81       	ldd	r30, Y+1	; 0x01
    459c:	fa 81       	ldd	r31, Y+2	; 0x02
    459e:	86 89       	ldd	r24, Z+22	; 0x16
    45a0:	28 2f       	mov	r18, r24
    45a2:	30 e0       	ldi	r19, 0x00	; 0
    45a4:	c9 01       	movw	r24, r18
    45a6:	88 0f       	add	r24, r24
    45a8:	99 1f       	adc	r25, r25
    45aa:	88 0f       	add	r24, r24
    45ac:	99 1f       	adc	r25, r25
    45ae:	88 0f       	add	r24, r24
    45b0:	99 1f       	adc	r25, r25
    45b2:	82 0f       	add	r24, r18
    45b4:	93 1f       	adc	r25, r19
    45b6:	ac 01       	movw	r20, r24
    45b8:	46 53       	subi	r20, 0x36	; 54
    45ba:	5b 4f       	sbci	r21, 0xFB	; 251
    45bc:	89 81       	ldd	r24, Y+1	; 0x01
    45be:	9a 81       	ldd	r25, Y+2	; 0x02
    45c0:	9c 01       	movw	r18, r24
    45c2:	2e 5f       	subi	r18, 0xFE	; 254
    45c4:	3f 4f       	sbci	r19, 0xFF	; 255
    45c6:	ca 01       	movw	r24, r20
    45c8:	b9 01       	movw	r22, r18
    45ca:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>
    45ce:	0a c0       	rjmp	.+20     	; 0x45e4 <xTaskResumeFromISR+0xb8>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    45d0:	89 81       	ldd	r24, Y+1	; 0x01
    45d2:	9a 81       	ldd	r25, Y+2	; 0x02
    45d4:	9c 01       	movw	r18, r24
    45d6:	24 5f       	subi	r18, 0xF4	; 244
    45d8:	3f 4f       	sbci	r19, 0xFF	; 255
    45da:	84 e0       	ldi	r24, 0x04	; 4
    45dc:	95 e0       	ldi	r25, 0x05	; 5
    45de:	b9 01       	movw	r22, r18
    45e0:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>
			}
		}

		return xYieldRequired;
    45e4:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    45e6:	0f 90       	pop	r0
    45e8:	0f 90       	pop	r0
    45ea:	0f 90       	pop	r0
    45ec:	0f 90       	pop	r0
    45ee:	0f 90       	pop	r0
    45f0:	cf 91       	pop	r28
    45f2:	df 91       	pop	r29
    45f4:	08 95       	ret

000045f6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    45f6:	af 92       	push	r10
    45f8:	bf 92       	push	r11
    45fa:	cf 92       	push	r12
    45fc:	df 92       	push	r13
    45fe:	ef 92       	push	r14
    4600:	ff 92       	push	r15
    4602:	0f 93       	push	r16
    4604:	df 93       	push	r29
    4606:	cf 93       	push	r28
    4608:	0f 92       	push	r0
    460a:	cd b7       	in	r28, 0x3d	; 61
    460c:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    460e:	24 e7       	ldi	r18, 0x74	; 116
    4610:	30 e0       	ldi	r19, 0x00	; 0
    4612:	8f e7       	ldi	r24, 0x7F	; 127
    4614:	96 e2       	ldi	r25, 0x26	; 38
    4616:	b9 01       	movw	r22, r18
    4618:	4a ef       	ldi	r20, 0xFA	; 250
    461a:	50 e0       	ldi	r21, 0x00	; 0
    461c:	20 e0       	ldi	r18, 0x00	; 0
    461e:	30 e0       	ldi	r19, 0x00	; 0
    4620:	00 e0       	ldi	r16, 0x00	; 0
    4622:	ee 24       	eor	r14, r14
    4624:	ff 24       	eor	r15, r15
    4626:	cc 24       	eor	r12, r12
    4628:	dd 24       	eor	r13, r13
    462a:	aa 24       	eor	r10, r10
    462c:	bb 24       	eor	r11, r11
    462e:	0e 94 a3 1f 	call	0x3f46	; 0x3f46 <xTaskGenericCreate>
    4632:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    4634:	89 81       	ldd	r24, Y+1	; 0x01
    4636:	81 30       	cpi	r24, 0x01	; 1
    4638:	51 f4       	brne	.+20     	; 0x464e <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    463a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    463c:	81 e0       	ldi	r24, 0x01	; 1
    463e:	80 93 c4 04 	sts	0x04C4, r24
		xTickCount = ( portTickType ) 0U;
    4642:	10 92 c1 04 	sts	0x04C1, r1
    4646:	10 92 c0 04 	sts	0x04C0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    464a:	0e 94 b4 19 	call	0x3368	; 0x3368 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    464e:	0f 90       	pop	r0
    4650:	cf 91       	pop	r28
    4652:	df 91       	pop	r29
    4654:	0f 91       	pop	r16
    4656:	ff 90       	pop	r15
    4658:	ef 90       	pop	r14
    465a:	df 90       	pop	r13
    465c:	cf 90       	pop	r12
    465e:	bf 90       	pop	r11
    4660:	af 90       	pop	r10
    4662:	08 95       	ret

00004664 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4664:	df 93       	push	r29
    4666:	cf 93       	push	r28
    4668:	cd b7       	in	r28, 0x3d	; 61
    466a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    466c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    466e:	10 92 c4 04 	sts	0x04C4, r1
	vPortEndScheduler();
    4672:	0e 94 e9 19 	call	0x33d2	; 0x33d2 <vPortEndScheduler>
}
    4676:	cf 91       	pop	r28
    4678:	df 91       	pop	r29
    467a:	08 95       	ret

0000467c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    467c:	df 93       	push	r29
    467e:	cf 93       	push	r28
    4680:	cd b7       	in	r28, 0x3d	; 61
    4682:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    4684:	80 91 c5 04 	lds	r24, 0x04C5
    4688:	8f 5f       	subi	r24, 0xFF	; 255
    468a:	80 93 c5 04 	sts	0x04C5, r24
}
    468e:	cf 91       	pop	r28
    4690:	df 91       	pop	r29
    4692:	08 95       	ret

00004694 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    4694:	df 93       	push	r29
    4696:	cf 93       	push	r28
    4698:	00 d0       	rcall	.+0      	; 0x469a <xTaskResumeAll+0x6>
    469a:	00 d0       	rcall	.+0      	; 0x469c <xTaskResumeAll+0x8>
    469c:	cd b7       	in	r28, 0x3d	; 61
    469e:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    46a0:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    46a2:	0f b6       	in	r0, 0x3f	; 63
    46a4:	f8 94       	cli
    46a6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    46a8:	80 91 c5 04 	lds	r24, 0x04C5
    46ac:	81 50       	subi	r24, 0x01	; 1
    46ae:	80 93 c5 04 	sts	0x04C5, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    46b2:	80 91 c5 04 	lds	r24, 0x04C5
    46b6:	88 23       	and	r24, r24
    46b8:	09 f0       	breq	.+2      	; 0x46bc <xTaskResumeAll+0x28>
    46ba:	6c c0       	rjmp	.+216    	; 0x4794 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    46bc:	80 91 bf 04 	lds	r24, 0x04BF
    46c0:	88 23       	and	r24, r24
    46c2:	09 f4       	brne	.+2      	; 0x46c6 <xTaskResumeAll+0x32>
    46c4:	67 c0       	rjmp	.+206    	; 0x4794 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    46c6:	19 82       	std	Y+1, r1	; 0x01
    46c8:	41 c0       	rjmp	.+130    	; 0x474c <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    46ca:	e0 91 09 05 	lds	r30, 0x0509
    46ce:	f0 91 0a 05 	lds	r31, 0x050A
    46d2:	86 81       	ldd	r24, Z+6	; 0x06
    46d4:	97 81       	ldd	r25, Z+7	; 0x07
    46d6:	9c 83       	std	Y+4, r25	; 0x04
    46d8:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    46da:	8b 81       	ldd	r24, Y+3	; 0x03
    46dc:	9c 81       	ldd	r25, Y+4	; 0x04
    46de:	0c 96       	adiw	r24, 0x0c	; 12
    46e0:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    46e4:	8b 81       	ldd	r24, Y+3	; 0x03
    46e6:	9c 81       	ldd	r25, Y+4	; 0x04
    46e8:	02 96       	adiw	r24, 0x02	; 2
    46ea:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    46ee:	eb 81       	ldd	r30, Y+3	; 0x03
    46f0:	fc 81       	ldd	r31, Y+4	; 0x04
    46f2:	96 89       	ldd	r25, Z+22	; 0x16
    46f4:	80 91 c3 04 	lds	r24, 0x04C3
    46f8:	89 17       	cp	r24, r25
    46fa:	28 f4       	brcc	.+10     	; 0x4706 <xTaskResumeAll+0x72>
    46fc:	eb 81       	ldd	r30, Y+3	; 0x03
    46fe:	fc 81       	ldd	r31, Y+4	; 0x04
    4700:	86 89       	ldd	r24, Z+22	; 0x16
    4702:	80 93 c3 04 	sts	0x04C3, r24
    4706:	eb 81       	ldd	r30, Y+3	; 0x03
    4708:	fc 81       	ldd	r31, Y+4	; 0x04
    470a:	86 89       	ldd	r24, Z+22	; 0x16
    470c:	28 2f       	mov	r18, r24
    470e:	30 e0       	ldi	r19, 0x00	; 0
    4710:	c9 01       	movw	r24, r18
    4712:	88 0f       	add	r24, r24
    4714:	99 1f       	adc	r25, r25
    4716:	88 0f       	add	r24, r24
    4718:	99 1f       	adc	r25, r25
    471a:	88 0f       	add	r24, r24
    471c:	99 1f       	adc	r25, r25
    471e:	82 0f       	add	r24, r18
    4720:	93 1f       	adc	r25, r19
    4722:	86 53       	subi	r24, 0x36	; 54
    4724:	9b 4f       	sbci	r25, 0xFB	; 251
    4726:	2b 81       	ldd	r18, Y+3	; 0x03
    4728:	3c 81       	ldd	r19, Y+4	; 0x04
    472a:	2e 5f       	subi	r18, 0xFE	; 254
    472c:	3f 4f       	sbci	r19, 0xFF	; 255
    472e:	b9 01       	movw	r22, r18
    4730:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4734:	eb 81       	ldd	r30, Y+3	; 0x03
    4736:	fc 81       	ldd	r31, Y+4	; 0x04
    4738:	96 89       	ldd	r25, Z+22	; 0x16
    473a:	e0 91 bc 04 	lds	r30, 0x04BC
    473e:	f0 91 bd 04 	lds	r31, 0x04BD
    4742:	86 89       	ldd	r24, Z+22	; 0x16
    4744:	98 17       	cp	r25, r24
    4746:	10 f0       	brcs	.+4      	; 0x474c <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    4748:	81 e0       	ldi	r24, 0x01	; 1
    474a:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    474c:	80 91 04 05 	lds	r24, 0x0504
    4750:	88 23       	and	r24, r24
    4752:	09 f0       	breq	.+2      	; 0x4756 <xTaskResumeAll+0xc2>
    4754:	ba cf       	rjmp	.-140    	; 0x46ca <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4756:	80 91 c6 04 	lds	r24, 0x04C6
    475a:	88 23       	and	r24, r24
    475c:	71 f0       	breq	.+28     	; 0x477a <xTaskResumeAll+0xe6>
    475e:	07 c0       	rjmp	.+14     	; 0x476e <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    4760:	0e 94 09 24 	call	0x4812	; 0x4812 <vTaskIncrementTick>
						--uxMissedTicks;
    4764:	80 91 c6 04 	lds	r24, 0x04C6
    4768:	81 50       	subi	r24, 0x01	; 1
    476a:	80 93 c6 04 	sts	0x04C6, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    476e:	80 91 c6 04 	lds	r24, 0x04C6
    4772:	88 23       	and	r24, r24
    4774:	a9 f7       	brne	.-22     	; 0x4760 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    4776:	81 e0       	ldi	r24, 0x01	; 1
    4778:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    477a:	89 81       	ldd	r24, Y+1	; 0x01
    477c:	81 30       	cpi	r24, 0x01	; 1
    477e:	21 f0       	breq	.+8      	; 0x4788 <xTaskResumeAll+0xf4>
    4780:	80 91 c7 04 	lds	r24, 0x04C7
    4784:	81 30       	cpi	r24, 0x01	; 1
    4786:	31 f4       	brne	.+12     	; 0x4794 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    4788:	81 e0       	ldi	r24, 0x01	; 1
    478a:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    478c:	10 92 c7 04 	sts	0x04C7, r1
					portYIELD_WITHIN_API();
    4790:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    4794:	0f 90       	pop	r0
    4796:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4798:	8a 81       	ldd	r24, Y+2	; 0x02
}
    479a:	0f 90       	pop	r0
    479c:	0f 90       	pop	r0
    479e:	0f 90       	pop	r0
    47a0:	0f 90       	pop	r0
    47a2:	cf 91       	pop	r28
    47a4:	df 91       	pop	r29
    47a6:	08 95       	ret

000047a8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    47a8:	df 93       	push	r29
    47aa:	cf 93       	push	r28
    47ac:	00 d0       	rcall	.+0      	; 0x47ae <xTaskGetTickCount+0x6>
    47ae:	cd b7       	in	r28, 0x3d	; 61
    47b0:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    47b2:	0f b6       	in	r0, 0x3f	; 63
    47b4:	f8 94       	cli
    47b6:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    47b8:	80 91 c0 04 	lds	r24, 0x04C0
    47bc:	90 91 c1 04 	lds	r25, 0x04C1
    47c0:	9a 83       	std	Y+2, r25	; 0x02
    47c2:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    47c4:	0f 90       	pop	r0
    47c6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    47c8:	89 81       	ldd	r24, Y+1	; 0x01
    47ca:	9a 81       	ldd	r25, Y+2	; 0x02
}
    47cc:	0f 90       	pop	r0
    47ce:	0f 90       	pop	r0
    47d0:	cf 91       	pop	r28
    47d2:	df 91       	pop	r29
    47d4:	08 95       	ret

000047d6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    47d6:	df 93       	push	r29
    47d8:	cf 93       	push	r28
    47da:	00 d0       	rcall	.+0      	; 0x47dc <xTaskGetTickCountFromISR+0x6>
    47dc:	0f 92       	push	r0
    47de:	cd b7       	in	r28, 0x3d	; 61
    47e0:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    47e2:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    47e4:	80 91 c0 04 	lds	r24, 0x04C0
    47e8:	90 91 c1 04 	lds	r25, 0x04C1
    47ec:	9b 83       	std	Y+3, r25	; 0x03
    47ee:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    47f0:	8a 81       	ldd	r24, Y+2	; 0x02
    47f2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    47f4:	0f 90       	pop	r0
    47f6:	0f 90       	pop	r0
    47f8:	0f 90       	pop	r0
    47fa:	cf 91       	pop	r28
    47fc:	df 91       	pop	r29
    47fe:	08 95       	ret

00004800 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4800:	df 93       	push	r29
    4802:	cf 93       	push	r28
    4804:	cd b7       	in	r28, 0x3d	; 61
    4806:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    4808:	80 91 bf 04 	lds	r24, 0x04BF
}
    480c:	cf 91       	pop	r28
    480e:	df 91       	pop	r29
    4810:	08 95       	ret

00004812 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4812:	df 93       	push	r29
    4814:	cf 93       	push	r28
    4816:	00 d0       	rcall	.+0      	; 0x4818 <vTaskIncrementTick+0x6>
    4818:	00 d0       	rcall	.+0      	; 0x481a <vTaskIncrementTick+0x8>
    481a:	00 d0       	rcall	.+0      	; 0x481c <vTaskIncrementTick+0xa>
    481c:	cd b7       	in	r28, 0x3d	; 61
    481e:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4820:	80 91 c5 04 	lds	r24, 0x04C5
    4824:	88 23       	and	r24, r24
    4826:	09 f0       	breq	.+2      	; 0x482a <vTaskIncrementTick+0x18>
    4828:	bb c0       	rjmp	.+374    	; 0x49a0 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    482a:	80 91 c0 04 	lds	r24, 0x04C0
    482e:	90 91 c1 04 	lds	r25, 0x04C1
    4832:	01 96       	adiw	r24, 0x01	; 1
    4834:	90 93 c1 04 	sts	0x04C1, r25
    4838:	80 93 c0 04 	sts	0x04C0, r24
		if( xTickCount == ( portTickType ) 0U )
    483c:	80 91 c0 04 	lds	r24, 0x04C0
    4840:	90 91 c1 04 	lds	r25, 0x04C1
    4844:	00 97       	sbiw	r24, 0x00	; 0
    4846:	d1 f5       	brne	.+116    	; 0x48bc <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    4848:	80 91 00 05 	lds	r24, 0x0500
    484c:	90 91 01 05 	lds	r25, 0x0501
    4850:	9c 83       	std	Y+4, r25	; 0x04
    4852:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    4854:	80 91 02 05 	lds	r24, 0x0502
    4858:	90 91 03 05 	lds	r25, 0x0503
    485c:	90 93 01 05 	sts	0x0501, r25
    4860:	80 93 00 05 	sts	0x0500, r24
			pxOverflowDelayedTaskList = pxTemp;
    4864:	8b 81       	ldd	r24, Y+3	; 0x03
    4866:	9c 81       	ldd	r25, Y+4	; 0x04
    4868:	90 93 03 05 	sts	0x0503, r25
    486c:	80 93 02 05 	sts	0x0502, r24
			xNumOfOverflows++;
    4870:	80 91 c8 04 	lds	r24, 0x04C8
    4874:	8f 5f       	subi	r24, 0xFF	; 255
    4876:	80 93 c8 04 	sts	0x04C8, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    487a:	e0 91 00 05 	lds	r30, 0x0500
    487e:	f0 91 01 05 	lds	r31, 0x0501
    4882:	80 81       	ld	r24, Z
    4884:	88 23       	and	r24, r24
    4886:	39 f4       	brne	.+14     	; 0x4896 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    4888:	8f ef       	ldi	r24, 0xFF	; 255
    488a:	9f ef       	ldi	r25, 0xFF	; 255
    488c:	90 93 82 00 	sts	0x0082, r25
    4890:	80 93 81 00 	sts	0x0081, r24
    4894:	13 c0       	rjmp	.+38     	; 0x48bc <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4896:	e0 91 00 05 	lds	r30, 0x0500
    489a:	f0 91 01 05 	lds	r31, 0x0501
    489e:	05 80       	ldd	r0, Z+5	; 0x05
    48a0:	f6 81       	ldd	r31, Z+6	; 0x06
    48a2:	e0 2d       	mov	r30, r0
    48a4:	86 81       	ldd	r24, Z+6	; 0x06
    48a6:	97 81       	ldd	r25, Z+7	; 0x07
    48a8:	9e 83       	std	Y+6, r25	; 0x06
    48aa:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    48ac:	ed 81       	ldd	r30, Y+5	; 0x05
    48ae:	fe 81       	ldd	r31, Y+6	; 0x06
    48b0:	82 81       	ldd	r24, Z+2	; 0x02
    48b2:	93 81       	ldd	r25, Z+3	; 0x03
    48b4:	90 93 82 00 	sts	0x0082, r25
    48b8:	80 93 81 00 	sts	0x0081, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    48bc:	20 91 c0 04 	lds	r18, 0x04C0
    48c0:	30 91 c1 04 	lds	r19, 0x04C1
    48c4:	80 91 81 00 	lds	r24, 0x0081
    48c8:	90 91 82 00 	lds	r25, 0x0082
    48cc:	28 17       	cp	r18, r24
    48ce:	39 07       	cpc	r19, r25
    48d0:	08 f4       	brcc	.+2      	; 0x48d4 <vTaskIncrementTick+0xc2>
    48d2:	6b c0       	rjmp	.+214    	; 0x49aa <vTaskIncrementTick+0x198>
    48d4:	e0 91 00 05 	lds	r30, 0x0500
    48d8:	f0 91 01 05 	lds	r31, 0x0501
    48dc:	80 81       	ld	r24, Z
    48de:	88 23       	and	r24, r24
    48e0:	39 f4       	brne	.+14     	; 0x48f0 <vTaskIncrementTick+0xde>
    48e2:	8f ef       	ldi	r24, 0xFF	; 255
    48e4:	9f ef       	ldi	r25, 0xFF	; 255
    48e6:	90 93 82 00 	sts	0x0082, r25
    48ea:	80 93 81 00 	sts	0x0081, r24
    48ee:	5d c0       	rjmp	.+186    	; 0x49aa <vTaskIncrementTick+0x198>
    48f0:	e0 91 00 05 	lds	r30, 0x0500
    48f4:	f0 91 01 05 	lds	r31, 0x0501
    48f8:	05 80       	ldd	r0, Z+5	; 0x05
    48fa:	f6 81       	ldd	r31, Z+6	; 0x06
    48fc:	e0 2d       	mov	r30, r0
    48fe:	86 81       	ldd	r24, Z+6	; 0x06
    4900:	97 81       	ldd	r25, Z+7	; 0x07
    4902:	9e 83       	std	Y+6, r25	; 0x06
    4904:	8d 83       	std	Y+5, r24	; 0x05
    4906:	ed 81       	ldd	r30, Y+5	; 0x05
    4908:	fe 81       	ldd	r31, Y+6	; 0x06
    490a:	82 81       	ldd	r24, Z+2	; 0x02
    490c:	93 81       	ldd	r25, Z+3	; 0x03
    490e:	9a 83       	std	Y+2, r25	; 0x02
    4910:	89 83       	std	Y+1, r24	; 0x01
    4912:	20 91 c0 04 	lds	r18, 0x04C0
    4916:	30 91 c1 04 	lds	r19, 0x04C1
    491a:	89 81       	ldd	r24, Y+1	; 0x01
    491c:	9a 81       	ldd	r25, Y+2	; 0x02
    491e:	28 17       	cp	r18, r24
    4920:	39 07       	cpc	r19, r25
    4922:	38 f4       	brcc	.+14     	; 0x4932 <vTaskIncrementTick+0x120>
    4924:	89 81       	ldd	r24, Y+1	; 0x01
    4926:	9a 81       	ldd	r25, Y+2	; 0x02
    4928:	90 93 82 00 	sts	0x0082, r25
    492c:	80 93 81 00 	sts	0x0081, r24
    4930:	3c c0       	rjmp	.+120    	; 0x49aa <vTaskIncrementTick+0x198>
    4932:	8d 81       	ldd	r24, Y+5	; 0x05
    4934:	9e 81       	ldd	r25, Y+6	; 0x06
    4936:	02 96       	adiw	r24, 0x02	; 2
    4938:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
    493c:	ed 81       	ldd	r30, Y+5	; 0x05
    493e:	fe 81       	ldd	r31, Y+6	; 0x06
    4940:	84 89       	ldd	r24, Z+20	; 0x14
    4942:	95 89       	ldd	r25, Z+21	; 0x15
    4944:	00 97       	sbiw	r24, 0x00	; 0
    4946:	29 f0       	breq	.+10     	; 0x4952 <vTaskIncrementTick+0x140>
    4948:	8d 81       	ldd	r24, Y+5	; 0x05
    494a:	9e 81       	ldd	r25, Y+6	; 0x06
    494c:	0c 96       	adiw	r24, 0x0c	; 12
    494e:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
    4952:	ed 81       	ldd	r30, Y+5	; 0x05
    4954:	fe 81       	ldd	r31, Y+6	; 0x06
    4956:	96 89       	ldd	r25, Z+22	; 0x16
    4958:	80 91 c3 04 	lds	r24, 0x04C3
    495c:	89 17       	cp	r24, r25
    495e:	28 f4       	brcc	.+10     	; 0x496a <vTaskIncrementTick+0x158>
    4960:	ed 81       	ldd	r30, Y+5	; 0x05
    4962:	fe 81       	ldd	r31, Y+6	; 0x06
    4964:	86 89       	ldd	r24, Z+22	; 0x16
    4966:	80 93 c3 04 	sts	0x04C3, r24
    496a:	ed 81       	ldd	r30, Y+5	; 0x05
    496c:	fe 81       	ldd	r31, Y+6	; 0x06
    496e:	86 89       	ldd	r24, Z+22	; 0x16
    4970:	28 2f       	mov	r18, r24
    4972:	30 e0       	ldi	r19, 0x00	; 0
    4974:	c9 01       	movw	r24, r18
    4976:	88 0f       	add	r24, r24
    4978:	99 1f       	adc	r25, r25
    497a:	88 0f       	add	r24, r24
    497c:	99 1f       	adc	r25, r25
    497e:	88 0f       	add	r24, r24
    4980:	99 1f       	adc	r25, r25
    4982:	82 0f       	add	r24, r18
    4984:	93 1f       	adc	r25, r19
    4986:	ac 01       	movw	r20, r24
    4988:	46 53       	subi	r20, 0x36	; 54
    498a:	5b 4f       	sbci	r21, 0xFB	; 251
    498c:	8d 81       	ldd	r24, Y+5	; 0x05
    498e:	9e 81       	ldd	r25, Y+6	; 0x06
    4990:	9c 01       	movw	r18, r24
    4992:	2e 5f       	subi	r18, 0xFE	; 254
    4994:	3f 4f       	sbci	r19, 0xFF	; 255
    4996:	ca 01       	movw	r24, r20
    4998:	b9 01       	movw	r22, r18
    499a:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>
    499e:	9a cf       	rjmp	.-204    	; 0x48d4 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    49a0:	80 91 c6 04 	lds	r24, 0x04C6
    49a4:	8f 5f       	subi	r24, 0xFF	; 255
    49a6:	80 93 c6 04 	sts	0x04C6, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    49aa:	26 96       	adiw	r28, 0x06	; 6
    49ac:	0f b6       	in	r0, 0x3f	; 63
    49ae:	f8 94       	cli
    49b0:	de bf       	out	0x3e, r29	; 62
    49b2:	0f be       	out	0x3f, r0	; 63
    49b4:	cd bf       	out	0x3d, r28	; 61
    49b6:	cf 91       	pop	r28
    49b8:	df 91       	pop	r29
    49ba:	08 95       	ret

000049bc <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    49bc:	df 93       	push	r29
    49be:	cf 93       	push	r28
    49c0:	00 d0       	rcall	.+0      	; 0x49c2 <vTaskSwitchContext+0x6>
    49c2:	cd b7       	in	r28, 0x3d	; 61
    49c4:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    49c6:	80 91 c5 04 	lds	r24, 0x04C5
    49ca:	88 23       	and	r24, r24
    49cc:	49 f0       	breq	.+18     	; 0x49e0 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    49ce:	81 e0       	ldi	r24, 0x01	; 1
    49d0:	80 93 c7 04 	sts	0x04C7, r24
    49d4:	54 c0       	rjmp	.+168    	; 0x4a7e <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    49d6:	80 91 c3 04 	lds	r24, 0x04C3
    49da:	81 50       	subi	r24, 0x01	; 1
    49dc:	80 93 c3 04 	sts	0x04C3, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    49e0:	80 91 c3 04 	lds	r24, 0x04C3
    49e4:	28 2f       	mov	r18, r24
    49e6:	30 e0       	ldi	r19, 0x00	; 0
    49e8:	c9 01       	movw	r24, r18
    49ea:	88 0f       	add	r24, r24
    49ec:	99 1f       	adc	r25, r25
    49ee:	88 0f       	add	r24, r24
    49f0:	99 1f       	adc	r25, r25
    49f2:	88 0f       	add	r24, r24
    49f4:	99 1f       	adc	r25, r25
    49f6:	82 0f       	add	r24, r18
    49f8:	93 1f       	adc	r25, r19
    49fa:	fc 01       	movw	r30, r24
    49fc:	e6 53       	subi	r30, 0x36	; 54
    49fe:	fb 4f       	sbci	r31, 0xFB	; 251
    4a00:	80 81       	ld	r24, Z
    4a02:	88 23       	and	r24, r24
    4a04:	41 f3       	breq	.-48     	; 0x49d6 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    4a06:	80 91 c3 04 	lds	r24, 0x04C3
    4a0a:	28 2f       	mov	r18, r24
    4a0c:	30 e0       	ldi	r19, 0x00	; 0
    4a0e:	c9 01       	movw	r24, r18
    4a10:	88 0f       	add	r24, r24
    4a12:	99 1f       	adc	r25, r25
    4a14:	88 0f       	add	r24, r24
    4a16:	99 1f       	adc	r25, r25
    4a18:	88 0f       	add	r24, r24
    4a1a:	99 1f       	adc	r25, r25
    4a1c:	82 0f       	add	r24, r18
    4a1e:	93 1f       	adc	r25, r19
    4a20:	86 53       	subi	r24, 0x36	; 54
    4a22:	9b 4f       	sbci	r25, 0xFB	; 251
    4a24:	9a 83       	std	Y+2, r25	; 0x02
    4a26:	89 83       	std	Y+1, r24	; 0x01
    4a28:	e9 81       	ldd	r30, Y+1	; 0x01
    4a2a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a2c:	01 80       	ldd	r0, Z+1	; 0x01
    4a2e:	f2 81       	ldd	r31, Z+2	; 0x02
    4a30:	e0 2d       	mov	r30, r0
    4a32:	82 81       	ldd	r24, Z+2	; 0x02
    4a34:	93 81       	ldd	r25, Z+3	; 0x03
    4a36:	e9 81       	ldd	r30, Y+1	; 0x01
    4a38:	fa 81       	ldd	r31, Y+2	; 0x02
    4a3a:	92 83       	std	Z+2, r25	; 0x02
    4a3c:	81 83       	std	Z+1, r24	; 0x01
    4a3e:	e9 81       	ldd	r30, Y+1	; 0x01
    4a40:	fa 81       	ldd	r31, Y+2	; 0x02
    4a42:	21 81       	ldd	r18, Z+1	; 0x01
    4a44:	32 81       	ldd	r19, Z+2	; 0x02
    4a46:	89 81       	ldd	r24, Y+1	; 0x01
    4a48:	9a 81       	ldd	r25, Y+2	; 0x02
    4a4a:	03 96       	adiw	r24, 0x03	; 3
    4a4c:	28 17       	cp	r18, r24
    4a4e:	39 07       	cpc	r19, r25
    4a50:	59 f4       	brne	.+22     	; 0x4a68 <vTaskSwitchContext+0xac>
    4a52:	e9 81       	ldd	r30, Y+1	; 0x01
    4a54:	fa 81       	ldd	r31, Y+2	; 0x02
    4a56:	01 80       	ldd	r0, Z+1	; 0x01
    4a58:	f2 81       	ldd	r31, Z+2	; 0x02
    4a5a:	e0 2d       	mov	r30, r0
    4a5c:	82 81       	ldd	r24, Z+2	; 0x02
    4a5e:	93 81       	ldd	r25, Z+3	; 0x03
    4a60:	e9 81       	ldd	r30, Y+1	; 0x01
    4a62:	fa 81       	ldd	r31, Y+2	; 0x02
    4a64:	92 83       	std	Z+2, r25	; 0x02
    4a66:	81 83       	std	Z+1, r24	; 0x01
    4a68:	e9 81       	ldd	r30, Y+1	; 0x01
    4a6a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a6c:	01 80       	ldd	r0, Z+1	; 0x01
    4a6e:	f2 81       	ldd	r31, Z+2	; 0x02
    4a70:	e0 2d       	mov	r30, r0
    4a72:	86 81       	ldd	r24, Z+6	; 0x06
    4a74:	97 81       	ldd	r25, Z+7	; 0x07
    4a76:	90 93 bd 04 	sts	0x04BD, r25
    4a7a:	80 93 bc 04 	sts	0x04BC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    4a7e:	0f 90       	pop	r0
    4a80:	0f 90       	pop	r0
    4a82:	cf 91       	pop	r28
    4a84:	df 91       	pop	r29
    4a86:	08 95       	ret

00004a88 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    4a88:	df 93       	push	r29
    4a8a:	cf 93       	push	r28
    4a8c:	00 d0       	rcall	.+0      	; 0x4a8e <vTaskPlaceOnEventList+0x6>
    4a8e:	00 d0       	rcall	.+0      	; 0x4a90 <vTaskPlaceOnEventList+0x8>
    4a90:	00 d0       	rcall	.+0      	; 0x4a92 <vTaskPlaceOnEventList+0xa>
    4a92:	cd b7       	in	r28, 0x3d	; 61
    4a94:	de b7       	in	r29, 0x3e	; 62
    4a96:	9c 83       	std	Y+4, r25	; 0x04
    4a98:	8b 83       	std	Y+3, r24	; 0x03
    4a9a:	7e 83       	std	Y+6, r23	; 0x06
    4a9c:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    4a9e:	4b 81       	ldd	r20, Y+3	; 0x03
    4aa0:	5c 81       	ldd	r21, Y+4	; 0x04
    4aa2:	80 91 bc 04 	lds	r24, 0x04BC
    4aa6:	90 91 bd 04 	lds	r25, 0x04BD
    4aaa:	9c 01       	movw	r18, r24
    4aac:	24 5f       	subi	r18, 0xF4	; 244
    4aae:	3f 4f       	sbci	r19, 0xFF	; 255
    4ab0:	ca 01       	movw	r24, r20
    4ab2:	b9 01       	movw	r22, r18
    4ab4:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4ab8:	80 91 bc 04 	lds	r24, 0x04BC
    4abc:	90 91 bd 04 	lds	r25, 0x04BD
    4ac0:	02 96       	adiw	r24, 0x02	; 2
    4ac2:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    4ac6:	8d 81       	ldd	r24, Y+5	; 0x05
    4ac8:	9e 81       	ldd	r25, Y+6	; 0x06
    4aca:	2f ef       	ldi	r18, 0xFF	; 255
    4acc:	8f 3f       	cpi	r24, 0xFF	; 255
    4ace:	92 07       	cpc	r25, r18
    4ad0:	69 f4       	brne	.+26     	; 0x4aec <vTaskPlaceOnEventList+0x64>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4ad2:	80 91 bc 04 	lds	r24, 0x04BC
    4ad6:	90 91 bd 04 	lds	r25, 0x04BD
    4ada:	9c 01       	movw	r18, r24
    4adc:	2e 5f       	subi	r18, 0xFE	; 254
    4ade:	3f 4f       	sbci	r19, 0xFF	; 255
    4ae0:	86 e1       	ldi	r24, 0x16	; 22
    4ae2:	95 e0       	ldi	r25, 0x05	; 5
    4ae4:	b9 01       	movw	r22, r18
    4ae6:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>
    4aea:	0e c0       	rjmp	.+28     	; 0x4b08 <vTaskPlaceOnEventList+0x80>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    4aec:	20 91 c0 04 	lds	r18, 0x04C0
    4af0:	30 91 c1 04 	lds	r19, 0x04C1
    4af4:	8d 81       	ldd	r24, Y+5	; 0x05
    4af6:	9e 81       	ldd	r25, Y+6	; 0x06
    4af8:	82 0f       	add	r24, r18
    4afa:	93 1f       	adc	r25, r19
    4afc:	9a 83       	std	Y+2, r25	; 0x02
    4afe:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4b00:	89 81       	ldd	r24, Y+1	; 0x01
    4b02:	9a 81       	ldd	r25, Y+2	; 0x02
    4b04:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    4b08:	26 96       	adiw	r28, 0x06	; 6
    4b0a:	0f b6       	in	r0, 0x3f	; 63
    4b0c:	f8 94       	cli
    4b0e:	de bf       	out	0x3e, r29	; 62
    4b10:	0f be       	out	0x3f, r0	; 63
    4b12:	cd bf       	out	0x3d, r28	; 61
    4b14:	cf 91       	pop	r28
    4b16:	df 91       	pop	r29
    4b18:	08 95       	ret

00004b1a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    4b1a:	df 93       	push	r29
    4b1c:	cf 93       	push	r28
    4b1e:	00 d0       	rcall	.+0      	; 0x4b20 <xTaskRemoveFromEventList+0x6>
    4b20:	00 d0       	rcall	.+0      	; 0x4b22 <xTaskRemoveFromEventList+0x8>
    4b22:	0f 92       	push	r0
    4b24:	cd b7       	in	r28, 0x3d	; 61
    4b26:	de b7       	in	r29, 0x3e	; 62
    4b28:	9d 83       	std	Y+5, r25	; 0x05
    4b2a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4b2c:	ec 81       	ldd	r30, Y+4	; 0x04
    4b2e:	fd 81       	ldd	r31, Y+5	; 0x05
    4b30:	05 80       	ldd	r0, Z+5	; 0x05
    4b32:	f6 81       	ldd	r31, Z+6	; 0x06
    4b34:	e0 2d       	mov	r30, r0
    4b36:	86 81       	ldd	r24, Z+6	; 0x06
    4b38:	97 81       	ldd	r25, Z+7	; 0x07
    4b3a:	9b 83       	std	Y+3, r25	; 0x03
    4b3c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b40:	9b 81       	ldd	r25, Y+3	; 0x03
    4b42:	0c 96       	adiw	r24, 0x0c	; 12
    4b44:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4b48:	80 91 c5 04 	lds	r24, 0x04C5
    4b4c:	88 23       	and	r24, r24
    4b4e:	61 f5       	brne	.+88     	; 0x4ba8 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4b50:	8a 81       	ldd	r24, Y+2	; 0x02
    4b52:	9b 81       	ldd	r25, Y+3	; 0x03
    4b54:	02 96       	adiw	r24, 0x02	; 2
    4b56:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4b5a:	ea 81       	ldd	r30, Y+2	; 0x02
    4b5c:	fb 81       	ldd	r31, Y+3	; 0x03
    4b5e:	96 89       	ldd	r25, Z+22	; 0x16
    4b60:	80 91 c3 04 	lds	r24, 0x04C3
    4b64:	89 17       	cp	r24, r25
    4b66:	28 f4       	brcc	.+10     	; 0x4b72 <xTaskRemoveFromEventList+0x58>
    4b68:	ea 81       	ldd	r30, Y+2	; 0x02
    4b6a:	fb 81       	ldd	r31, Y+3	; 0x03
    4b6c:	86 89       	ldd	r24, Z+22	; 0x16
    4b6e:	80 93 c3 04 	sts	0x04C3, r24
    4b72:	ea 81       	ldd	r30, Y+2	; 0x02
    4b74:	fb 81       	ldd	r31, Y+3	; 0x03
    4b76:	86 89       	ldd	r24, Z+22	; 0x16
    4b78:	28 2f       	mov	r18, r24
    4b7a:	30 e0       	ldi	r19, 0x00	; 0
    4b7c:	c9 01       	movw	r24, r18
    4b7e:	88 0f       	add	r24, r24
    4b80:	99 1f       	adc	r25, r25
    4b82:	88 0f       	add	r24, r24
    4b84:	99 1f       	adc	r25, r25
    4b86:	88 0f       	add	r24, r24
    4b88:	99 1f       	adc	r25, r25
    4b8a:	82 0f       	add	r24, r18
    4b8c:	93 1f       	adc	r25, r19
    4b8e:	ac 01       	movw	r20, r24
    4b90:	46 53       	subi	r20, 0x36	; 54
    4b92:	5b 4f       	sbci	r21, 0xFB	; 251
    4b94:	8a 81       	ldd	r24, Y+2	; 0x02
    4b96:	9b 81       	ldd	r25, Y+3	; 0x03
    4b98:	9c 01       	movw	r18, r24
    4b9a:	2e 5f       	subi	r18, 0xFE	; 254
    4b9c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b9e:	ca 01       	movw	r24, r20
    4ba0:	b9 01       	movw	r22, r18
    4ba2:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>
    4ba6:	0a c0       	rjmp	.+20     	; 0x4bbc <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4ba8:	8a 81       	ldd	r24, Y+2	; 0x02
    4baa:	9b 81       	ldd	r25, Y+3	; 0x03
    4bac:	9c 01       	movw	r18, r24
    4bae:	24 5f       	subi	r18, 0xF4	; 244
    4bb0:	3f 4f       	sbci	r19, 0xFF	; 255
    4bb2:	84 e0       	ldi	r24, 0x04	; 4
    4bb4:	95 e0       	ldi	r25, 0x05	; 5
    4bb6:	b9 01       	movw	r22, r18
    4bb8:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4bbc:	ea 81       	ldd	r30, Y+2	; 0x02
    4bbe:	fb 81       	ldd	r31, Y+3	; 0x03
    4bc0:	96 89       	ldd	r25, Z+22	; 0x16
    4bc2:	e0 91 bc 04 	lds	r30, 0x04BC
    4bc6:	f0 91 bd 04 	lds	r31, 0x04BD
    4bca:	86 89       	ldd	r24, Z+22	; 0x16
    4bcc:	98 17       	cp	r25, r24
    4bce:	18 f0       	brcs	.+6      	; 0x4bd6 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4bd0:	81 e0       	ldi	r24, 0x01	; 1
    4bd2:	89 83       	std	Y+1, r24	; 0x01
    4bd4:	01 c0       	rjmp	.+2      	; 0x4bd8 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    4bd6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4bd8:	89 81       	ldd	r24, Y+1	; 0x01
}
    4bda:	0f 90       	pop	r0
    4bdc:	0f 90       	pop	r0
    4bde:	0f 90       	pop	r0
    4be0:	0f 90       	pop	r0
    4be2:	0f 90       	pop	r0
    4be4:	cf 91       	pop	r28
    4be6:	df 91       	pop	r29
    4be8:	08 95       	ret

00004bea <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4bea:	df 93       	push	r29
    4bec:	cf 93       	push	r28
    4bee:	00 d0       	rcall	.+0      	; 0x4bf0 <vTaskSetTimeOutState+0x6>
    4bf0:	cd b7       	in	r28, 0x3d	; 61
    4bf2:	de b7       	in	r29, 0x3e	; 62
    4bf4:	9a 83       	std	Y+2, r25	; 0x02
    4bf6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4bf8:	80 91 c8 04 	lds	r24, 0x04C8
    4bfc:	e9 81       	ldd	r30, Y+1	; 0x01
    4bfe:	fa 81       	ldd	r31, Y+2	; 0x02
    4c00:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4c02:	80 91 c0 04 	lds	r24, 0x04C0
    4c06:	90 91 c1 04 	lds	r25, 0x04C1
    4c0a:	e9 81       	ldd	r30, Y+1	; 0x01
    4c0c:	fa 81       	ldd	r31, Y+2	; 0x02
    4c0e:	92 83       	std	Z+2, r25	; 0x02
    4c10:	81 83       	std	Z+1, r24	; 0x01
}
    4c12:	0f 90       	pop	r0
    4c14:	0f 90       	pop	r0
    4c16:	cf 91       	pop	r28
    4c18:	df 91       	pop	r29
    4c1a:	08 95       	ret

00004c1c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    4c1c:	df 93       	push	r29
    4c1e:	cf 93       	push	r28
    4c20:	00 d0       	rcall	.+0      	; 0x4c22 <xTaskCheckForTimeOut+0x6>
    4c22:	00 d0       	rcall	.+0      	; 0x4c24 <xTaskCheckForTimeOut+0x8>
    4c24:	0f 92       	push	r0
    4c26:	cd b7       	in	r28, 0x3d	; 61
    4c28:	de b7       	in	r29, 0x3e	; 62
    4c2a:	9b 83       	std	Y+3, r25	; 0x03
    4c2c:	8a 83       	std	Y+2, r24	; 0x02
    4c2e:	7d 83       	std	Y+5, r23	; 0x05
    4c30:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4c32:	0f b6       	in	r0, 0x3f	; 63
    4c34:	f8 94       	cli
    4c36:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    4c38:	ec 81       	ldd	r30, Y+4	; 0x04
    4c3a:	fd 81       	ldd	r31, Y+5	; 0x05
    4c3c:	80 81       	ld	r24, Z
    4c3e:	91 81       	ldd	r25, Z+1	; 0x01
    4c40:	2f ef       	ldi	r18, 0xFF	; 255
    4c42:	8f 3f       	cpi	r24, 0xFF	; 255
    4c44:	92 07       	cpc	r25, r18
    4c46:	11 f4       	brne	.+4      	; 0x4c4c <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    4c48:	19 82       	std	Y+1, r1	; 0x01
    4c4a:	44 c0       	rjmp	.+136    	; 0x4cd4 <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    4c4c:	ea 81       	ldd	r30, Y+2	; 0x02
    4c4e:	fb 81       	ldd	r31, Y+3	; 0x03
    4c50:	90 81       	ld	r25, Z
    4c52:	80 91 c8 04 	lds	r24, 0x04C8
    4c56:	98 17       	cp	r25, r24
    4c58:	71 f0       	breq	.+28     	; 0x4c76 <xTaskCheckForTimeOut+0x5a>
    4c5a:	ea 81       	ldd	r30, Y+2	; 0x02
    4c5c:	fb 81       	ldd	r31, Y+3	; 0x03
    4c5e:	21 81       	ldd	r18, Z+1	; 0x01
    4c60:	32 81       	ldd	r19, Z+2	; 0x02
    4c62:	80 91 c0 04 	lds	r24, 0x04C0
    4c66:	90 91 c1 04 	lds	r25, 0x04C1
    4c6a:	82 17       	cp	r24, r18
    4c6c:	93 07       	cpc	r25, r19
    4c6e:	18 f0       	brcs	.+6      	; 0x4c76 <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4c70:	81 e0       	ldi	r24, 0x01	; 1
    4c72:	89 83       	std	Y+1, r24	; 0x01
    4c74:	2f c0       	rjmp	.+94     	; 0x4cd4 <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4c76:	20 91 c0 04 	lds	r18, 0x04C0
    4c7a:	30 91 c1 04 	lds	r19, 0x04C1
    4c7e:	ea 81       	ldd	r30, Y+2	; 0x02
    4c80:	fb 81       	ldd	r31, Y+3	; 0x03
    4c82:	81 81       	ldd	r24, Z+1	; 0x01
    4c84:	92 81       	ldd	r25, Z+2	; 0x02
    4c86:	28 1b       	sub	r18, r24
    4c88:	39 0b       	sbc	r19, r25
    4c8a:	ec 81       	ldd	r30, Y+4	; 0x04
    4c8c:	fd 81       	ldd	r31, Y+5	; 0x05
    4c8e:	80 81       	ld	r24, Z
    4c90:	91 81       	ldd	r25, Z+1	; 0x01
    4c92:	28 17       	cp	r18, r24
    4c94:	39 07       	cpc	r19, r25
    4c96:	e0 f4       	brcc	.+56     	; 0x4cd0 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    4c98:	ec 81       	ldd	r30, Y+4	; 0x04
    4c9a:	fd 81       	ldd	r31, Y+5	; 0x05
    4c9c:	40 81       	ld	r20, Z
    4c9e:	51 81       	ldd	r21, Z+1	; 0x01
    4ca0:	ea 81       	ldd	r30, Y+2	; 0x02
    4ca2:	fb 81       	ldd	r31, Y+3	; 0x03
    4ca4:	21 81       	ldd	r18, Z+1	; 0x01
    4ca6:	32 81       	ldd	r19, Z+2	; 0x02
    4ca8:	80 91 c0 04 	lds	r24, 0x04C0
    4cac:	90 91 c1 04 	lds	r25, 0x04C1
    4cb0:	b9 01       	movw	r22, r18
    4cb2:	68 1b       	sub	r22, r24
    4cb4:	79 0b       	sbc	r23, r25
    4cb6:	cb 01       	movw	r24, r22
    4cb8:	84 0f       	add	r24, r20
    4cba:	95 1f       	adc	r25, r21
    4cbc:	ec 81       	ldd	r30, Y+4	; 0x04
    4cbe:	fd 81       	ldd	r31, Y+5	; 0x05
    4cc0:	91 83       	std	Z+1, r25	; 0x01
    4cc2:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    4cc4:	8a 81       	ldd	r24, Y+2	; 0x02
    4cc6:	9b 81       	ldd	r25, Y+3	; 0x03
    4cc8:	0e 94 f5 25 	call	0x4bea	; 0x4bea <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    4ccc:	19 82       	std	Y+1, r1	; 0x01
    4cce:	02 c0       	rjmp	.+4      	; 0x4cd4 <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    4cd0:	81 e0       	ldi	r24, 0x01	; 1
    4cd2:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4cd4:	0f 90       	pop	r0
    4cd6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4cd8:	89 81       	ldd	r24, Y+1	; 0x01
}
    4cda:	0f 90       	pop	r0
    4cdc:	0f 90       	pop	r0
    4cde:	0f 90       	pop	r0
    4ce0:	0f 90       	pop	r0
    4ce2:	0f 90       	pop	r0
    4ce4:	cf 91       	pop	r28
    4ce6:	df 91       	pop	r29
    4ce8:	08 95       	ret

00004cea <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4cea:	df 93       	push	r29
    4cec:	cf 93       	push	r28
    4cee:	cd b7       	in	r28, 0x3d	; 61
    4cf0:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4cf2:	81 e0       	ldi	r24, 0x01	; 1
    4cf4:	80 93 c7 04 	sts	0x04C7, r24
}
    4cf8:	cf 91       	pop	r28
    4cfa:	df 91       	pop	r29
    4cfc:	08 95       	ret

00004cfe <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4cfe:	df 93       	push	r29
    4d00:	cf 93       	push	r28
    4d02:	00 d0       	rcall	.+0      	; 0x4d04 <prvIdleTask+0x6>
    4d04:	cd b7       	in	r28, 0x3d	; 61
    4d06:	de b7       	in	r29, 0x3e	; 62
    4d08:	9a 83       	std	Y+2, r25	; 0x02
    4d0a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4d0c:	0e 94 21 27 	call	0x4e42	; 0x4e42 <prvCheckTasksWaitingTermination>
    4d10:	fd cf       	rjmp	.-6      	; 0x4d0c <prvIdleTask+0xe>

00004d12 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4d12:	0f 93       	push	r16
    4d14:	1f 93       	push	r17
    4d16:	df 93       	push	r29
    4d18:	cf 93       	push	r28
    4d1a:	cd b7       	in	r28, 0x3d	; 61
    4d1c:	de b7       	in	r29, 0x3e	; 62
    4d1e:	29 97       	sbiw	r28, 0x09	; 9
    4d20:	0f b6       	in	r0, 0x3f	; 63
    4d22:	f8 94       	cli
    4d24:	de bf       	out	0x3e, r29	; 62
    4d26:	0f be       	out	0x3f, r0	; 63
    4d28:	cd bf       	out	0x3d, r28	; 61
    4d2a:	9a 83       	std	Y+2, r25	; 0x02
    4d2c:	89 83       	std	Y+1, r24	; 0x01
    4d2e:	7c 83       	std	Y+4, r23	; 0x04
    4d30:	6b 83       	std	Y+3, r22	; 0x03
    4d32:	4d 83       	std	Y+5, r20	; 0x05
    4d34:	3f 83       	std	Y+7, r19	; 0x07
    4d36:	2e 83       	std	Y+6, r18	; 0x06
    4d38:	19 87       	std	Y+9, r17	; 0x09
    4d3a:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    4d3c:	89 81       	ldd	r24, Y+1	; 0x01
    4d3e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d40:	49 96       	adiw	r24, 0x19	; 25
    4d42:	2b 81       	ldd	r18, Y+3	; 0x03
    4d44:	3c 81       	ldd	r19, Y+4	; 0x04
    4d46:	b9 01       	movw	r22, r18
    4d48:	48 e0       	ldi	r20, 0x08	; 8
    4d4a:	50 e0       	ldi	r21, 0x00	; 0
    4d4c:	0e 94 8b 28 	call	0x5116	; 0x5116 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4d50:	e9 81       	ldd	r30, Y+1	; 0x01
    4d52:	fa 81       	ldd	r31, Y+2	; 0x02
    4d54:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4d56:	8d 81       	ldd	r24, Y+5	; 0x05
    4d58:	84 30       	cpi	r24, 0x04	; 4
    4d5a:	10 f0       	brcs	.+4      	; 0x4d60 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    4d5c:	83 e0       	ldi	r24, 0x03	; 3
    4d5e:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4d60:	e9 81       	ldd	r30, Y+1	; 0x01
    4d62:	fa 81       	ldd	r31, Y+2	; 0x02
    4d64:	8d 81       	ldd	r24, Y+5	; 0x05
    4d66:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4d68:	89 81       	ldd	r24, Y+1	; 0x01
    4d6a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d6c:	02 96       	adiw	r24, 0x02	; 2
    4d6e:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4d72:	89 81       	ldd	r24, Y+1	; 0x01
    4d74:	9a 81       	ldd	r25, Y+2	; 0x02
    4d76:	0c 96       	adiw	r24, 0x0c	; 12
    4d78:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4d7c:	e9 81       	ldd	r30, Y+1	; 0x01
    4d7e:	fa 81       	ldd	r31, Y+2	; 0x02
    4d80:	89 81       	ldd	r24, Y+1	; 0x01
    4d82:	9a 81       	ldd	r25, Y+2	; 0x02
    4d84:	91 87       	std	Z+9, r25	; 0x09
    4d86:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4d88:	8d 81       	ldd	r24, Y+5	; 0x05
    4d8a:	28 2f       	mov	r18, r24
    4d8c:	30 e0       	ldi	r19, 0x00	; 0
    4d8e:	84 e0       	ldi	r24, 0x04	; 4
    4d90:	90 e0       	ldi	r25, 0x00	; 0
    4d92:	82 1b       	sub	r24, r18
    4d94:	93 0b       	sbc	r25, r19
    4d96:	e9 81       	ldd	r30, Y+1	; 0x01
    4d98:	fa 81       	ldd	r31, Y+2	; 0x02
    4d9a:	95 87       	std	Z+13, r25	; 0x0d
    4d9c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4d9e:	e9 81       	ldd	r30, Y+1	; 0x01
    4da0:	fa 81       	ldd	r31, Y+2	; 0x02
    4da2:	89 81       	ldd	r24, Y+1	; 0x01
    4da4:	9a 81       	ldd	r25, Y+2	; 0x02
    4da6:	93 8b       	std	Z+19, r25	; 0x13
    4da8:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    4daa:	29 96       	adiw	r28, 0x09	; 9
    4dac:	0f b6       	in	r0, 0x3f	; 63
    4dae:	f8 94       	cli
    4db0:	de bf       	out	0x3e, r29	; 62
    4db2:	0f be       	out	0x3f, r0	; 63
    4db4:	cd bf       	out	0x3d, r28	; 61
    4db6:	cf 91       	pop	r28
    4db8:	df 91       	pop	r29
    4dba:	1f 91       	pop	r17
    4dbc:	0f 91       	pop	r16
    4dbe:	08 95       	ret

00004dc0 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    4dc0:	df 93       	push	r29
    4dc2:	cf 93       	push	r28
    4dc4:	0f 92       	push	r0
    4dc6:	cd b7       	in	r28, 0x3d	; 61
    4dc8:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4dca:	19 82       	std	Y+1, r1	; 0x01
    4dcc:	13 c0       	rjmp	.+38     	; 0x4df4 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4dce:	89 81       	ldd	r24, Y+1	; 0x01
    4dd0:	28 2f       	mov	r18, r24
    4dd2:	30 e0       	ldi	r19, 0x00	; 0
    4dd4:	c9 01       	movw	r24, r18
    4dd6:	88 0f       	add	r24, r24
    4dd8:	99 1f       	adc	r25, r25
    4dda:	88 0f       	add	r24, r24
    4ddc:	99 1f       	adc	r25, r25
    4dde:	88 0f       	add	r24, r24
    4de0:	99 1f       	adc	r25, r25
    4de2:	82 0f       	add	r24, r18
    4de4:	93 1f       	adc	r25, r19
    4de6:	86 53       	subi	r24, 0x36	; 54
    4de8:	9b 4f       	sbci	r25, 0xFB	; 251
    4dea:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4dee:	89 81       	ldd	r24, Y+1	; 0x01
    4df0:	8f 5f       	subi	r24, 0xFF	; 255
    4df2:	89 83       	std	Y+1, r24	; 0x01
    4df4:	89 81       	ldd	r24, Y+1	; 0x01
    4df6:	84 30       	cpi	r24, 0x04	; 4
    4df8:	50 f3       	brcs	.-44     	; 0x4dce <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4dfa:	8e ee       	ldi	r24, 0xEE	; 238
    4dfc:	94 e0       	ldi	r25, 0x04	; 4
    4dfe:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4e02:	87 ef       	ldi	r24, 0xF7	; 247
    4e04:	94 e0       	ldi	r25, 0x04	; 4
    4e06:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    4e0a:	84 e0       	ldi	r24, 0x04	; 4
    4e0c:	95 e0       	ldi	r25, 0x05	; 5
    4e0e:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4e12:	8d e0       	ldi	r24, 0x0D	; 13
    4e14:	95 e0       	ldi	r25, 0x05	; 5
    4e16:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    4e1a:	86 e1       	ldi	r24, 0x16	; 22
    4e1c:	95 e0       	ldi	r25, 0x05	; 5
    4e1e:	0e 94 f6 16 	call	0x2dec	; 0x2dec <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4e22:	8e ee       	ldi	r24, 0xEE	; 238
    4e24:	94 e0       	ldi	r25, 0x04	; 4
    4e26:	90 93 01 05 	sts	0x0501, r25
    4e2a:	80 93 00 05 	sts	0x0500, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4e2e:	87 ef       	ldi	r24, 0xF7	; 247
    4e30:	94 e0       	ldi	r25, 0x04	; 4
    4e32:	90 93 03 05 	sts	0x0503, r25
    4e36:	80 93 02 05 	sts	0x0502, r24
}
    4e3a:	0f 90       	pop	r0
    4e3c:	cf 91       	pop	r28
    4e3e:	df 91       	pop	r29
    4e40:	08 95       	ret

00004e42 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4e42:	df 93       	push	r29
    4e44:	cf 93       	push	r28
    4e46:	00 d0       	rcall	.+0      	; 0x4e48 <prvCheckTasksWaitingTermination+0x6>
    4e48:	0f 92       	push	r0
    4e4a:	cd b7       	in	r28, 0x3d	; 61
    4e4c:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4e4e:	80 91 be 04 	lds	r24, 0x04BE
    4e52:	88 23       	and	r24, r24
    4e54:	71 f1       	breq	.+92     	; 0x4eb2 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    4e56:	0e 94 3e 23 	call	0x467c	; 0x467c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4e5a:	80 91 0d 05 	lds	r24, 0x050D
    4e5e:	1b 82       	std	Y+3, r1	; 0x03
    4e60:	88 23       	and	r24, r24
    4e62:	11 f4       	brne	.+4      	; 0x4e68 <prvCheckTasksWaitingTermination+0x26>
    4e64:	81 e0       	ldi	r24, 0x01	; 1
    4e66:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    4e68:	0e 94 4a 23 	call	0x4694	; 0x4694 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4e6e:	88 23       	and	r24, r24
    4e70:	01 f5       	brne	.+64     	; 0x4eb2 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    4e72:	0f b6       	in	r0, 0x3f	; 63
    4e74:	f8 94       	cli
    4e76:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4e78:	e0 91 12 05 	lds	r30, 0x0512
    4e7c:	f0 91 13 05 	lds	r31, 0x0513
    4e80:	86 81       	ldd	r24, Z+6	; 0x06
    4e82:	97 81       	ldd	r25, Z+7	; 0x07
    4e84:	9a 83       	std	Y+2, r25	; 0x02
    4e86:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    4e88:	89 81       	ldd	r24, Y+1	; 0x01
    4e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e8c:	02 96       	adiw	r24, 0x02	; 2
    4e8e:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <vListRemove>
					--uxCurrentNumberOfTasks;
    4e92:	80 91 bf 04 	lds	r24, 0x04BF
    4e96:	81 50       	subi	r24, 0x01	; 1
    4e98:	80 93 bf 04 	sts	0x04BF, r24
					--uxTasksDeleted;
    4e9c:	80 91 be 04 	lds	r24, 0x04BE
    4ea0:	81 50       	subi	r24, 0x01	; 1
    4ea2:	80 93 be 04 	sts	0x04BE, r24
				}
				taskEXIT_CRITICAL();
    4ea6:	0f 90       	pop	r0
    4ea8:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4eaa:	89 81       	ldd	r24, Y+1	; 0x01
    4eac:	9a 81       	ldd	r25, Y+2	; 0x02
    4eae:	0e 94 f8 27 	call	0x4ff0	; 0x4ff0 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    4eb2:	0f 90       	pop	r0
    4eb4:	0f 90       	pop	r0
    4eb6:	0f 90       	pop	r0
    4eb8:	cf 91       	pop	r28
    4eba:	df 91       	pop	r29
    4ebc:	08 95       	ret

00004ebe <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    4ebe:	df 93       	push	r29
    4ec0:	cf 93       	push	r28
    4ec2:	00 d0       	rcall	.+0      	; 0x4ec4 <prvAddCurrentTaskToDelayedList+0x6>
    4ec4:	cd b7       	in	r28, 0x3d	; 61
    4ec6:	de b7       	in	r29, 0x3e	; 62
    4ec8:	9a 83       	std	Y+2, r25	; 0x02
    4eca:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4ecc:	e0 91 bc 04 	lds	r30, 0x04BC
    4ed0:	f0 91 bd 04 	lds	r31, 0x04BD
    4ed4:	89 81       	ldd	r24, Y+1	; 0x01
    4ed6:	9a 81       	ldd	r25, Y+2	; 0x02
    4ed8:	93 83       	std	Z+3, r25	; 0x03
    4eda:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4edc:	20 91 c0 04 	lds	r18, 0x04C0
    4ee0:	30 91 c1 04 	lds	r19, 0x04C1
    4ee4:	89 81       	ldd	r24, Y+1	; 0x01
    4ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    4ee8:	82 17       	cp	r24, r18
    4eea:	93 07       	cpc	r25, r19
    4eec:	70 f4       	brcc	.+28     	; 0x4f0a <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4eee:	80 91 02 05 	lds	r24, 0x0502
    4ef2:	90 91 03 05 	lds	r25, 0x0503
    4ef6:	20 91 bc 04 	lds	r18, 0x04BC
    4efa:	30 91 bd 04 	lds	r19, 0x04BD
    4efe:	2e 5f       	subi	r18, 0xFE	; 254
    4f00:	3f 4f       	sbci	r19, 0xFF	; 255
    4f02:	b9 01       	movw	r22, r18
    4f04:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vListInsert>
    4f08:	1e c0       	rjmp	.+60     	; 0x4f46 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4f0a:	40 91 00 05 	lds	r20, 0x0500
    4f0e:	50 91 01 05 	lds	r21, 0x0501
    4f12:	80 91 bc 04 	lds	r24, 0x04BC
    4f16:	90 91 bd 04 	lds	r25, 0x04BD
    4f1a:	9c 01       	movw	r18, r24
    4f1c:	2e 5f       	subi	r18, 0xFE	; 254
    4f1e:	3f 4f       	sbci	r19, 0xFF	; 255
    4f20:	ca 01       	movw	r24, r20
    4f22:	b9 01       	movw	r22, r18
    4f24:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4f28:	20 91 81 00 	lds	r18, 0x0081
    4f2c:	30 91 82 00 	lds	r19, 0x0082
    4f30:	89 81       	ldd	r24, Y+1	; 0x01
    4f32:	9a 81       	ldd	r25, Y+2	; 0x02
    4f34:	82 17       	cp	r24, r18
    4f36:	93 07       	cpc	r25, r19
    4f38:	30 f4       	brcc	.+12     	; 0x4f46 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4f3a:	89 81       	ldd	r24, Y+1	; 0x01
    4f3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f3e:	90 93 82 00 	sts	0x0082, r25
    4f42:	80 93 81 00 	sts	0x0081, r24
		}
	}
}
    4f46:	0f 90       	pop	r0
    4f48:	0f 90       	pop	r0
    4f4a:	cf 91       	pop	r28
    4f4c:	df 91       	pop	r29
    4f4e:	08 95       	ret

00004f50 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    4f50:	df 93       	push	r29
    4f52:	cf 93       	push	r28
    4f54:	cd b7       	in	r28, 0x3d	; 61
    4f56:	de b7       	in	r29, 0x3e	; 62
    4f58:	28 97       	sbiw	r28, 0x08	; 8
    4f5a:	0f b6       	in	r0, 0x3f	; 63
    4f5c:	f8 94       	cli
    4f5e:	de bf       	out	0x3e, r29	; 62
    4f60:	0f be       	out	0x3f, r0	; 63
    4f62:	cd bf       	out	0x3d, r28	; 61
    4f64:	9c 83       	std	Y+4, r25	; 0x04
    4f66:	8b 83       	std	Y+3, r24	; 0x03
    4f68:	7e 83       	std	Y+6, r23	; 0x06
    4f6a:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4f6c:	81 e2       	ldi	r24, 0x21	; 33
    4f6e:	90 e0       	ldi	r25, 0x00	; 0
    4f70:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <pvPortMalloc>
    4f74:	9a 83       	std	Y+2, r25	; 0x02
    4f76:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4f78:	89 81       	ldd	r24, Y+1	; 0x01
    4f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f7c:	00 97       	sbiw	r24, 0x00	; 0
    4f7e:	69 f1       	breq	.+90     	; 0x4fda <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    4f80:	8d 81       	ldd	r24, Y+5	; 0x05
    4f82:	9e 81       	ldd	r25, Y+6	; 0x06
    4f84:	00 97       	sbiw	r24, 0x00	; 0
    4f86:	39 f4       	brne	.+14     	; 0x4f96 <prvAllocateTCBAndStack+0x46>
    4f88:	8b 81       	ldd	r24, Y+3	; 0x03
    4f8a:	9c 81       	ldd	r25, Y+4	; 0x04
    4f8c:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <pvPortMalloc>
    4f90:	98 87       	std	Y+8, r25	; 0x08
    4f92:	8f 83       	std	Y+7, r24	; 0x07
    4f94:	04 c0       	rjmp	.+8      	; 0x4f9e <prvAllocateTCBAndStack+0x4e>
    4f96:	8d 81       	ldd	r24, Y+5	; 0x05
    4f98:	9e 81       	ldd	r25, Y+6	; 0x06
    4f9a:	98 87       	std	Y+8, r25	; 0x08
    4f9c:	8f 83       	std	Y+7, r24	; 0x07
    4f9e:	e9 81       	ldd	r30, Y+1	; 0x01
    4fa0:	fa 81       	ldd	r31, Y+2	; 0x02
    4fa2:	8f 81       	ldd	r24, Y+7	; 0x07
    4fa4:	98 85       	ldd	r25, Y+8	; 0x08
    4fa6:	90 8f       	std	Z+24, r25	; 0x18
    4fa8:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    4faa:	e9 81       	ldd	r30, Y+1	; 0x01
    4fac:	fa 81       	ldd	r31, Y+2	; 0x02
    4fae:	87 89       	ldd	r24, Z+23	; 0x17
    4fb0:	90 8d       	ldd	r25, Z+24	; 0x18
    4fb2:	00 97       	sbiw	r24, 0x00	; 0
    4fb4:	39 f4       	brne	.+14     	; 0x4fc4 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4fb6:	89 81       	ldd	r24, Y+1	; 0x01
    4fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fba:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <vPortFree>
			pxNewTCB = NULL;
    4fbe:	1a 82       	std	Y+2, r1	; 0x02
    4fc0:	19 82       	std	Y+1, r1	; 0x01
    4fc2:	0b c0       	rjmp	.+22     	; 0x4fda <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    4fc4:	e9 81       	ldd	r30, Y+1	; 0x01
    4fc6:	fa 81       	ldd	r31, Y+2	; 0x02
    4fc8:	87 89       	ldd	r24, Z+23	; 0x17
    4fca:	90 8d       	ldd	r25, Z+24	; 0x18
    4fcc:	2b 81       	ldd	r18, Y+3	; 0x03
    4fce:	3c 81       	ldd	r19, Y+4	; 0x04
    4fd0:	65 ea       	ldi	r22, 0xA5	; 165
    4fd2:	70 e0       	ldi	r23, 0x00	; 0
    4fd4:	a9 01       	movw	r20, r18
    4fd6:	0e 94 84 28 	call	0x5108	; 0x5108 <memset>
		}
	}

	return pxNewTCB;
    4fda:	89 81       	ldd	r24, Y+1	; 0x01
    4fdc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4fde:	28 96       	adiw	r28, 0x08	; 8
    4fe0:	0f b6       	in	r0, 0x3f	; 63
    4fe2:	f8 94       	cli
    4fe4:	de bf       	out	0x3e, r29	; 62
    4fe6:	0f be       	out	0x3f, r0	; 63
    4fe8:	cd bf       	out	0x3d, r28	; 61
    4fea:	cf 91       	pop	r28
    4fec:	df 91       	pop	r29
    4fee:	08 95       	ret

00004ff0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    4ff0:	df 93       	push	r29
    4ff2:	cf 93       	push	r28
    4ff4:	00 d0       	rcall	.+0      	; 0x4ff6 <prvDeleteTCB+0x6>
    4ff6:	cd b7       	in	r28, 0x3d	; 61
    4ff8:	de b7       	in	r29, 0x3e	; 62
    4ffa:	9a 83       	std	Y+2, r25	; 0x02
    4ffc:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    4ffe:	e9 81       	ldd	r30, Y+1	; 0x01
    5000:	fa 81       	ldd	r31, Y+2	; 0x02
    5002:	87 89       	ldd	r24, Z+23	; 0x17
    5004:	90 8d       	ldd	r25, Z+24	; 0x18
    5006:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <vPortFree>
		vPortFree( pxTCB );
    500a:	89 81       	ldd	r24, Y+1	; 0x01
    500c:	9a 81       	ldd	r25, Y+2	; 0x02
    500e:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <vPortFree>
	}
    5012:	0f 90       	pop	r0
    5014:	0f 90       	pop	r0
    5016:	cf 91       	pop	r28
    5018:	df 91       	pop	r29
    501a:	08 95       	ret

0000501c <__udivmodhi4>:
    501c:	aa 1b       	sub	r26, r26
    501e:	bb 1b       	sub	r27, r27
    5020:	51 e1       	ldi	r21, 0x11	; 17
    5022:	07 c0       	rjmp	.+14     	; 0x5032 <__udivmodhi4_ep>

00005024 <__udivmodhi4_loop>:
    5024:	aa 1f       	adc	r26, r26
    5026:	bb 1f       	adc	r27, r27
    5028:	a6 17       	cp	r26, r22
    502a:	b7 07       	cpc	r27, r23
    502c:	10 f0       	brcs	.+4      	; 0x5032 <__udivmodhi4_ep>
    502e:	a6 1b       	sub	r26, r22
    5030:	b7 0b       	sbc	r27, r23

00005032 <__udivmodhi4_ep>:
    5032:	88 1f       	adc	r24, r24
    5034:	99 1f       	adc	r25, r25
    5036:	5a 95       	dec	r21
    5038:	a9 f7       	brne	.-22     	; 0x5024 <__udivmodhi4_loop>
    503a:	80 95       	com	r24
    503c:	90 95       	com	r25
    503e:	bc 01       	movw	r22, r24
    5040:	cd 01       	movw	r24, r26
    5042:	08 95       	ret

00005044 <__udivmodsi4>:
    5044:	a1 e2       	ldi	r26, 0x21	; 33
    5046:	1a 2e       	mov	r1, r26
    5048:	aa 1b       	sub	r26, r26
    504a:	bb 1b       	sub	r27, r27
    504c:	fd 01       	movw	r30, r26
    504e:	0d c0       	rjmp	.+26     	; 0x506a <__udivmodsi4_ep>

00005050 <__udivmodsi4_loop>:
    5050:	aa 1f       	adc	r26, r26
    5052:	bb 1f       	adc	r27, r27
    5054:	ee 1f       	adc	r30, r30
    5056:	ff 1f       	adc	r31, r31
    5058:	a2 17       	cp	r26, r18
    505a:	b3 07       	cpc	r27, r19
    505c:	e4 07       	cpc	r30, r20
    505e:	f5 07       	cpc	r31, r21
    5060:	20 f0       	brcs	.+8      	; 0x506a <__udivmodsi4_ep>
    5062:	a2 1b       	sub	r26, r18
    5064:	b3 0b       	sbc	r27, r19
    5066:	e4 0b       	sbc	r30, r20
    5068:	f5 0b       	sbc	r31, r21

0000506a <__udivmodsi4_ep>:
    506a:	66 1f       	adc	r22, r22
    506c:	77 1f       	adc	r23, r23
    506e:	88 1f       	adc	r24, r24
    5070:	99 1f       	adc	r25, r25
    5072:	1a 94       	dec	r1
    5074:	69 f7       	brne	.-38     	; 0x5050 <__udivmodsi4_loop>
    5076:	60 95       	com	r22
    5078:	70 95       	com	r23
    507a:	80 95       	com	r24
    507c:	90 95       	com	r25
    507e:	9b 01       	movw	r18, r22
    5080:	ac 01       	movw	r20, r24
    5082:	bd 01       	movw	r22, r26
    5084:	cf 01       	movw	r24, r30
    5086:	08 95       	ret

00005088 <__prologue_saves__>:
    5088:	2f 92       	push	r2
    508a:	3f 92       	push	r3
    508c:	4f 92       	push	r4
    508e:	5f 92       	push	r5
    5090:	6f 92       	push	r6
    5092:	7f 92       	push	r7
    5094:	8f 92       	push	r8
    5096:	9f 92       	push	r9
    5098:	af 92       	push	r10
    509a:	bf 92       	push	r11
    509c:	cf 92       	push	r12
    509e:	df 92       	push	r13
    50a0:	ef 92       	push	r14
    50a2:	ff 92       	push	r15
    50a4:	0f 93       	push	r16
    50a6:	1f 93       	push	r17
    50a8:	cf 93       	push	r28
    50aa:	df 93       	push	r29
    50ac:	cd b7       	in	r28, 0x3d	; 61
    50ae:	de b7       	in	r29, 0x3e	; 62
    50b0:	ca 1b       	sub	r28, r26
    50b2:	db 0b       	sbc	r29, r27
    50b4:	0f b6       	in	r0, 0x3f	; 63
    50b6:	f8 94       	cli
    50b8:	de bf       	out	0x3e, r29	; 62
    50ba:	0f be       	out	0x3f, r0	; 63
    50bc:	cd bf       	out	0x3d, r28	; 61
    50be:	09 94       	ijmp

000050c0 <__epilogue_restores__>:
    50c0:	2a 88       	ldd	r2, Y+18	; 0x12
    50c2:	39 88       	ldd	r3, Y+17	; 0x11
    50c4:	48 88       	ldd	r4, Y+16	; 0x10
    50c6:	5f 84       	ldd	r5, Y+15	; 0x0f
    50c8:	6e 84       	ldd	r6, Y+14	; 0x0e
    50ca:	7d 84       	ldd	r7, Y+13	; 0x0d
    50cc:	8c 84       	ldd	r8, Y+12	; 0x0c
    50ce:	9b 84       	ldd	r9, Y+11	; 0x0b
    50d0:	aa 84       	ldd	r10, Y+10	; 0x0a
    50d2:	b9 84       	ldd	r11, Y+9	; 0x09
    50d4:	c8 84       	ldd	r12, Y+8	; 0x08
    50d6:	df 80       	ldd	r13, Y+7	; 0x07
    50d8:	ee 80       	ldd	r14, Y+6	; 0x06
    50da:	fd 80       	ldd	r15, Y+5	; 0x05
    50dc:	0c 81       	ldd	r16, Y+4	; 0x04
    50de:	1b 81       	ldd	r17, Y+3	; 0x03
    50e0:	aa 81       	ldd	r26, Y+2	; 0x02
    50e2:	b9 81       	ldd	r27, Y+1	; 0x01
    50e4:	ce 0f       	add	r28, r30
    50e6:	d1 1d       	adc	r29, r1
    50e8:	0f b6       	in	r0, 0x3f	; 63
    50ea:	f8 94       	cli
    50ec:	de bf       	out	0x3e, r29	; 62
    50ee:	0f be       	out	0x3f, r0	; 63
    50f0:	cd bf       	out	0x3d, r28	; 61
    50f2:	ed 01       	movw	r28, r26
    50f4:	08 95       	ret

000050f6 <memcpy>:
    50f6:	fb 01       	movw	r30, r22
    50f8:	dc 01       	movw	r26, r24
    50fa:	02 c0       	rjmp	.+4      	; 0x5100 <memcpy+0xa>
    50fc:	01 90       	ld	r0, Z+
    50fe:	0d 92       	st	X+, r0
    5100:	41 50       	subi	r20, 0x01	; 1
    5102:	50 40       	sbci	r21, 0x00	; 0
    5104:	d8 f7       	brcc	.-10     	; 0x50fc <memcpy+0x6>
    5106:	08 95       	ret

00005108 <memset>:
    5108:	dc 01       	movw	r26, r24
    510a:	01 c0       	rjmp	.+2      	; 0x510e <memset+0x6>
    510c:	6d 93       	st	X+, r22
    510e:	41 50       	subi	r20, 0x01	; 1
    5110:	50 40       	sbci	r21, 0x00	; 0
    5112:	e0 f7       	brcc	.-8      	; 0x510c <memset+0x4>
    5114:	08 95       	ret

00005116 <strncpy>:
    5116:	fb 01       	movw	r30, r22
    5118:	dc 01       	movw	r26, r24
    511a:	41 50       	subi	r20, 0x01	; 1
    511c:	50 40       	sbci	r21, 0x00	; 0
    511e:	48 f0       	brcs	.+18     	; 0x5132 <strncpy+0x1c>
    5120:	01 90       	ld	r0, Z+
    5122:	0d 92       	st	X+, r0
    5124:	00 20       	and	r0, r0
    5126:	c9 f7       	brne	.-14     	; 0x511a <strncpy+0x4>
    5128:	01 c0       	rjmp	.+2      	; 0x512c <strncpy+0x16>
    512a:	1d 92       	st	X+, r1
    512c:	41 50       	subi	r20, 0x01	; 1
    512e:	50 40       	sbci	r21, 0x00	; 0
    5130:	e0 f7       	brcc	.-8      	; 0x512a <strncpy+0x14>
    5132:	08 95       	ret

00005134 <_exit>:
    5134:	f8 94       	cli

00005136 <__stop_program>:
    5136:	ff cf       	rjmp	.-2      	; 0x5136 <__stop_program>
